# cython: language_level=3
# distutils: language=c++
#
# THIS FILE IS AUTO-GENERATED BY pxdgen - DO NOT EDIT
# Generated: 2025-11-30 01:47:20
# Source: nalt.hpp
#

from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libc.stdint cimport uint8_t, uint16_t, uint32_t, uint64_t
from libc.stdint cimport intptr_t, uintptr_t
from libc.stddef cimport size_t, ptrdiff_t
from libc.stdio cimport FILE
from libcpp cimport bool as cppbool

cdef extern from "nalt.hpp":
    # =========================================================================
    # Fundamental Types
    # =========================================================================
    ctypedef int64_t adiff_t
    ctypedef uint64_t asize_t
    ctypedef uint32_t bgcolor_t
    ctypedef uint64_t bmask_t
    ctypedef uint64_t ea_t
    ctypedef uint64_t enum_t
    ctypedef int32_t error_t
    ctypedef uint64_t flags64_t
    ctypedef uint32_t flags_t
    ctypedef int16_t int16
    ctypedef int32_t int32
    ctypedef int64_t int64
    ctypedef int8_t int8
    ctypedef uint64_t nodeidx_t
    ctypedef uint8_t op_dtype_t
    ctypedef uint64_t sel_t
    ctypedef int8_t sint8
    ctypedef int64_t sval_t
    ctypedef uint64_t tid_t
    ctypedef uint8_t uchar
    ctypedef uint32_t uint
    ctypedef uint16_t uint16
    ctypedef uint32_t uint32
    ctypedef uint64_t uint64
    ctypedef uint8_t uint8
    ctypedef uint16_t ushort
    ctypedef uint64_t uval_t

    # =========================================================================
    # Typedefs
    # =========================================================================
    ctypedef uint64 ulonglong
    ctypedef int64 longlong
    ctypedef uint16 wchar16_t
    ctypedef uint32 wchar32_t
    ctypedef uint32 ea32_t
    ctypedef uint64 ea64_t
    ctypedef uval_t inode_t  # The inode_t type is the specialization specific inode...
    ctypedef asize_t diffpos_t  # A position in the difference source. This is an abstract...
    ctypedef int sizevec_t
    ctypedef int qhandle_t
    ctypedef uchar comp_t  # ---------------------------------------------------------...
    ctypedef uchar cm_t
    ctypedef uint32 callcnv_t
    ctypedef int16_t int_least16_t
    ctypedef int32_t int_least32_t
    ctypedef int64_t int_least64_t
    ctypedef uint8_t uint_least8_t
    ctypedef uint16_t uint_least16_t
    ctypedef uint32_t uint_least32_t
    ctypedef uint64_t uint_least64_t
    ctypedef int8_t int_fast8_t
    ctypedef int16_t int_fast16_t
    ctypedef int32_t int_fast32_t
    ctypedef int64_t int_fast64_t
    ctypedef uint8_t uint_fast8_t
    ctypedef uint16_t uint_fast16_t
    ctypedef uint32_t uint_fast32_t
    ctypedef uint64_t uint_fast64_t
    ctypedef int64_t quad_t
    ctypedef quad_t* qaddr_t
    ctypedef int32_t swblk_t
    ctypedef uint64 nodeidx64_t
    ctypedef uint32 nodeidx32_t
    ctypedef flags_t aflags_t  #  See
    ctypedef uchar reftype_t  # @ }
    ctypedef uchar type_t  # ---------------------------------------------------------...
    ctypedef uchar p_list

    # =========================================================================
    # Enums
    # =========================================================================
    cdef enum:
        pool_size
        pool_nelems
    cdef enum tty_control_t:  # Teletype control
        TCT_UNKNOWN
        TCT_OWNER
        TCT_NOT_OWNER
    cdef enum range_kind_t:  # ---------------------------------------------------------...
        RANGE_KIND_UNKNOWN
        RANGE_KIND_FUNC
        RANGE_KIND_SEGMENT
        RANGE_KIND_HIDDEN_RANGE
    cdef enum filetype_t:  # ---------------------------------------------------------...
        f_EXE_old  # MS DOS EXE File
        f_COM_old  # MS DOS COM File
        f_BIN  # Binary File
        f_DRV  # MS DOS Driver
        f_WIN  # New Executable (NE)
        f_HEX  # Intel Hex Object File
        f_MEX  # MOS Technology Hex Object File
        f_LX  # Linear Executable (LX)
        f_LE  # Linear Executable (LE)
        f_NLM  # Netware Loadable Module (NLM)
        f_COFF  # Common Object File Format (COFF)
        f_PE  # Portable Executable (PE)
        f_OMF  # Object Module Format
        f_SREC  # Motorola SREC (S-record)
        f_ZIP  # ZIP file (this file is never loaded to IDA database)
        f_OMFLIB  # Library of OMF Modules
        f_AR  # ar library
        f_LOADER  # file is loaded using LOADER DLL
        f_ELF  # Executable and Linkable Format (ELF)
        f_W32RUN  # Watcom DOS32 Extender (W32RUN)
        f_AOUT  # Linux a.out (AOUT)
        f_PRC  # PalmPilot program file
        f_EXE  # MS DOS EXE File
        f_COM  # MS DOS COM File
        f_AIXAR  # AIX ar library
        f_MACHO  # Mac OS X Mach-O
        f_PSXOBJ  # Sony Playstation PSX object file
        f_MD1IMG  # Mediatek Firmware Image
    cdef enum storage_type_t:  # ---------------------------------------------------------...
        STT_CUR = -1  # use current storage type (may be used only as...
        STT_VA = 0  # regular storage: virtual arrays, an explicit...
        STT_MM = 1  # memory map: sparse storage. useful for huge objects
        STT_DBG = 2  # memory map: temporary debugger storage. used internally
    cdef enum inftag_t:
        INF_VERSION
        INF_PROCNAME
        INF_GENFLAGS
        INF_LFLAGS
        INF_DATABASE_CHANGE_COUNT
        INF_FILETYPE
        INF_OSTYPE
        INF_APPTYPE
        INF_ASMTYPE
        INF_SPECSEGS
        INF_AF
        INF_AF2
        INF_BASEADDR
        INF_START_SS
        INF_START_CS
        INF_START_IP
        INF_START_EA
        INF_START_SP
        INF_MAIN
        INF_MIN_EA
        INF_MAX_EA
        INF_OMIN_EA
        INF_OMAX_EA
        INF_LOWOFF
        INF_HIGHOFF
        INF_MAXREF
        INF_PRIVRANGE
        INF_PRIVRANGE_START_EA
        INF_PRIVRANGE_END_EA
        INF_NETDELTA
        INF_XREFNUM
        INF_TYPE_XREFNUM
        INF_REFCMTNUM
        INF_XREFFLAG
        INF_MAX_AUTONAME_LEN
        INF_NAMETYPE
        INF_SHORT_DEMNAMES
        INF_LONG_DEMNAMES
        INF_DEMNAMES
        INF_LISTNAMES
        INF_INDENT
        INF_CMT_INDENT
        INF_MARGIN
        INF_LENXREF
        INF_OUTFLAGS
        INF_CMTFLG
        INF_LIMITER
        INF_BIN_PREFIX_SIZE
        INF_PREFFLAG
        INF_STRLIT_FLAGS
        INF_STRLIT_BREAK
        INF_STRLIT_ZEROES
        INF_STRTYPE
        INF_STRLIT_PREF
        INF_STRLIT_SERNUM
        INF_DATATYPES
        INF_OBSOLETE_CC
        INF_CC_ID
        INF_CC_CM
        INF_CC_SIZE_I
        INF_CC_SIZE_B
        INF_CC_SIZE_E
        INF_CC_DEFALIGN
        INF_CC_SIZE_S
        INF_CC_SIZE_L
        INF_CC_SIZE_LL
        INF_CC_SIZE_LDBL
        INF_ABIBITS
        INF_APPCALL_OPTIONS
        INF_FILE_FORMAT_NAME  # file format name for loader modules
        INF_GROUPS  # segment group information (see init_groups())
        INF_H_PATH  # C header path
        INF_C_MACROS  # C predefined macros
        INF_INCLUDE  # assembler include file name
        INF_DUALOP_GRAPH  # Graph text representation options
        INF_DUALOP_TEXT  # Text text representation options
        INF_MD5  # MD5 of the input file
        INF_IDA_VERSION  # version of ida which created the database
        INF_STR_ENCODINGS  # a list of encodings for the program strings
        INF_DBG_BINPATHS  # unused (20 indexes)
        INF_SHA256  # SHA256 of the input file
        INF_ABINAME  # ABI name (processor specific)
        INF_ARCHIVE_PATH  # archive file path
        INF_PROBLEMS  # problem lists
        INF_SELECTORS  # 2..63 are for selector_t blob (see init_selectors())
        INF_NOTEPAD  # notepad blob, occupies 1000 indexes (1MB of text)
        INF_SRCDBG_PATHS  # source debug paths, occupies 20 indexes
        INF_SRCDBG_UNDESIRED  # user-closed source files, occupies 20 indexes
        INF_INITIAL_VERSION  # initial version of database
        INF_CTIME  # database creation timestamp
        INF_ELAPSED  # seconds database stayed open
        INF_NOPENS  # how many times the database is opened
        INF_CRC32  # input file crc32
        INF_IMAGEBASE  # image base
        INF_IDSNODE  # ids modnode id (for import_module)
        INF_FSIZE  # input file size
        INF_OUTFILEENC  # output file encoding index
        INF_INPUT_FILE_PATH
        INF_COMPILER_INFO  # more inf fields
        INF_CALLCNV  # more inf fields
        INF_LAST  # more inf fields
    cdef enum hook_type_t:  # ---------------------------------------------------------...
        HT_IDP  # Hook to the processor module. The callback...
        HT_UI  # Hook to the user interface. The callback will...
        HT_DBG  # Hook to the debugger. The callback will...
        HT_IDB  # Hook to the database events. These events are...
        HT_DEV  # Internal debugger events. Not stable and...
        HT_VIEW  # Custom/IDA views notifications. Refer to...
        HT_OUTPUT  # Output window notifications. Refer to...
        HT_GRAPH  # Handling graph operations (::graph_notification_t)
        HT_IDD  # Hook to the debugger plugin. The callback will...
        HT_LAST
    cdef enum:
        QOS_CLASS_USER_INTERACTIVE = 33
        QOS_CLASS_USER_INITIATED = 25
        QOS_CLASS_DEFAULT = 21
        QOS_CLASS_UTILITY = 17
        QOS_CLASS_BACKGROUND = 9
        QOS_CLASS_UNSPECIFIED = 0
    cdef enum:
        SWITCH_INFO_VERSION

    # =========================================================================
    # Template Classes
    # =========================================================================
    cdef cppclass qvector[T]:
        qvector() except +
        qvector(const qvector[T]& x) except +
        T& operator[](size_t idx)
        T& at(size_t idx)
        T& front()
        T& back()
        size_t size() const
        bint empty() const
        size_t capacity() const
        void reserve(size_t cnt) except +
        void push_back(const T& x) except +
        void pop_back() except +
        void clear() except +
        void resize(size_t newsize) except +
        void swap(qvector[T]& r) except +
        ctypedef T* iterator
        ctypedef const T* const_iterator
        iterator begin()
        iterator end()
        iterator erase(iterator it) except +
        iterator insert(iterator it, const T& x) except +
        const T* find(const T& x) const
        bint has(const T& x) const
        bint add_unique(const T& x) except +
    cdef cppclass _qstring[T]:
        _qstring() except +
        _qstring(const T* ptr) except +
        _qstring(const _qstring[T]& r) except +
        size_t length() const
        size_t size() const
        bint empty() const
        const T* c_str() const
        T& operator[](size_t idx)
        void clear() except +
        void resize(size_t newsize, T c) except +
        _qstring[T]& append(const T* ptr) except +
        _qstring[T]& append(const _qstring[T]& r) except +
        size_t find(const T* str, size_t pos) const
        size_t find(T c, size_t pos) const
        _qstring[T] substr(size_t pos, size_t len) except +
        bint operator==(const _qstring[T]& r) const
        bint operator!=(const _qstring[T]& r) const
        int compare(const _qstring[T]& r) const
    cdef cppclass qstack[T](qvector[T]):
        T& top()
        void push(const T& x) except +
        T pop() except +
    cdef cppclass qrefcnt_t[T]:
        qrefcnt_t() except +
        qrefcnt_t(T* p) except +
        qrefcnt_t(const qrefcnt_t[T]& r) except +
        T& operator*()
        bint operator==(const qrefcnt_t[T]& r) const
        bint operator!=(const qrefcnt_t[T]& r) const
        void reset()
        T* release()
        T* get()

    # =========================================================================
    # Template Instantiation Typedefs
    # =========================================================================
    ctypedef _qstring[char] qstring  # IDA string type
    ctypedef qvector[uint8_t] bytevec_t  # Vector of bytes
    ctypedef qvector[int] intvec_t  # Vector of ints
    ctypedef qvector[ea_t] eavec_t  # Vector of addresses
    ctypedef qvector[sval_t] svalvec_t  # Vector of signed values
    ctypedef qvector[uval_t] uvalvec_t  # Vector of unsigned values
    ctypedef qvector[qstring] qstrvec_t  # Vector of strings
    ctypedef qvector[bint] boolvec_t  # Vector of bools
    ctypedef qvector[sval_t] casevec_t  # Vector of case values
    ctypedef _qstring[uchar] qtype
    ctypedef _qstring[wchar16_t] qwstring
    ctypedef qvector[channel_redir_t] channel_redirs_t
    ctypedef qvector[plugin_option_t] plugin_option_vec_t
    ctypedef qvector[range_t] rangevec_base_t
    ctypedef qvector[rangeset_t] array_of_rangesets
    ctypedef qvector[rangeset_t*] rangeset_crefvec_t
    ctypedef qvector[callcnv_t] callcnvs_t
    ctypedef qvector[refinfo_desc_t] refinfo_desc_vec_t

    # =========================================================================
    # Forward Declarations
    # =========================================================================
    cdef cppclass cliopt_handler_t
    cdef cppclass enum__t
    cdef cppclass fd_set
    cdef cppclass iterator
    cdef cppclass qmutex_t
    cdef cppclass usage_printer_t

    # =========================================================================
    # Classes
    # =========================================================================
    cdef cppclass ida_movable_type
    cdef cppclass qrefcnt_obj_t:  # ------------------------------------------------------------
        int refcnt  # counter
        qrefcnt_obj_t()  # Constructor
        void release()  # Call destructor. We use release() instead of opera
        qrefcnt_obj_t& operator=(qrefcnt_obj_t&)
        qrefcnt_obj_t& operator=(qrefcnt_obj_t&&)
    cdef cppclass reloc_info_t:  # Relocation information (relocatable objects - see ::relobj_t
        pass
    cdef cppclass relobj_t:  # Relocatable object
        ea_t base  # current base
        reloc_info_t ri  # relocation info
        relobj_t()
        bint relocate(ea_t ea, bint mf)
    cdef cppclass qlist
    cdef cppclass listnode_t:
        listnode_t* next
        listnode_t* prev
        void fix_links(int len)
    cdef cppclass const_iterator
    cdef cppclass linput_t
    cdef cppclass channel_redir_t:  # Tools for command line parsing
        int fd  # channel number
        qstring file  # file name to redirect to/from. if empty, the chann
        int flags
        int start  # begin of the redirection string in the command lin
        int length  # length of the redirection string in the command li
        bint is_input() const  # @ }
        bint is_output() const
        bint is_append() const
        bint is_quoted() const
    cdef cppclass cliopt_t:
        char shortname
        char* longname
        char* help
        int nargs  # number of arguments. Can be 0, 1 or -1. If '-1', i
    cdef cppclass cliopts_t:
        qstring prog_name
        qstring epilog
        bint print_usage
        void add(cliopt_t* opts, int nopts)
        int apply(int argc, char** argv, void* ud)
        cliopt_t* find_short(char shortname) const
        cliopt_t* find_long(char* longname) const
        void usage(bint is_error) const
    cdef cppclass plugin_option_t:  # Named option, supports two kinds of options: string option: 
        qstring name
        qstring value
        char* get_value(char* default_value) const
        bint get_string(qstring* out, char* desired_name, char* default_value) const
        bint get_bool(bint* out, char* desired_name, bint default_value) const
    cdef cppclass plugin_options_t:
        plugin_option_t* find(qstring& name) const
        bint erase(char* name)
    cdef cppclass instant_dbgopts_t:  # Options for instant debugging
        qstring debmod  # name of debugger module
        qstring env  # config variables for debmod. example: DEFAULT_CPU=
        qstring host  # remote hostname (if remote debugging)
        qstring pass_  # password for the remote debugger server
        int port  # port number for the remote debugger server
        int pid  # process to attach to (-1: ask the user)
        int event_id  # event to trigger upon attaching
        bint attach  # should attach to a process?
    cdef cppclass launch_process_params_t:  # Information for launching a process with IDA API Note: all s
        int cb  # size of this structure
        int flags
        char* path  # file to run
        char* args  # command line arguments
        int in_handle  # handle for stdin or -1
        int out_handle  # handle for stdout or -1
        int err_handle  # handle for stderr or -1
        char* env  # zero separated environment variables that will be 
        char* startdir  # current directory for the new process
        void* info  # os specific info (on windows it points to PROCESS_
    cdef cppclass qmutex_locker_t:  # Mutex locker object. Will lock a given mutex upon creation a
        pass
    cdef cppclass range_t:  # ------------------------------------------------------------
        ea_t start_ea  # start_ea included
        ea_t end_ea  # end_ea excluded
        range_t(ea_t ea1, ea_t ea2)
        bint operator==(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator!=(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator<(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator>(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator<=(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator>=(range_t& r) const  # Compare two range_t instances, based on the start_
        int compare(range_t& r) const  # Compare two range_t instances, based on the start_
        bint contains(ea_t ea) const  # Is 'ea' in the address range?
        bint contains(range_t& r) const  # Is every ea in 'r' also in this range_t?
        bint overlaps(range_t& r) const  # Is there an ea in 'r' that is also in this range_t
        void clear()  # Set #start_ea, #end_ea to 0
        bint empty() const  # Is the size of the range_t < = 0?
        asize_t size() const  # Get #end_ea - #start_ea
        void intersect(range_t& r)  # Assign the range_t to the intersection between the
        void extend(ea_t ea)  # Ensure that the range_t includes 'ea'
        int print(char* buf, int bufsize) const  # Print the range_t. 
        range_t(range_t&)
        range_t(range_t&&)
        range_t& operator=(range_t&)
        range_t& operator=(range_t&&)
    cdef cppclass rangevec_t:
        pass
    cdef cppclass rangeset_t:  # An ordered set of non-overlapping address ranges
        rangeset_t()  # Constructor
        rangeset_t(range_t& range)  # Constructor - Initialize set with 'range'
        rangeset_t(rangeset_t& ivs)  # Constructor - Initialize set with 'ivs'
        rangeset_t& operator=(rangeset_t& ivs)
        void swap(rangeset_t& r)  # Set this = 'r' and 'r' = this. See qvector::swap()
        bint add(range_t& range)  # Add an address range to the set. If 'range' inters
        bint add(ea_t start, ea_t _end)  # Create a new range_t from 'start' and 'end' and ad
        bint add(rangeset_t& aset)  # Add each element of 'aset' to the set. 
        bint sub(range_t& range)  # Subtract an address range from the set. All subset
        bint sub(ea_t ea)  # Subtract an ea (an range of size 1) from the set. 
        bint sub(rangeset_t& aset)  # Subtract each range in 'aset' from the set 
        bint has_common(range_t& range) const  # Is there an ea in 'range' that is also in the rang
        bint includes(range_t& range) const  # Is every ea in 'range' contained in the rangeset?
        int print(char* buf, int bufsize) const  # Print each range_t in the rangeset
        asize_t count() const  # Size in bytes
        range_t& getrange(int idx) const  # Get the range_t at index 'idx'
        range_t& lastrange() const  # Get the last range_t in the set
        int nranges() const  # Get the number of range_t elements in the set
        bint empty() const  # Does the set have zero elements
        void clear()  # Delete all elements from the set. See qvector::cle
        bint has_common(rangeset_t& aset) const  # Does any element of 'aset' overlap with an element
        bint contains(ea_t ea) const  # Does an element of the rangeset contain 'ea'? See 
        bint contains(rangeset_t& aset) const  # Is every element in 'aset' contained in an element
        bint intersect(rangeset_t& aset)  # Set the rangeset to its intersection with 'aset'. 
        bint is_subset_of(rangeset_t& aset) const  # Is every element in the rangeset contained in an e
        bint is_equal(rangeset_t& aset) const  # Do this rangeset and 'aset' have identical element
        bint operator==(rangeset_t& aset) const
        bint operator!=(rangeset_t& aset) const
        const_iterator begin() const
        const_iterator end() const
        const_iterator lower_bound(ea_t ea) const  # Get the first range that contains at least one ea_
        const_iterator upper_bound(ea_t ea) const  # Get the first range such that every ea_t value in 
        range_t* find_range(ea_t ea) const  # Get the element from the set that contains 'ea'. 
        range_t* cached_range() const  # When searching the rangeset, we keep a cached elem
        ea_t next_addr(ea_t ea) const  # Get the smallest ea_t value greater than 'ea' cont
        ea_t prev_addr(ea_t ea) const  # Get the largest ea_t value less than 'ea' containe
        ea_t next_range(ea_t ea) const  # Get the smallest ea_t value greater than 'ea' that
        ea_t prev_range(ea_t ea) const  # Get the largest ea_t value less than 'ea' that is 
        int move_chunk(ea_t from_, ea_t to, asize_t size)  # Subtract the address range (from, from+size) and a
        int check_move_args(ea_t from_, ea_t to, asize_t size)  # Check if the intended move_chunk() arguments are c
        rangevec_t& as_rangevec() const  # Return underlying rangevec_t object
    cdef cppclass range64_t:  # ------------------------------------------------------------
        uint64 start
        uint64 end
        range64_t(uint64 _start, uint64 _end)
        bint operator==(range64_t& r) const
        bint operator!=(range64_t& r) const
        bint operator<(range64_t& r) const
        bint operator>(range64_t& r) const
        bint operator<=(range64_t& r) const
        bint operator>=(range64_t& r) const
        int compare(range64_t& r) const
        bint contains(uint64 x) const
        bint contains(range64_t& r) const
        bint overlaps(range64_t& r) const
        void clear()
        bint empty() const
        uint64 size() const
        void intersect(range64_t& r)
        void extend(uint64 ea)
        range64_t(range64_t&)
        range64_t(range64_t&&)
    cdef cppclass range64vec_t:
        range64_t* find_range(uint64 off) const
    cdef cppclass plugin_t
    cdef cppclass plugmod_t
    cdef cppclass compiler_info_t:  # Information about the target compiler
        comp_t id  # compiler id (see
        cm_t cm  # memory model and calling convention (see see also 
        uchar size_i  # sizeof(int)
        uchar size_b  # sizeof(bool)
        uchar size_e  # sizeof(enum)
        uchar defalign  # default alignment for structures
        uchar size_s  # short
        uchar size_l  # long
        uchar size_ll  # longlong
        uchar size_ldbl  # longdouble (if different from
        callcnv_t _new_callcnv  # do not access directly; use get_cc/set_cc
        callcnv_t get_cc() const
        void set_cc(callcnv_t cc)
    cdef cppclass idainfo:
        char zero  # this field is not present in the database
        ushort version  # Version of database
        ushort s_genflags
        uint32 lflags
        uint32 database_change_count  # incremented after each byte and regular segment mo
        ushort filetype  # The input file type
        ushort ostype  # OS type the program is for bit definitions in libf
        ushort apptype  # Application type bit definitions in libfuncs.hpp
        uchar asmtype  # target assembler number
        uchar specsegs  # What format do special segments use? 0-unspecified
        uint32 af
        uint32 af2
        uval_t baseaddr  # base address of the program (paragraphs)
        sel_t start_ss  # selector of the initial stack segment
        sel_t start_cs  # selector of the segment with the main entry point
        ea_t start_ip  # IP register value at the start of program executio
        ea_t start_ea  # Linear address of program entry point
        ea_t start_sp  # SP register value at the start of program executio
        ea_t main  # address of main()
        ea_t min_ea  # current limits of program
        ea_t max_ea  # maxEA is excluded
        ea_t omin_ea  # original minEA (is set after loading the input fil
        ea_t omax_ea  # original maxEA (is set after loading the input fil
        ea_t lowoff  # Low  limit for offsets (used in calculation of 'vo
        ea_t highoff  # High limit for offsets (used in calculation of 'vo
        uval_t maxref  # Max tail for references
        range_t privrange  # Range of addresses reserved for internal use. Init
        sval_t netdelta  # Delta value to be added to all addresses for mappi
        uchar xrefnum  # Number of references to generate in the disassembl
        uchar type_xrefnum  # Number of references to generate in the struct & e
        uchar refcmtnum  # Number of comment lines to generate for refs to st
        uchar s_xrefflag
        ushort max_autoname_len  # max autogenerated name length (without zero byte)
        char nametype
        uint32 short_demnames  # short form of demangled names
        uint32 long_demnames  # long form of demangled names see demangle.h for de
        uchar demnames
        uchar listnames
        uchar indent  # Indentation for instructions
        uchar cmt_indent  # Indentation for comments
        ushort margin  # max length of data lines
        ushort lenxref  # max length of line with xrefs
        uint32 outflags
        uchar s_cmtflg
        uchar s_limiter
        short bin_prefix_size  # Number of instruction bytes (opcodes) to show in l
        uchar s_prefflag
        uchar strlit_flags
        uchar strlit_break  # string literal line break symbol
        char strlit_zeroes  # leading zeroes
        int32 strtype  # current ascii string type see nalt.hpp for string 
        uval_t strlit_sernum  # serial number
        uval_t datatypes  # data types allowed in data carousel
        compiler_info_t cc  # Target compiler
        uint32 abibits  # ABI features. Depends on info returned by get_abi_
        uint32 appcall_options  # appcall options, see idd.hpp
        uint32 padding
    cdef cppclass ea_helper_t:  # ------------------------------------------------------------
        uval_t mask32
        uval_t mask64
        uval_t mask
        int ea_size
        bint enabled  # can be disabled for old databases
        void setup(bint is_64bit)
        void disable()
        bint is_enabled() const
        sval_t ea2sval(uval_t v) const
        uval_t trunc_uval(uval_t v) const
        ea_t uval2ea(uval_t v) const
        bint fits_ea_space(ea_t ea) const
        bint fits_ea_space(range_t& r) const
        ea_t trunc_ea(ea_t ea) const
        ea_t ea_space_end() const
        ea_t to_ea(sel_t cs, uval_t ip) const
        ea_t fix_ea_tid(ea_t ea) const
        bint is_ea_add_ok(uval_t x, uval_t y) const
        sval_t sval_max() const
        sval_t sval_min() const
        bint like_badaddr(ea_t ea) const
        ea_t align_ea(ea_t ea, int size) const
        bint advance_ea(ea_t* ea, asize_t n) const
    cdef cppclass post_event_visitor_t:  # Implements action to take when the event was processed by th
        int handle_post_event(int code, int notification_code, int va)  # Action for post-event management. May change the r
        post_event_visitor_t& operator=(post_event_visitor_t&)
    cdef cppclass dbctx_t
    cdef cppclass idbattr_valmap_t:  # ------------------------------------------------------------
        uint64 value
        char* valname
    cdef cppclass idbattr_info_t:  # ------------------------------------------------------------
        char* name  # human-readable name. if null, then the field will 
        int offset  # field position: offset within a structure (IDI_STR
        int width  # field width in bytes
        uint64 bitmask  # mask for bitfields (0-not bitfield)
        uchar tag  # tag of node value (if IDI_NODEVAL is set)
        idbattr_valmap_t* vmap  # array value=>name (terminated by empty element)
        char* individual_node  # individual node name (nullptr - use default)
        uint idi_flags
        uint32 maxsize  # max bytes reserved for storage in netnode
        bint is_node_altval() const
        bint is_node_supval() const
        bint is_node_valobj() const
        bint is_node_blob() const
        bint is_node_var() const
        bint is_struc_field() const
        bint is_cstr() const
        bint is_qstring() const
        bint is_bytearray() const
        bint is_buf_var() const
        bint is_decimal() const
        bint is_hexadecimal() const
        bint is_readonly_var() const
        bint is_incremented() const
        bint is_val_mapped() const
        bint is_hash() const
        bint use_hlpstruc() const
        bint is_bitmap() const
        bint is_onoff() const
        bint is_scalar_var() const
        bint is_bitfield() const
        bint is_boolean() const
        bint has_individual_node() const
        char* str_true() const
        char* str_false() const
        int ridx() const
        char* hashname() const
        bint operator<(idbattr_info_t& r) const
    cdef cppclass _opaque_pthread_attr_t:
        long __sig
    cdef cppclass _opaque_pthread_cond_t:
        long __sig
        _opaque_pthread_cond_t(_opaque_pthread_cond_t&)
        _opaque_pthread_cond_t(_opaque_pthread_cond_t&&)
        _opaque_pthread_cond_t& operator=(_opaque_pthread_cond_t&)
        _opaque_pthread_cond_t& operator=(_opaque_pthread_cond_t&&)
    cdef cppclass _opaque_pthread_condattr_t:
        long __sig
    cdef cppclass _opaque_pthread_mutex_t:
        long __sig
        _opaque_pthread_mutex_t(_opaque_pthread_mutex_t&)
        _opaque_pthread_mutex_t(_opaque_pthread_mutex_t&&)
        _opaque_pthread_mutex_t& operator=(_opaque_pthread_mutex_t&)
        _opaque_pthread_mutex_t& operator=(_opaque_pthread_mutex_t&&)
    cdef cppclass _opaque_pthread_mutexattr_t:
        long __sig
        _opaque_pthread_mutexattr_t()
        _opaque_pthread_mutexattr_t(_opaque_pthread_mutexattr_t&)
        _opaque_pthread_mutexattr_t(_opaque_pthread_mutexattr_t&&)
    cdef cppclass _opaque_pthread_once_t:
        long __sig
    cdef cppclass _opaque_pthread_rwlock_t:
        long __sig
    cdef cppclass _opaque_pthread_rwlockattr_t:
        long __sig
    cdef cppclass _opaque_pthread_t:
        long __sig
    cdef cppclass exception_ptr:
        exception_ptr()
        exception_ptr(nullptr_t)
        exception_ptr(exception_ptr&)
        exception_ptr& operator=(exception_ptr&)
    cdef cppclass logic_error:
        logic_error(int&)
        logic_error(char*)
        logic_error(logic_error&)
        logic_error& operator=(logic_error&)
        char* what() const
    cdef cppclass runtime_error:
        runtime_error(int&)
        runtime_error(char*)
        runtime_error(runtime_error&)
        runtime_error& operator=(runtime_error&)
        char* what() const
    cdef cppclass domain_error:
        domain_error(int& __s)
        domain_error(char* __s)
        domain_error(domain_error&)
        domain_error& operator=(domain_error&)
    cdef cppclass invalid_argument:
        invalid_argument(int& __s)
        invalid_argument(char* __s)
        invalid_argument(invalid_argument&)
        invalid_argument& operator=(invalid_argument&)
    cdef cppclass length_error:
        length_error(int& __s)
        length_error(char* __s)
        length_error(length_error&)
        length_error& operator=(length_error&)
    cdef cppclass out_of_range:
        out_of_range(int& __s)
        out_of_range(char* __s)
        out_of_range(out_of_range&)
        out_of_range& operator=(out_of_range&)
    cdef cppclass range_error:
        range_error(int& __s)
        range_error(char* __s)
        range_error(range_error&)
        range_error& operator=(range_error&)
    cdef cppclass overflow_error:
        overflow_error(int& __s)
        overflow_error(char* __s)
        overflow_error(overflow_error&)
        overflow_error& operator=(overflow_error&)
    cdef cppclass underflow_error:
        underflow_error(int& __s)
        underflow_error(char* __s)
        underflow_error(underflow_error&)
        underflow_error& operator=(underflow_error&)
    cdef cppclass timespec:
        long tv_nsec
    cdef cppclass altadjust_visitor_t:  # visitor to be used by altadjust2 to skip the adjustment of s
        bint should_skip(nodeidx_t ea)
        altadjust_visitor_t& operator=(altadjust_visitor_t&)
        altadjust_visitor_t& operator=(altadjust_visitor_t&&)
    cdef cppclass netnode:  # Definition of the IDA database node. Note that the size of t
        netnode(nodeidx_t num)  # Constructor to create a netnode to access informat
        netnode(char* _name, size_t namlen, bint do_create)  # Construct an instance of netnode class to access t
        bint exist(char* _name)  # Does the netnode with the specified name exist?
        bint create(char* _name, size_t namlen)  # Create a named netnode. 
        bint create()  # Create unnamed netnode. 
        void kill()  # Delete a netnode with all information attached to 
        ssize_t get_name(qstring* buf) const  # Get the netnode name. 
        bint rename(char* newname, size_t namlen)  # Rename a netnode. 
        ssize_t valobj(void* buf, size_t bufsize) const  # Get value of netnode. Netnode values are arbitrary
        ssize_t valstr(qstring* buf) const  # Get string value of netnode. See explanations for 
        ssize_t valstr(char* buf, size_t bufsize) const
        bint set(void* value, size_t length)  # Set value of netnode. 
        bint delvalue()  # Delete value of netnode. 
        bint set_long(nodeidx_t x)  # Value of netnode as a long number:
        bint value_exists() const
        nodeidx_t long_value() const
        nodeidx_t altval(nodeidx_t alt, uchar tag) const  # Get altval element of the specified array. 
        nodeidx_t altval_ea(ea_t ea, uchar tag) const
        bint altset(nodeidx_t alt, nodeidx_t value, uchar tag)  # Set value of altval array. 
        bint altset_ea(ea_t ea, nodeidx_t value, uchar tag)
        bint altdel(nodeidx_t alt, uchar tag)  # Delete element of altval array. 
        bint altdel_ea(ea_t ea, uchar tag)
        bint easet(ea_t ea, ea_t addr, uchar tag)  # Store/retrieve/delete an address value in the netn
        ea_t eaget(ea_t ea, uchar tag) const
        bint eadel(ea_t ea, uchar tag)
        bint easet_idx(nodeidx_t idx, ea_t addr, uchar tag)
        ea_t eaget_idx(nodeidx_t idx, uchar tag)
        bint easet_idx8(uchar idx, ea_t addr, uchar tag)
        ea_t eaget_idx8(uchar idx, uchar tag) const
        bint eadel_idx8(uchar idx, uchar tag)
        nodeidx_t altfirst(uchar tag) const  # Get first existing element of altval array. 
        nodeidx_t altnext(nodeidx_t cur, uchar tag) const  # Get next existing element of altval array. 
        nodeidx_t altlast(uchar tag) const  # Get last element of altval array. 
        nodeidx_t altprev(nodeidx_t cur, uchar tag) const  # Get previous existing element of altval array. 
        size_t altshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the altval array elements. Moves the array e
        void altadjust2(nodeidx_t from_, nodeidx_t to, nodeidx_t size, altadjust_visitor_t& av)
        uchar charval(nodeidx_t alt, uchar tag) const  #  The following functions behave in the same manner
        bint charset(nodeidx_t alt, uchar val, uchar tag)
        bint chardel(nodeidx_t alt, uchar tag)
        uchar charval_ea(ea_t ea, uchar tag) const
        bint charset_ea(ea_t ea, uchar val, uchar tag)
        bint chardel_ea(ea_t ea, uchar tag)
        nodeidx_t charfirst(uchar tag) const
        nodeidx_t charnext(nodeidx_t cur, uchar tag) const
        nodeidx_t charlast(uchar tag) const
        nodeidx_t charprev(nodeidx_t cur, uchar tag) const
        size_t charshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)
        nodeidx_t altval_idx8(uchar alt, uchar tag) const  #  Another set of functions to work with altvals. Th
        bint altset_idx8(uchar alt, nodeidx_t val, uchar tag)
        bint altdel_idx8(uchar alt, uchar tag)
        nodeidx_t altfirst_idx8(uchar tag) const
        nodeidx_t altnext_idx8(uchar cur, uchar tag) const
        nodeidx_t altlast_idx8(uchar tag) const
        nodeidx_t altprev_idx8(uchar cur, uchar tag) const
        uchar charval_idx8(uchar alt, uchar tag) const  #  Another set of functions to work with altvals. - 
        bint charset_idx8(uchar alt, uchar val, uchar tag)
        bint chardel_idx8(uchar alt, uchar tag)
        nodeidx_t charfirst_idx8(uchar tag) const
        nodeidx_t charnext_idx8(uchar cur, uchar tag) const
        nodeidx_t charlast_idx8(uchar tag) const
        nodeidx_t charprev_idx8(uchar cur, uchar tag) const
        bint altdel()  # Delete all elements of altval array. This function
        bint altdel_all(uchar tag)  # Delete all elements of the specified altval array.
        ssize_t supval(nodeidx_t alt, void* buf, size_t bufsize, uchar tag) const  # Get value of the specified supval array element. N
        ssize_t supval_ea(ea_t ea, void* buf, size_t bufsize, uchar tag) const
        ssize_t supstr(qstring* buf, nodeidx_t alt, uchar tag) const  # Get string value of the specified supval array ele
        ssize_t supstr_ea(qstring* buf, ea_t ea, uchar tag) const
        ssize_t supstr(nodeidx_t alt, char* buf, size_t bufsize, uchar tag) const
        ssize_t supstr_ea(ea_t ea, char* buf, size_t bufsize, uchar tag) const
        bint supset(nodeidx_t alt, void* value, size_t length, uchar tag)  # Set value of supval array element. 
        bint supset_ea(ea_t ea, void* value, size_t length, uchar tag)
        bint supdel(nodeidx_t alt, uchar tag)  # Delete supval element. 
        bint supdel_ea(ea_t ea, uchar tag)
        nodeidx_t lower_bound(nodeidx_t cur, uchar tag) const  # Get lower bound of existing elements of supval arr
        nodeidx_t lower_bound_ea(ea_t ea, uchar tag) const
        nodeidx_t supfirst(uchar tag) const  # Get first existing element of supval array. 
        nodeidx_t supnext(nodeidx_t cur, uchar tag) const  # Get next existing element of supval array. 
        nodeidx_t suplast(uchar tag) const  # Get last existing element of supval array. 
        nodeidx_t supprev(nodeidx_t cur, uchar tag) const  # Get previous existing element of supval array. 
        size_t supshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the supval array elements. Moves the array e
        ssize_t supval_idx8(uchar alt, void* buf, size_t bufsize, uchar tag) const  #  The following functions behave in the same manner
        ssize_t supstr_idx8(uchar alt, char* buf, size_t bufsize, uchar tag) const
        ssize_t supstr_idx8(qstring* buf, uchar alt, uchar tag) const
        bint supset_idx8(uchar alt, void* value, size_t length, uchar tag)
        bint supdel_idx8(uchar alt, uchar tag)
        nodeidx_t lower_bound_idx8(uchar alt, uchar tag) const
        nodeidx_t supfirst_idx8(uchar tag) const
        nodeidx_t supnext_idx8(uchar alt, uchar tag) const
        nodeidx_t suplast_idx8(uchar tag) const
        nodeidx_t supprev_idx8(uchar alt, uchar tag) const
        bint supdel()  # Delete all elements of supval array. This function
        bint supdel_all(uchar tag)  # Delete all elements of the specified supval array.
        int supdel_range(nodeidx_t idx1, nodeidx_t idx2, uchar tag)  # Delete range of elements in the specified supval a
        int supdel_range_idx8(uchar idx1, uchar idx2, uchar tag)  # Same as above, but accepts 8-bit indexes
        ssize_t hashval(char* idx, void* buf, size_t bufsize, uchar tag) const  # Get value of the specified hash element. 
        ssize_t hashstr(qstring* buf, char* idx, uchar tag) const  # Similar to supstr(), but accepts a hash index
        ssize_t hashstr(char* idx, char* buf, size_t bufsize, uchar tag) const
        nodeidx_t hashval_long(char* idx, uchar tag) const  # Get value of the specified hash element. 
        bint hashset(char* idx, void* value, size_t length, uchar tag)  # Set value of hash element. 
        bint hashset(char* idx, nodeidx_t value, uchar tag)  # Set value of hash element to long value. 
        bint hashdel(char* idx, uchar tag)  # Delete hash element. 
        ssize_t hashfirst(qstring* buf, uchar tag) const  # Get first existing element of hash. 
        ssize_t hashfirst(char* buf, size_t bufsize, uchar tag) const
        ssize_t hashnext(qstring* buf, char* idx, uchar tag) const  # Get next existing element of hash. 
        ssize_t hashnext(char* idx, char* buf, size_t bufsize, uchar tag) const
        ssize_t hashlast(qstring* buf, uchar tag) const  # Get last existing element of hash. 
        ssize_t hashlast(char* buf, size_t bufsize, uchar tag) const
        ssize_t hashprev(qstring* buf, char* idx, uchar tag) const  # Get previous existing element of supval array. 
        ssize_t hashprev(char* idx, char* buf, size_t bufsize, uchar tag) const
        bint hashdel_all(uchar tag)  # Delete all elements of hash. This function deletes
        size_t blobsize(nodeidx_t _start, uchar tag)  # Get size of blob. 
        size_t blobsize_ea(ea_t ea, uchar tag)
        void* getblob(void* buf, size_t* bufsize, nodeidx_t _start, uchar tag)  # Get blob from a netnode. 
        void* getblob_ea(void* buf, size_t* bufsize, ea_t ea, uchar tag)
        ssize_t getblob(qstring* buf, nodeidx_t _start, uchar tag)  # Get blob from a netnode into a qstring* and make s
        bint setblob(void* buf, size_t size, nodeidx_t _start, uchar tag)  # Store a blob in a netnode. 
        bint setblob_ea(void* buf, size_t size, ea_t ea, uchar tag)
        int delblob(nodeidx_t _start, uchar tag)  # Delete a blob. 
        int delblob_ea(ea_t ea, uchar tag)
        size_t blobshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the blob array elements. Moves the array ele
        bint start()  # Get first netnode in the graph. Sets netnodenumber
        bint end()  # Get last netnode in the graph. Sets netnodenumber 
        bint next()  # Get next netnode in the graph. Sets netnodenumber 
        bint prev()  # Get prev netnode in the graph. Sets netnodenumber 
        size_t copyto(netnode destnode, nodeidx_t count)  # --------------------------------------------------
        size_t moveto(netnode destnode, nodeidx_t count)
        bint operator==(netnode& n) const  # --------------------------------------------------
        bint operator!=(netnode& n) const
        bint operator==(nodeidx_t x) const
        bint operator!=(nodeidx_t x) const
        bint inited()  # @ }
        bint is_available()
    cdef cppclass xrefpos_t:  #  @ { Position of cursor in the window with cross-references 
        ea_t ea
        uchar type  # the type of xref (::cref_t & ::dref_t)
        xrefpos_t(ea_t ea_, uchar type_)
        bint is_valid() const
    cdef cppclass array_parameters_t:  # ------------------------------------------------------------
        int32 flags
        int32 lineitems  # number of items on a line
        int32 alignment  # -1 - don't align. 0  - align automatically. else i
        array_parameters_t(int32 _f, int32 _l, int32 _a)
        bint is_default() const
    cdef cppclass switch_info_t:  # ------------------------------------------------------------
        uint32 flags
        ushort ncases  # number of cases (excluding default)
        ea_t jumps  # jump table start address
        ea_t values  # values table address (if #SWI_SPARSE is set)
        uval_t lowcase  # the lowest value in cases
        ea_t defjump  # default jump address (#BADADDR if no default case)
        ea_t startea  # start of the switch idiom
        int jcases  # number of entries in the jump table (SWI_INDIRECT)
        sval_t ind_lowcase
        ea_t elbase  # element base
        int regnum  # the switch expression as a value of the REGNUM reg
        op_dtype_t regdtype  # size of the switch expression register as dtype
        uval_t custom  # information for custom tables (filled and used by 
        int version
        ea_t expr_ea  # the address before that the switch expression is i
        eavec_t marks  # the insns marked as IM_SWITCH. They are used to de
        int get_shift() const  # See #SWI_SHIFT_MASK. possible answers: 0..3.
        void set_shift(int shift)  # See #SWI_SHIFT_MASK
        int get_jtable_element_size() const
        void set_jtable_element_size(int size)
        int get_vtable_element_size() const
        void set_vtable_element_size(int size)
        bint has_default() const
        bint has_elbase() const
        bint is_sparse() const
        bint is_custom() const
        bint is_indirect() const
        bint is_subtract() const
        bint is_nolowcase() const
        bint use_std_table() const
        bint is_user_defined() const
        sval_t get_lowcase() const
        int get_jtable_size() const
        void set_jtable_size(int size)
        void set_elbase(ea_t base)
        void set_expr(int r, op_dtype_t dt)
        bint get_jrange_vrange(range_t* jrange, range_t* vrange) const  # get separate parts of the switch
        int get_version() const
        switch_info_t()
        void clear()
        switch_info_t(switch_info_t&)
        switch_info_t(switch_info_t&&)
        switch_info_t& operator=(switch_info_t&)
        switch_info_t& operator=(switch_info_t&&)
    cdef cppclass custom_data_type_ids_t:  #  @ { Information about custom data types
        int16 dtid  # data type id
        void set(tid_t tid)
        tid_t get_dtid() const
        custom_data_type_ids_t()
        custom_data_type_ids_t(custom_data_type_ids_t&)
        custom_data_type_ids_t(custom_data_type_ids_t&&)
    cdef cppclass refinfo_t:  # Information about a reference
        ea_t target  # reference target (#BADADDR-none)
        ea_t base  # base of reference (may be BADADDR)
        adiff_t tdelta  # offset from the target
        uint32 flags
        reftype_t type() const  # @ }
        bint is_target_optional() const
        bint no_base_xref() const
        bint is_pastend() const
        bint is_rvaoff() const
        bint is_custom() const
        bint is_subtract() const
        bint is_signed() const
        bint is_no_zeros() const
        bint is_no_ones() const
        bint is_selfref() const
        void set_type(reftype_t rt)  # RT can include REFINFO_CUSTOM bit
        void init(uint32 reft_and_flags, ea_t _base, ea_t _target, adiff_t _tdelta)  # init the structure with some default values reft_a
        refinfo_t()
        refinfo_t(refinfo_t&)
        refinfo_t(refinfo_t&&)
    cdef cppclass custom_refinfo_handler_t:  # Manage a custom refinfo type Custom refinfos are usually use
        int32 cbsize  # size of this structure
        char* name  # Format name, must be unique
        char* desc  # Refinfo description to use in Ctrl-R dialog
        int props  # properties (currently 0)
    cdef cppclass refinfo_desc_t:  # Get descriptions of all standard and custom refinfo types.
        uint32 type  # Refinfo type, see Custom refinfo has REFINFO_CUSTO
        char* name  # Refinfo name
        char* desc  # Refinfo description to use in Ctrl-R dialog
    cdef cppclass strpath_t:  # Information for structure offsets. ids[0] contains the id of
        int len
        adiff_t delta
        strpath_t()
        strpath_t(strpath_t&)
        strpath_t(strpath_t&&)
    cdef cppclass enum_const_t:  # See opinfo_t::ec
        tid_t tid
        uchar serial
        enum_const_t()
        enum_const_t(enum_const_t&)
        enum_const_t(enum_const_t&&)
    cdef cppclass opinfo_t:  # Additional information about an operand type
        refinfo_t ri  # for offset members
        tid_t tid  # for struct, etc. members
        strpath_t path  # for stroff
        int32 strtype  # for strings (
        enum_const_t ec  # for enums
        custom_data_type_ids_t cd  # for custom data
        opinfo_t()
        opinfo_t(opinfo_t&)
        opinfo_t(opinfo_t&&)
    cdef cppclass printop_t:  # ------------------------------------------------------------
        uint32 unused  # not used anymore, use flags64 instead (kept for ba
        opinfo_t ti  # new operand type
        uchar features  # features this instance holds
        int suspop  # out: will be set by print_operand()
        aflags_t aflags  # additional aflags
        flags64_t flags  # new operand representation flags
        printop_t()
        bint is_ti_initialized() const
        void set_ti_initialized(bint v)
        bint is_aflags_initialized() const
        void set_aflags_initialized(bint v)
        bint is_f64() const
        opinfo_t* get_ti() const
    cdef cppclass tinfo_t

    # =========================================================================
    # Functions
    # =========================================================================
    int64 make_int64(uint32 ll, int32 hh)
    uint64 make_uint64(uint32 ll, int32 hh)
    uint32 low(uint64& x)
    uint32 high(uint64& x)
    int64 llong_scan(char* buf, int radix, char** end)
    uint64 swap64(uint64)
    int64 qatoll(char* nptr)
    void qexit(int code)  # Call qatexit functions, shut down UI and kernel, and exit. 
    bint test_bit(uchar* bitmap, asize_t bit)  # ---------------------------------------------------------...
    void set_bit(uchar* bitmap, asize_t bit)  # Set 'bit' in 'bitmap'
    void clear_bit(uchar* bitmap, asize_t bit)  # Clear 'bit' in 'bitmap'
    void set_bits(uchar* bitmap, asize_t low, asize_t high)  # Set bits between [low, high) in 'bitmap'
    void clear_bits(uchar* bitmap, asize_t low, asize_t high)  # Clear bits between [low, high) in 'bitmap'
    void set_all_bits(uchar* bitmap, asize_t nbits)  # Set first 'nbits' of 'bitmap'
    void clear_all_bits(uchar* bitmap, asize_t nbits)  # Clear first 'nbits' of 'bitmap'
    int log2ceil(uint64 d64)  # calculate ceil(log2(d64)) or floor(log2(d64)), it...
    int log2floor(uint64 d64)
    int bitcount(uint64 x)  # count the number of non-zero bits (the population count)
    int bitcountr_zero(uint64 x)  # count the number of consecutive trailing zero bits (line...
    uint32 round_up_power2(uint32 x)  # round up or down to a power of 2
    uint32 round_down_power2(uint32 x)
    uval_t last(uval_t off, asize_t s)  # max offset of the interval (assume s != 0)
    bint overlap(uval_t off1, asize_t s1, uval_t off2, asize_t s2)  # Do (off1,s1) and (off2,s2) overlap?
    bint includes(uval_t off1, asize_t s1, uval_t off2, asize_t s2)  # Does (off1,s1) include (off2,s2)?
    bint contains(uval_t off1, asize_t s1, uval_t off)  # Does (off1,s1) contain off?
    uint64 extend_sign(uint64 v, int nbytes, bint sign_extend)  # ---------------------------------------------------------...
    int readbytes(int h, uint32* res, int size, bint mf)  # ---------------------------------------------------------...
    int writebytes(int h, uint32 l, int size, bint mf)  # Write at most 4 bytes to file. 
    int read2bytes(int h, uint16* res, bint mf)  # Read a 2 byte entity from a file. 
    uint32 swap32(uint32 x)
    ushort swap16(ushort x)
    void swap_value(void* dst, void* src, int size)  # Swap endianness of a given value in memory. 
    void reloc_value(void* value, int size, adiff_t delta, bint mf)
    uval_t rotate_left(uval_t x, int count, asize_t bits, int offset)  # Rotate left - can be used to rotate a value to the right...
    void* qalloc_or_throw(int size)  # qalloc() 'size' bytes, and throw a "not enough memory"...
    void* qrealloc_or_throw(void* ptr, int size)  # qrealloc() 'ptr' by 'size', and throw a "not enough...
    void* qvector_reserve(void* vec, void* old, int cnt, int elsize)  # Change capacity of given qvector. 
    int qstrlen(char* s)  # ---------------------------------------------------------...
    int qstrcmp(char* s1, char* s2)  #  Lexical comparison of strings. 
    int qstrncmp(char* s1, char* s2, int len)  #  Lexical comparison of string prefixes. 
    char* qstrstr(char* s1, char* s2)  #  Find a string within another string. 
    char* qstrchr(char* s1, char c)  #  Find a character within a string. 
    char* qstrrchr(char* s1, char c)  #  Find a last occurrence of a character within a string. 
    uint32 calc_crc32(uint32 crc, void* buf, int len)  # Calculate CRC32 (polynom 0xEDB88320, zlib compatible). 
    bint base64_encode(qstring* output, void* input, int size)  # Encode base64
    bint base64_decode(bytevec_t* output, char* input, int size)  # Decode base64
    bint replace_tabs(qstring* out, char* str, int tabsize)  # Convert tabulations to spaces 
    char* str2user(char* dst, char* src, int dstsize)  #  String C-style conversions (convert \ n to a newline...
    char* user2str(char* dst, char* src, int dstsize)
    char back_char(char** p)
    void qstr2user(qstring* dst, char* src, int nsyms)
    void user2qstr(qstring* dst, qstring& src)
    bint is_utf8_head(char in_)  # Does this byte correspond to the head of a UTF-8 byte...
    bint is_utf8_tail(char in_)  # Does this byte correspond to the tail of a UTF-8 byte sequence? 
    bint is_valid_utf8(char* in_)  # Does byte sequence consist of valid UTF-8-encoded codepoints? 
    bint utf8_utf16(qwstring* out, char* in_, int nsyms)  # UTF-8 -> UTF-16 
    bint utf16_utf8(qstring* out, wchar16_t* in_, int nsyms)  # UTF-16 -> UTF-8 
    bint is_lead_surrogate(wchar32_t wch)
    bint is_tail_surrogate(wchar32_t wch)
    wchar32_t utf16_surrogates_to_cp(wchar16_t lead_surrogate, wchar16_t tail_surrogate)
    bint idb_utf8(qstring* out, char* in_, int nsyms, int flags)  # IDB default C string encoding -> UTF-8 
    bint change_codepage(qstring*, char*, int, int)
    wchar16_t utf8_wchar16(uchar b0, uchar b1)  # ---------------------------------------------------------...
    wchar32_t utf8_wchar32(uchar b0, uchar b1, uchar b2, uchar b3)  # ---------------------------------------------------------...
    wchar32_t get_utf8_char(char** pptr)  # Read one UTF-8 character from string. if error, return BADCP
    bint prev_utf8_char(wchar32_t* out_cp, char** p, char* begin)  # Get the UTF-8 character from string, before 'p'. 
    int skip_utf8(char** putf8, int n)  # Advance by n codepoints into the UTF-8 buffer. Each bad...
    int put_utf8_char(char* out, wchar32_t cp)  # Encode the codepoint into a UTF-8 byte sequence, and add...
    bint is_cp_graphical(wchar32_t cp)  # Is the provided codepoint graphical?
    int qustrlen(char* utf8)  # Get number of codepoints in UTF-8 string. Any 'bad' byte...
    bint qustrncpy(char* dst, char* utf8, int dstsize)  # A safer strncpy - makes sure that there is a terminating...
    bint is_cvt64()  # ---------------------------------------------------------...
    int convert_encoding(bytevec_t* out, char* fromcode, char* tocode, uchar* indata, int insize, int flags)  # Convert data from encoding fromcode into tocode. 
    int parse_command_line(qstrvec_t* args, channel_redirs_t* redirs, char* cmdline, int flags)  # Parse a space separated string (escaping with backslash...
    char** expand_argv(int* p_argc, int argc, char** argv)  # Copy and expand command line arguments. For ' '...
    void free_argv(int argc, char** argv)  # Free 'argc' elements of 'argv'
    bint quote_cmdline_arg(qstring* arg)  # Quote a command line argument if it contains escape...
    bint parse_plugin_options(plugin_options_t* opts, char* optstring)  # Parse plugin options from IDA command line specified by...
    void build_plugin_options(qstring* out, plugin_options_t& opts, char* optname)  # Build the plugin options, suitable for IDA command line...
    bint parse_dbgopts(instant_dbgopts_t* ido, char* r_switch)  # Parse the -r command line switch (for instant...
    void* launch_process(launch_process_params_t& lpp, qstring* errbuf)
    int term_process(void* handle)  # Forcibly terminate a running process. 
    int qwait_timed(int* status, int child, int flags, int timeout_ms)  # Wait for state changes in a child process (UNIX only)....
    int qwait(int* status, int child, int flags)
    int check_process_exit(void* handle, int* exit_code, int msecs)  # Check whether process has terminated or not. 
    tty_control_t is_control_tty(int fd)  # Check if the current process is the owner of the TTY...
    void qdetach_tty()  # If the current terminal is the controlling terminal of...
    void qcontrol_tty()  # Make the current terminal the controlling terminal of...
    bint is_main_thread()  # Are we running in the main thread?
    bint qsetenv(char* varname, char* value)  # Thread safe function to work with the environment
    bint qgetenv(char* varname, qstring* buf)
    int qpipe_create(qhandle_t* handles)  # Create a pipe. 
    int qpipe_read(qhandle_t handle, void* buf, int size)  # Read from a pipe.
    bint qpipe_read_n(qhandle_t handle, bytevec_t* out_bytes, int n)  # Read a specific amount of bytes from a pipe. 
    int qpipe_write(qhandle_t handle, void* buf, int size)  # Write to a pipe.
    int qpipe_close(qhandle_t handle)  # Close a pipe.
    void* pipe_process(qhandle_t* read_handle, qhandle_t* write_handle, launch_process_params_t* lpp, qstring* errbuf)  # Launch a process and establish 2-way comminucation with...
    int qwait_for_handles(int* idx, qhandle_t* handles, int n, uint32 write_bitmask, int timeout_ms)  # Wait for file/socket/pipe handles. 
    bint get_login_name(qstring* out)  # Get the user name for the current desktop session 
    int get_physical_core_count()  # Get the total CPU physical core count 
    int get_logical_core_count()  # Get the total CPU logical core count 
    int get_available_core_count()  # Get the number of logical CPU cores available to the...
    bint is_filetype_like_binary(filetype_t ft)  # Is unstructured input file?
    int getinf(inftag_t tag)  # Get program specific information (a scalar value) 
    int getinf_buf(inftag_t tag, void* buf, int bufsize)  # Get program specific information (a non-scalar value) 
    int getinf_str(qstring* buf, inftag_t tag)  # Get program specific information (a non-scalar value) 
    bint getinf_flag(inftag_t tag, uint32 flag)  # Get a flag value 
    bint setinf(inftag_t tag, int value)  # Set program specific information 
    bint setinf_buf(inftag_t tag, void* buf, int bufsize)  # Set program specific information 
    bint setinf_flag(inftag_t tag, uint32 flag, bint value)  # Set a flag value 
    bint delinf(inftag_t tag)  # Undefine a program specific information 
    ushort inf_get_version()  #  <INF _ACCESSORS>
    bint inf_set_version(ushort _v)
    ushort inf_get_genflags()
    bint inf_set_genflags(ushort _v)
    bint inf_is_auto_enabled()
    bint inf_set_auto_enabled(bint _v)
    bint inf_use_allasm()
    bint inf_set_use_allasm(bint _v)
    bint inf_loading_idc()
    bint inf_set_loading_idc(bint _v)
    bint inf_no_store_user_info()
    bint inf_set_no_store_user_info(bint _v)
    bint inf_readonly_idb()
    bint inf_set_readonly_idb(bint _v)
    bint inf_check_manual_ops()
    bint inf_set_check_manual_ops(bint _v)
    bint inf_allow_non_matched_ops()
    bint inf_set_allow_non_matched_ops(bint _v)
    bint inf_is_graph_view()
    bint inf_set_graph_view(bint _v)
    uint32 inf_get_lflags()
    bint inf_set_lflags(uint32 _v)
    bint inf_decode_fpp()
    bint inf_set_decode_fpp(bint _v)
    bint inf_is_32bit_or_higher()  # unfortunately the name inf_is_32bit was used in the past...
    bint inf_is_32bit_exactly()
    bint inf_set_32bit(bint _v)
    bint inf_is_16bit()
    bint inf_is_64bit()
    bint inf_set_64bit(bint _v)
    bint inf_is_ilp32()
    bint inf_set_ilp32(bint _v)
    bint inf_is_dll()
    bint inf_set_dll(bint _v)
    bint inf_is_flat_off32()
    bint inf_set_flat_off32(bint _v)
    bint inf_is_be()
    bint inf_set_be(bint _v)
    bint inf_is_wide_high_byte_first()
    bint inf_set_wide_high_byte_first(bint _v)
    bint inf_dbg_no_store_path()
    bint inf_set_dbg_no_store_path(bint _v)
    bint inf_is_snapshot()
    bint inf_set_snapshot(bint _v)
    bint inf_pack_idb()
    bint inf_set_pack_idb(bint _v)
    bint inf_compress_idb()
    bint inf_set_compress_idb(bint _v)
    bint inf_is_kernel_mode()
    bint inf_set_kernel_mode(bint _v)
    uint inf_get_app_bitness()
    void inf_set_app_bitness(uint bitness)
    uint32 inf_get_database_change_count()
    bint inf_set_database_change_count(uint32 _v)
    filetype_t inf_get_filetype()
    bint inf_set_filetype(filetype_t _v)
    ushort inf_get_ostype()
    bint inf_set_ostype(ushort _v)
    ushort inf_get_apptype()
    bint inf_set_apptype(ushort _v)
    uchar inf_get_asmtype()
    bint inf_set_asmtype(uchar _v)
    uchar inf_get_specsegs()
    bint inf_set_specsegs(uchar _v)
    uint32 inf_get_af()
    bint inf_set_af(uint32 _v)
    bint inf_trace_flow()
    bint inf_set_trace_flow(bint _v)
    bint inf_mark_code()
    bint inf_set_mark_code(bint _v)
    bint inf_create_jump_tables()
    bint inf_set_create_jump_tables(bint _v)
    bint inf_noflow_to_data()
    bint inf_set_noflow_to_data(bint _v)
    bint inf_create_all_xrefs()
    bint inf_set_create_all_xrefs(bint _v)
    bint inf_del_no_xref_insns()
    bint inf_set_del_no_xref_insns(bint _v)
    bint inf_create_func_from_ptr()
    bint inf_set_create_func_from_ptr(bint _v)
    bint inf_create_func_from_call()
    bint inf_set_create_func_from_call(bint _v)
    bint inf_create_func_tails()
    bint inf_set_create_func_tails(bint _v)
    bint inf_should_create_stkvars()
    bint inf_set_should_create_stkvars(bint _v)
    bint inf_propagate_stkargs()
    bint inf_set_propagate_stkargs(bint _v)
    bint inf_propagate_regargs()
    bint inf_set_propagate_regargs(bint _v)
    bint inf_should_trace_sp()
    bint inf_set_should_trace_sp(bint _v)
    bint inf_full_sp_ana()
    bint inf_set_full_sp_ana(bint _v)
    bint inf_noret_ana()
    bint inf_set_noret_ana(bint _v)
    bint inf_guess_func_type()
    bint inf_set_guess_func_type(bint _v)
    bint inf_truncate_on_del()
    bint inf_set_truncate_on_del(bint _v)
    bint inf_create_strlit_on_xref()
    bint inf_set_create_strlit_on_xref(bint _v)
    bint inf_check_unicode_strlits()
    bint inf_set_check_unicode_strlits(bint _v)
    bint inf_create_off_using_fixup()
    bint inf_set_create_off_using_fixup(bint _v)
    bint inf_create_off_on_dref()
    bint inf_set_create_off_on_dref(bint _v)
    bint inf_op_offset()
    bint inf_set_op_offset(bint _v)
    bint inf_data_offset()
    bint inf_set_data_offset(bint _v)
    bint inf_use_flirt()
    bint inf_set_use_flirt(bint _v)
    bint inf_append_sigcmt()
    bint inf_set_append_sigcmt(bint _v)
    bint inf_allow_sigmulti()
    bint inf_set_allow_sigmulti(bint _v)
    bint inf_hide_libfuncs()
    bint inf_set_hide_libfuncs(bint _v)
    bint inf_rename_jumpfunc()
    bint inf_set_rename_jumpfunc(bint _v)
    bint inf_rename_nullsub()
    bint inf_set_rename_nullsub(bint _v)
    bint inf_coagulate_data()
    bint inf_set_coagulate_data(bint _v)
    bint inf_coagulate_code()
    bint inf_set_coagulate_code(bint _v)
    bint inf_final_pass()
    bint inf_set_final_pass(bint _v)
    uint32 inf_get_af2()
    bint inf_set_af2(uint32 _v)
    bint inf_handle_eh()
    bint inf_set_handle_eh(bint _v)
    bint inf_handle_rtti()
    bint inf_set_handle_rtti(bint _v)
    bint inf_macros_enabled()
    bint inf_set_macros_enabled(bint _v)
    bint inf_merge_strlits()
    bint inf_set_merge_strlits(bint _v)
    uval_t inf_get_baseaddr()
    bint inf_set_baseaddr(uval_t _v)
    sel_t inf_get_start_ss()
    bint inf_set_start_ss(sel_t _v)
    sel_t inf_get_start_cs()
    bint inf_set_start_cs(sel_t _v)
    ea_t inf_get_start_ip()
    bint inf_set_start_ip(ea_t _v)
    ea_t inf_get_start_ea()
    bint inf_set_start_ea(ea_t _v)
    ea_t inf_get_start_sp()
    bint inf_set_start_sp(ea_t _v)
    ea_t inf_get_main()
    bint inf_set_main(ea_t _v)
    ea_t inf_get_min_ea()
    bint inf_set_min_ea(ea_t _v)
    ea_t inf_get_max_ea()
    bint inf_set_max_ea(ea_t _v)
    ea_t inf_get_omin_ea()
    bint inf_set_omin_ea(ea_t _v)
    ea_t inf_get_omax_ea()
    bint inf_set_omax_ea(ea_t _v)
    ea_t inf_get_lowoff()
    bint inf_set_lowoff(ea_t _v)
    ea_t inf_get_highoff()
    bint inf_set_highoff(ea_t _v)
    uval_t inf_get_maxref()
    bint inf_set_maxref(uval_t _v)
    sval_t inf_get_netdelta()
    bint inf_set_netdelta(sval_t _v)
    uchar inf_get_xrefnum()
    bint inf_set_xrefnum(uchar _v)
    uchar inf_get_type_xrefnum()
    bint inf_set_type_xrefnum(uchar _v)
    uchar inf_get_refcmtnum()
    bint inf_set_refcmtnum(uchar _v)
    uchar inf_get_xrefflag()
    bint inf_set_xrefflag(uchar _v)
    bint inf_show_xref_seg()
    bint inf_set_show_xref_seg(bint _v)
    bint inf_show_xref_tmarks()
    bint inf_set_show_xref_tmarks(bint _v)
    bint inf_show_xref_fncoff()
    bint inf_set_show_xref_fncoff(bint _v)
    bint inf_show_xref_val()
    bint inf_set_show_xref_val(bint _v)
    ushort inf_get_max_autoname_len()
    bint inf_set_max_autoname_len(ushort _v)
    char inf_get_nametype()
    bint inf_set_nametype(char _v)
    uint32 inf_get_short_demnames()
    bint inf_set_short_demnames(uint32 _v)
    uint32 inf_get_long_demnames()
    bint inf_set_long_demnames(uint32 _v)
    uchar inf_get_demnames()
    bint inf_set_demnames(uchar _v)
    uchar inf_get_listnames()
    bint inf_set_listnames(uchar _v)
    uchar inf_get_indent()
    bint inf_set_indent(uchar _v)
    uchar inf_get_cmt_indent()
    bint inf_set_cmt_indent(uchar _v)
    ushort inf_get_margin()
    bint inf_set_margin(ushort _v)
    ushort inf_get_lenxref()
    bint inf_set_lenxref(ushort _v)
    uint32 inf_get_outflags()
    bint inf_set_outflags(uint32 _v)
    bint inf_show_void()
    bint inf_set_show_void(bint _v)
    bint inf_show_auto()
    bint inf_set_show_auto(bint _v)
    bint inf_gen_null()
    bint inf_set_gen_null(bint _v)
    bint inf_show_line_pref()
    bint inf_set_show_line_pref(bint _v)
    bint inf_line_pref_with_seg()
    bint inf_set_line_pref_with_seg(bint _v)
    bint inf_gen_lzero()
    bint inf_set_gen_lzero(bint _v)
    bint inf_gen_org()
    bint inf_set_gen_org(bint _v)
    bint inf_gen_assume()
    bint inf_set_gen_assume(bint _v)
    bint inf_gen_tryblks()
    bint inf_set_gen_tryblks(bint _v)
    uchar inf_get_cmtflg()
    bint inf_set_cmtflg(uchar _v)
    bint inf_show_repeatables()
    bint inf_set_show_repeatables(bint _v)
    bint inf_show_all_comments()
    bint inf_set_show_all_comments(bint _v)
    bint inf_hide_comments()
    bint inf_set_hide_comments(bint _v)
    bint inf_show_src_linnum()
    bint inf_set_show_src_linnum(bint _v)
    bint inf_test_mode()
    bint inf_show_hidden_insns()
    bint inf_set_show_hidden_insns(bint _v)
    bint inf_show_hidden_funcs()
    bint inf_set_show_hidden_funcs(bint _v)
    bint inf_show_hidden_segms()
    bint inf_set_show_hidden_segms(bint _v)
    uchar inf_get_limiter()
    bint inf_set_limiter(uchar _v)
    bint inf_is_limiter_thin()
    bint inf_set_limiter_thin(bint _v)
    bint inf_is_limiter_thick()
    bint inf_set_limiter_thick(bint _v)
    bint inf_is_limiter_empty()
    bint inf_set_limiter_empty(bint _v)
    short inf_get_bin_prefix_size()
    bint inf_set_bin_prefix_size(short _v)
    uchar inf_get_prefflag()
    bint inf_set_prefflag(uchar _v)
    bint inf_prefix_show_segaddr()
    bint inf_set_prefix_show_segaddr(bint _v)
    bint inf_prefix_show_funcoff()
    bint inf_set_prefix_show_funcoff(bint _v)
    bint inf_prefix_show_stack()
    bint inf_set_prefix_show_stack(bint _v)
    bint inf_prefix_truncate_opcode_bytes()
    bint inf_set_prefix_truncate_opcode_bytes(bint _v)
    uchar inf_get_strlit_flags()
    bint inf_set_strlit_flags(uchar _v)
    bint inf_strlit_names()
    bint inf_set_strlit_names(bint _v)
    bint inf_strlit_name_bit()
    bint inf_set_strlit_name_bit(bint _v)
    bint inf_strlit_serial_names()
    bint inf_set_strlit_serial_names(bint _v)
    bint inf_unicode_strlits()
    bint inf_set_unicode_strlits(bint _v)
    bint inf_strlit_autocmt()
    bint inf_set_strlit_autocmt(bint _v)
    bint inf_strlit_savecase()
    bint inf_set_strlit_savecase(bint _v)
    uchar inf_get_strlit_break()
    bint inf_set_strlit_break(uchar _v)
    char inf_get_strlit_zeroes()
    bint inf_set_strlit_zeroes(char _v)
    int32 inf_get_strtype()
    bint inf_set_strtype(int32 _v)
    uval_t inf_get_strlit_sernum()
    bint inf_set_strlit_sernum(uval_t _v)
    uval_t inf_get_datatypes()
    bint inf_set_datatypes(uval_t _v)
    uint32 inf_get_abibits()
    bint inf_set_abibits(uint32 _v)
    bint inf_is_mem_aligned4()
    bint inf_set_mem_aligned4(bint _v)
    bint inf_pack_stkargs()
    bint inf_set_pack_stkargs(bint _v)
    bint inf_big_arg_align()
    bint inf_set_big_arg_align(bint _v)
    bint inf_stack_ldbl()
    bint inf_set_stack_ldbl(bint _v)
    bint inf_stack_varargs()
    bint inf_set_stack_varargs(bint _v)
    bint inf_is_hard_float()
    bint inf_set_hard_float(bint _v)
    bint inf_abi_set_by_user()
    bint inf_set_abi_set_by_user(bint _v)
    bint inf_use_gcc_layout()
    bint inf_set_use_gcc_layout(bint _v)
    bint inf_map_stkargs()
    bint inf_set_map_stkargs(bint _v)
    bint inf_huge_arg_align()
    bint inf_set_huge_arg_align(bint _v)
    uint32 inf_get_appcall_options()
    bint inf_set_appcall_options(uint32 _v)
    ea_t inf_get_privrange_start_ea()
    bint inf_set_privrange_start_ea(ea_t _v)
    ea_t inf_get_privrange_end_ea()
    bint inf_set_privrange_end_ea(ea_t _v)
    comp_t inf_get_cc_id()
    bint inf_set_cc_id(comp_t _v)
    cm_t inf_get_cc_cm()
    bint inf_set_cc_cm(cm_t _v)
    callcnv_t inf_get_callcnv()
    bint inf_set_callcnv(callcnv_t _v)
    uchar inf_get_cc_size_i()
    bint inf_set_cc_size_i(uchar _v)
    uchar inf_get_cc_size_b()
    bint inf_set_cc_size_b(uchar _v)
    uchar inf_get_cc_size_e()
    bint inf_set_cc_size_e(uchar _v)
    uchar inf_get_cc_defalign()
    bint inf_set_cc_defalign(uchar _v)
    uchar inf_get_cc_size_s()
    bint inf_set_cc_size_s(uchar _v)
    uchar inf_get_cc_size_l()
    bint inf_set_cc_size_l(uchar _v)
    uchar inf_get_cc_size_ll()
    bint inf_set_cc_size_ll(uchar _v)
    uchar inf_get_cc_size_ldbl()
    bint inf_set_cc_size_ldbl(uchar _v)
    bint inf_get_procname(char* buf, int bufsize)
    bint inf_set_procname(char* _v, int len)
    bint inf_get_strlit_pref(char* buf, int bufsize)
    bint inf_set_strlit_pref(char* _v, int len)
    bint inf_get_cc(compiler_info_t* out)
    bint inf_set_cc(compiler_info_t& _v)
    bint inf_get_privrange(range_t* out)
    bint inf_set_privrange(range_t& _v)
    ushort inf_get_af_low()  # Get/set low/high 16bit halves of inf.af
    void inf_set_af_low(ushort saf)
    ushort inf_get_af_high()
    void inf_set_af_high(ushort saf2)
    ushort inf_get_af2_low()  # Get/set low 16bit half of inf.af2
    void inf_set_af2_low(ushort saf)
    int inf_get_pack_mode()
    int inf_set_pack_mode(int pack_mode)
    void inf_inc_database_change_count(int cnt)
    uchar inf_get_demname_form()  # Get #DEMNAM_MASK bits of #demnames
    uval_t inf_postinc_strlit_sernum(uval_t cnt)
    bint inf_like_binary()
    int calc_default_idaplace_flags()  # Get default disassembly line options
    ea_t to_ea(sel_t reg_cs, uval_t reg_ip)  # ---------------------------------------------------------...
    int invoke_callbacks(hook_type_t hook_type, int notification_code, int va)  # Generate event notification. 
    bint register_post_event_visitor(hook_type_t hook_type, post_event_visitor_t* visitor, plugmod_t* owner)  # Register the post-event visitor. The kernel will not...
    bint unregister_post_event_visitor(hook_type_t hook_type, post_event_visitor_t* visitor)  # Unregister the post-event visitor. 
    int get_dbctx_id()  # Get the current database context ID 
    int get_dbctx_qty()  # Get number of database contexts 
    bint is_database_busy()  # Check if the database is busy (e.g. performing some...
    int validate_idb(uint32 vld_flags)  # Validate the database 
    bint move_privrange(ea_t new_privrange_start)  # Move privrange to the specified address 
    int isascii(int _c)
    int isalnum(int _c)
    int isalpha(int _c)
    int isblank(int _c)
    int iscntrl(int _c)
    int isdigit(int _c)
    int isgraph(int _c)
    int islower(int _c)
    int isprint(int _c)
    int ispunct(int _c)
    int isspace(int _c)
    int isupper(int _c)
    int isxdigit(int _c)
    int toascii(int _c)
    int tolower(int _c)
    int toupper(int _c)
    int digittoint(int _c)
    int ishexnumber(int _c)
    int isideogram(int _c)
    int isnumber(int _c)
    int isphonogram(int _c)
    int isrune(int _c)
    int isspecial(int _c)
    int __sputc(int _c, FILE* _p)
    int __darwin_check_fd_set(int _a, void* _b)
    void __darwin_fd_set(int _fd, fd_set*const _p)
    void __darwin_fd_clr(int _fd, fd_set*const _p)
    bint netnode_check(netnode*, char* name, size_t namlen, bint create)
    void netnode_kill(netnode*)
    bint netnode_start(netnode*)
    bint netnode_end(netnode*)
    bint netnode_next(netnode*)
    bint netnode_prev(netnode*)
    ssize_t netnode_get_name(nodeidx_t num, qstring* out)
    bint netnode_rename(nodeidx_t num, char* newname, size_t namlen)
    ssize_t netnode_valobj(nodeidx_t num, void* buf, size_t bufsize)
    ssize_t netnode_valstr(nodeidx_t num, char* buf, size_t bufsize)
    ssize_t netnode_qvalstr(nodeidx_t num, qstring* buf)
    bint netnode_set(nodeidx_t num, void* value, size_t length)
    bint netnode_delvalue(nodeidx_t num)
    nodeidx_t netnode_altval(nodeidx_t num, nodeidx_t alt, int tag)
    uchar netnode_charval(nodeidx_t num, nodeidx_t alt, int tag)
    nodeidx_t netnode_altval_idx8(nodeidx_t num, uchar alt, int tag)
    uchar netnode_charval_idx8(nodeidx_t num, uchar alt, int tag)
    ssize_t netnode_supval(nodeidx_t num, nodeidx_t alt, void* buf, size_t bufsize, int tag)
    ssize_t netnode_supstr(nodeidx_t num, nodeidx_t alt, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qsupstr(nodeidx_t num, qstring* buf, nodeidx_t alt, int tag)
    bint netnode_supset(nodeidx_t num, nodeidx_t alt, void* value, size_t length, int tag)
    bint netnode_supdel(nodeidx_t num, nodeidx_t alt, int tag)
    nodeidx_t netnode_lower_bound(nodeidx_t num, nodeidx_t cur, int tag)
    nodeidx_t netnode_supfirst(nodeidx_t num, int tag)
    nodeidx_t netnode_supnext(nodeidx_t num, nodeidx_t cur, int tag)
    nodeidx_t netnode_suplast(nodeidx_t num, int tag)
    nodeidx_t netnode_supprev(nodeidx_t num, nodeidx_t cur, int tag)
    ssize_t netnode_supval_idx8(nodeidx_t num, uchar alt, void* buf, size_t bufsize, int tag)
    ssize_t netnode_supstr_idx8(nodeidx_t num, uchar alt, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qsupstr_idx8(nodeidx_t num, qstring* buf, uchar alt, int tag)
    bint netnode_supset_idx8(nodeidx_t num, uchar alt, void* value, size_t length, int tag)
    bint netnode_supdel_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_lower_bound_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_supfirst_idx8(nodeidx_t num, int tag)
    nodeidx_t netnode_supnext_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_suplast_idx8(nodeidx_t num, int tag)
    nodeidx_t netnode_supprev_idx8(nodeidx_t num, uchar alt, int tag)
    bint netnode_supdel_all(nodeidx_t num, int tag)
    int netnode_supdel_range(nodeidx_t num, nodeidx_t idx1, nodeidx_t idx2, int tag)
    int netnode_supdel_range_idx8(nodeidx_t num, nodeidx_t idx1, nodeidx_t idx2, int tag)
    ssize_t netnode_hashval(nodeidx_t num, char* idx, void* buf, size_t bufsize, int tag)
    ssize_t netnode_hashstr(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashstr(nodeidx_t num, qstring* buf, char* idx, int tag)
    nodeidx_t netnode_hashval_long(nodeidx_t num, char* idx, int tag)
    bint netnode_hashset(nodeidx_t num, char* idx, void* value, size_t length, int tag)
    bint netnode_hashdel(nodeidx_t num, char* idx, int tag)
    ssize_t netnode_hashfirst(nodeidx_t num, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashfirst(nodeidx_t num, qstring* buf, int tag)
    ssize_t netnode_hashnext(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashnext(nodeidx_t num, qstring* buf, char* idx, int tag)
    ssize_t netnode_hashlast(nodeidx_t num, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashlast(nodeidx_t num, qstring* buf, int tag)
    ssize_t netnode_hashprev(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashprev(nodeidx_t num, qstring* buf, char* idx, int tag)
    size_t netnode_blobsize(nodeidx_t num, nodeidx_t start, int tag)
    void* netnode_getblob(nodeidx_t num, void* buf, size_t* bufsize, nodeidx_t start, int tag)
    ssize_t netnode_qgetblob(nodeidx_t num, bytevec_t* buf, size_t elsize, nodeidx_t start, int tag)
    bint netnode_setblob(nodeidx_t num, void* buf, size_t size, nodeidx_t start, int tag)
    int netnode_delblob(nodeidx_t num, nodeidx_t start, int tag)
    bint netnode_inited()
    bint netnode_is_available()
    size_t netnode_copy(nodeidx_t num, nodeidx_t count, nodeidx_t target, bint move)
    size_t netnode_altshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_charshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_supshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_blobshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    void netnode_altadjust2(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, altadjust_visitor_t& av)
    bint netnode_exist(netnode& n)
    nodeidx_t ea2node(ea_t ea)  # Get netnode for the specified address.
    ea_t node2ea(nodeidx_t ndx)
    nodeidx_t end_ea2node(ea_t ea)
    netnode getnode(ea_t ea)
    tid_t get_strid(ea_t ea)  #  Returns the struct id of the struct type at the...
    ssize_t get_xrefpos(xrefpos_t* out, ea_t ea)
    void set_xrefpos(ea_t ea, xrefpos_t* in_)
    void del_xrefpos(ea_t ea)
    void set_aflags(ea_t ea, aflags_t flags)
    void upd_abits(ea_t ea, aflags_t clr_bits, aflags_t set_bits)
    void set_abits(ea_t ea, aflags_t bits)
    void clr_abits(ea_t ea, aflags_t bits)
    aflags_t get_aflags(ea_t ea)
    void del_aflags(ea_t ea)
    bint has_aflag_linnum(aflags_t flags)
    bint is_aflag_usersp(aflags_t flags)
    bint is_aflag_public_name(aflags_t flags)
    bint is_aflag_weak_name(aflags_t flags)
    bint is_aflag_hidden_item(aflags_t flags)
    bint is_aflag_manual_insn(aflags_t flags)
    bint is_aflag_hidden_border(aflags_t flags)
    bint is_aflag_zstroff(aflags_t flags)
    bint is_aflag__bnot0(aflags_t flags)
    bint is_aflag__bnot1(aflags_t flags)
    bint is_aflag_libitem(aflags_t flags)
    bint has_aflag_ti(aflags_t flags)
    bint has_aflag_ti0(aflags_t flags)
    bint has_aflag_ti1(aflags_t flags)
    bint has_aflag_lname(aflags_t flags)
    bint is_aflag_tilcmt(aflags_t flags)
    bint is_aflag_lzero0(aflags_t flags)
    bint is_aflag_lzero1(aflags_t flags)
    bint is_aflag_colored_item(aflags_t flags)
    bint is_aflag_terse_struc(aflags_t flags)
    bint is_aflag__invsign0(aflags_t flags)
    bint is_aflag__invsign1(aflags_t flags)
    bint is_aflag_noret(aflags_t flags)
    bint is_aflag_fixed_spd(aflags_t flags)
    bint is_aflag_align_flow(aflags_t flags)
    bint is_aflag_userti(aflags_t flags)
    bint is_aflag_retfp(aflags_t flags)
    bint uses_aflag_modsp(aflags_t flags)
    bint is_aflag_notcode(aflags_t flags)
    bint is_aflag_notproc(aflags_t flags)
    bint is_aflag_type_guessed_by_ida(aflags_t flags)
    bint is_aflag_func_guessed_by_hexrays(aflags_t flags)
    bint is_aflag_data_guessed_by_hexrays(aflags_t flags)
    bint is_aflag_type_determined_by_hexrays(aflags_t flags)
    bint is_aflag_type_guessed_by_hexrays(aflags_t flags)
    bint is_hidden_item(ea_t ea)
    void hide_item(ea_t ea)
    void unhide_item(ea_t ea)
    bint is_hidden_border(ea_t ea)
    void hide_border(ea_t ea)
    void unhide_border(ea_t ea)
    bint uses_modsp(ea_t ea)
    void set_usemodsp(ea_t ea)
    void clr_usemodsp(ea_t ea)
    bint is_zstroff(ea_t ea)
    void set_zstroff(ea_t ea)
    void clr_zstroff(ea_t ea)
    bint is__bnot0(ea_t ea)
    void set__bnot0(ea_t ea)
    void clr__bnot0(ea_t ea)
    bint is__bnot1(ea_t ea)
    void set__bnot1(ea_t ea)
    void clr__bnot1(ea_t ea)
    bint is_libitem(ea_t ea)
    void set_libitem(ea_t ea)
    void clr_libitem(ea_t ea)
    bint has_ti(ea_t ea)
    void set_has_ti(ea_t ea)
    void clr_has_ti(ea_t ea)
    bint has_ti0(ea_t ea)
    void set_has_ti0(ea_t ea)
    void clr_has_ti0(ea_t ea)
    bint has_ti1(ea_t ea)
    void set_has_ti1(ea_t ea)
    void clr_has_ti1(ea_t ea)
    bint has_lname(ea_t ea)
    void set_has_lname(ea_t ea)
    void clr_has_lname(ea_t ea)
    bint is_tilcmt(ea_t ea)
    void set_tilcmt(ea_t ea)
    void clr_tilcmt(ea_t ea)
    bint is_usersp(ea_t ea)
    void set_usersp(ea_t ea)
    void clr_usersp(ea_t ea)
    bint is_lzero0(ea_t ea)
    void set_lzero0(ea_t ea)
    void clr_lzero0(ea_t ea)
    bint is_lzero1(ea_t ea)
    void set_lzero1(ea_t ea)
    void clr_lzero1(ea_t ea)
    bint is_colored_item(ea_t ea)
    void set_colored_item(ea_t ea)
    void clr_colored_item(ea_t ea)
    bint is_terse_struc(ea_t ea)
    void set_terse_struc(ea_t ea)
    void clr_terse_struc(ea_t ea)
    bint is__invsign0(ea_t ea)
    void set__invsign0(ea_t ea)
    void clr__invsign0(ea_t ea)
    bint is__invsign1(ea_t ea)
    void set__invsign1(ea_t ea)
    void clr__invsign1(ea_t ea)
    bint is_noret(ea_t ea)
    void set_noret(ea_t ea)
    void clr_noret(ea_t ea)
    bint is_fixed_spd(ea_t ea)
    void set_fixed_spd(ea_t ea)
    void clr_fixed_spd(ea_t ea)
    bint is_align_flow(ea_t ea)
    void set_align_flow(ea_t ea)
    void clr_align_flow(ea_t ea)
    bint is_userti(ea_t ea)
    void set_userti(ea_t ea)
    void clr_userti(ea_t ea)
    bint is_retfp(ea_t ea)
    void set_retfp(ea_t ea)
    void clr_retfp(ea_t ea)
    bint is_notproc(ea_t ea)
    void set_notproc(ea_t ea)
    void clr_notproc(ea_t ea)
    bint is_type_guessed_by_ida(ea_t ea)
    bint is_func_guessed_by_hexrays(ea_t ea)
    bint is_data_guessed_by_hexrays(ea_t ea)
    bint is_type_determined_by_hexrays(ea_t ea)
    bint is_type_guessed_by_hexrays(ea_t ea)
    void set_type_guessed_by_ida(ea_t ea)
    void set_func_guessed_by_hexrays(ea_t ea)
    void set_data_guessed_by_hexrays(ea_t ea)
    void set_type_determined_by_hexrays(ea_t ea)
    void set_notcode(ea_t ea)  # Mark address so that it cannot be converted to instruction
    void clr_notcode(ea_t ea)  # Clear not-code mark
    bint is_notcode(ea_t ea)  # Is the address marked as not-code?
    void set_visible_item(ea_t ea, bint visible)  # Change visibility of item at given ea
    bint is_visible_item(ea_t ea)  # Test visibility of item at given ea
    bint is_finally_visible_item(ea_t ea)  # Is instruction visible?
    void set_source_linnum(ea_t ea, uval_t lnnum)  #  They are sometimes present in object files. @ {
    uval_t get_source_linnum(ea_t ea)
    void del_source_linnum(ea_t ea)
    ea_t get_absbase(ea_t ea)  #  These functions may be used if necessary (despite of...
    void set_absbase(ea_t ea, ea_t x)
    void del_absbase(ea_t ea)
    ea_t get_ind_purged(ea_t ea)  #  Number of bytes purged from the stack when a function...
    void set_ind_purged(ea_t ea, ea_t x)
    void del_ind_purged(ea_t ea)
    uint32 get_str_type(ea_t ea)  #  Use higher level function get_opinfo(). @ {
    void set_str_type(ea_t ea, uint32 x)
    void del_str_type(ea_t ea)
    uchar get_str_type_code(int32 strtype)  #  See
    char get_str_term1(int32 strtype)
    char get_str_term2(int32 strtype)
    uchar get_str_encoding_idx(int32 strtype)  # if the second termination character is ' \ 0', then it...
    int32 set_str_encoding_idx(int32 strtype, int encoding_idx)  # Set index of the string encoding in the string type
    int32 make_str_type(uchar type_code, int encoding_idx, uchar term1, uchar term2)  # Get string type for a string in the given encoding
    bint is_pascal(int32 strtype)
    size_t get_str_type_prefix_length(int32 strtype)
    uint32 get_alignment(ea_t ea)  #  (should be power of 2) These functions may be used if...
    void set_alignment(ea_t ea, uint32 x)
    void del_alignment(ea_t ea)
    void set_item_color(ea_t ea, bgcolor_t color)  #  @ {
    bgcolor_t get_item_color(ea_t ea)
    bint del_item_color(ea_t ea)
    ssize_t get_array_parameters(array_parameters_t* out, ea_t ea)
    void set_array_parameters(ea_t ea, array_parameters_t* in_)
    void del_array_parameters(ea_t ea)
    ssize_t get_switch_info(switch_info_t* out, ea_t ea)  #  See ::switch_info_t, xref.hpp for related functions @ {
    void set_switch_info(ea_t ea, switch_info_t& in_)
    void del_switch_info(ea_t ea)
    ea_t get_switch_parent(ea_t ea)  #  Address which holds the switch info (::switch_info_t)....
    void set_switch_parent(ea_t ea, ea_t x)
    void del_switch_parent(ea_t ea)
    int get_custom_data_type_ids(custom_data_type_ids_t* cdis, ea_t ea)
    void set_custom_data_type_ids(ea_t ea, custom_data_type_ids_t* cdis)
    void del_custom_data_type_ids(ea_t ea)
    bint is_reftype_target_optional(reftype_t type)  # Can the target be calculated using operand value?
    reftype_t get_reftype_by_size(size_t size)  # Get REF_... constant from size Supported sizes:...
    int register_custom_refinfo(custom_refinfo_handler_t* crh)  # Register a new custom refinfo type.
    bint unregister_custom_refinfo(int crid)  # Unregister a new custom refinfo type.
    int find_custom_refinfo(char* name)  # Get id of a custom refinfo type.
    custom_refinfo_handler_t* get_custom_refinfo(int crid)  # Get definition of a registered custom refinfo type.
    custom_refinfo_handler_t* get_custom_refinfo_handler(refinfo_t& ri)  # Get refinfo handler
    void get_refinfo_descs(refinfo_desc_vec_t* descs)
    bint set_refinfo_ex(ea_t ea, int n, refinfo_t* ri)  #  n may be 0, 1, 2, #OPND_MASK. #OPND_OUTER may be used...
    bint set_refinfo(ea_t ea, int n, reftype_t type, ea_t target, ea_t base, adiff_t tdelta)
    bint get_refinfo(refinfo_t* ri, ea_t ea, int n)
    bint del_refinfo(ea_t ea, int n)
    void write_struc_path(ea_t ea, int idx, tid_t* path, int plen, adiff_t delta)  # ---------------------------------------------------------...
    int read_struc_path(tid_t* path, adiff_t* delta, ea_t ea, int idx)
    bint get_tinfo(tinfo_t* tif, ea_t ea)  #  Work with function/data types These functions may be...
    bint set_tinfo(ea_t ea, tinfo_t* tif)
    void del_tinfo(ea_t ea)
    bint get_op_tinfo(tinfo_t* tif, ea_t ea, int n)  #  These functions may be used if necessary (despite of...
    bint set_op_tinfo(ea_t ea, int n, tinfo_t* tif)
    void del_op_tinfo(ea_t ea, int n)
    ssize_t get_root_filename(char* buf, size_t bufsize)  # ---------------------------------------------------------...
    ssize_t dbg_get_input_path(char* buf, size_t bufsize)  # Get debugger input file name/path (see #LFLG_DBG_NOPATH)
    ssize_t get_input_file_path(char* buf, size_t bufsize)  # Get full path of the input file
    void set_root_filename(char* file)  # Set full path of the input file
    size_t retrieve_input_file_size()  # Get size of input file in bytes
    uint32 retrieve_input_file_crc32()  # Get input file crc32 stored in the database. it can be...
    bint retrieve_input_file_md5(uchar* hash)  # Get input file md5
    bint retrieve_input_file_sha256(uchar* hash)  # Get input file sha256
    ssize_t get_asm_inc_file(qstring* buf)  # Get name of the include file
    bint set_asm_inc_file(char* file)  # Set name of the include file
    ea_t get_imagebase()  # Get image base address
    void set_imagebase(ea_t base)  # Set image base address
    netnode get_ids_modnode()  # Get ids modnode
    void set_ids_modnode(netnode id)  # Set ids modnode
    ssize_t get_archive_path(qstring* out)  # Get archive file path from which input file was extracted
    bint set_archive_path(char* file)  # Set archive file path from which input file was extracted
    ssize_t get_loader_format_name(qstring* out)  # Get file format name for loader modules
    void set_loader_format_name(char* name)  # Set file format name for loader modules
    ssize_t get_initial_ida_version(qstring* out)  # Get version of ida which created the database (string...
    ssize_t get_ida_notepad_text(qstring* out)  # Get notepad text
    void set_ida_notepad_text(char* text, size_t size)  # Set notepad text
    ssize_t get_srcdbg_paths(qstring* out)  # Get source debug paths
    void set_srcdbg_paths(char* paths)  # Set source debug paths
    ssize_t get_srcdbg_undesired_paths(qstring* out)  # Get user-closed source files
    void set_srcdbg_undesired_paths(char* paths)  # Set user-closed source files
    ushort get_initial_idb_version()  # Get initial version of the database (numeric format like 700)
    size_t get_elapsed_secs()  # Get seconds database stayed open
    size_t get_idb_nopens()  # Get number of times the database is opened
    int get_encoding_qty()  # Get total number of encodings (counted from 0)
    char* get_encoding_name(int idx)  # Get encoding name for specific index (1-based). 
    int add_encoding(char* encname)  # Add a new encoding (e.g. "UTF-8"). If it's already in...
    bint del_encoding(int idx)  # Delete an encoding The encoding is not actually removed...
    bint rename_encoding(int idx, char* encname)  # Change name for an encoding The number of bytes per unit...
    int get_encoding_bpu(int idx)  # Get the amount of bytes per unit (e.g., 2 for UTF-16, 4...
    int get_encoding_bpu_by_name(char* encname)  # Get the amount of bytes per unit for the given encoding 
    int get_strtype_bpu(int32 strtype)  # ---------------------------------------------------------...
    int get_default_encoding_idx(int bpu)  # Get default encoding index for a specific string type. 
    bint set_default_encoding_idx(int bpu, int idx)  # Set default encoding for a string type 
    char* encoding_from_strtype(int32 strtype)  # Get encoding name for this strtype 
    int get_outfile_encoding_idx()  # Get the index of the encoding used when producing files 
    bint set_outfile_encoding_idx(int idx)  # set encoding to be used when producing files 
    uint get_import_module_qty()  # Get number of import modules
    bint get_import_module_name(qstring* buf, int mod_index)  # Get import module name. 
    void delete_imports()  # Delete all imported modules information
    int validate_idb_names(bint do_repair)  # Check consistency of name records, return number of bad ones
    void set_gotea(ea_t gotea)  # ---------------------------------------------------------...
    ea_t get_gotea()  # ---------------------------------------------------------...
