# cython: language_level=3
# distutils: language=c++
#
# THIS FILE IS AUTO-GENERATED BY pxdgen - DO NOT EDIT
# Generated: 2025-11-30 01:46:38
# Source: hexrays.hpp
#

from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libc.stdint cimport uint8_t, uint16_t, uint32_t, uint64_t
from libc.stdint cimport intptr_t, uintptr_t
from libc.stddef cimport size_t, ptrdiff_t
from libc.stdio cimport FILE
from libcpp cimport bool as cppbool

cdef extern from "hexrays.hpp":
    # =========================================================================
    # Fundamental Types
    # =========================================================================
    ctypedef int64_t adiff_t
    ctypedef uint64_t asize_t
    ctypedef uint32_t bgcolor_t
    ctypedef uint64_t bmask_t
    ctypedef uint64_t ea_t
    ctypedef uint64_t enum_t
    ctypedef int32_t error_t
    ctypedef uint64_t flags64_t
    ctypedef uint32_t flags_t
    ctypedef int16_t int16
    ctypedef int32_t int32
    ctypedef int64_t int64
    ctypedef int8_t int8
    ctypedef uint64_t nodeidx_t
    ctypedef uint8_t op_dtype_t
    ctypedef uint64_t sel_t
    ctypedef int8_t sint8
    ctypedef int64_t sval_t
    ctypedef uint64_t tid_t
    ctypedef uint8_t uchar
    ctypedef uint32_t uint
    ctypedef uint16_t uint16
    ctypedef uint32_t uint32
    ctypedef uint64_t uint64
    ctypedef uint8_t uint8
    ctypedef uint16_t ushort
    ctypedef uint64_t uval_t

    # =========================================================================
    # Typedefs
    # =========================================================================
    ctypedef uint64 ulonglong
    ctypedef int64 longlong
    ctypedef uint16 wchar16_t
    ctypedef uint32 wchar32_t
    ctypedef uint32 ea32_t
    ctypedef uint64 ea64_t
    ctypedef uval_t inode_t  # The inode_t type is the specialization specific inode...
    ctypedef asize_t diffpos_t  # A position in the difference source. This is an abstract...
    ctypedef int sizevec_t
    ctypedef int qhandle_t
    ctypedef int64_t user_ssize_t
    ctypedef int64_t user_long_t
    ctypedef int64_t user_time_t
    ctypedef int64_t user_off_t
    ctypedef uchar comp_t  # ---------------------------------------------------------...
    ctypedef uchar cm_t
    ctypedef uint32 callcnv_t
    ctypedef uint16[11] eNI  # There is one more internal format used by IDA to store...
    ctypedef int16_t int_least16_t
    ctypedef int32_t int_least32_t
    ctypedef int64_t int_least64_t
    ctypedef uint8_t uint_least8_t
    ctypedef uint16_t uint_least16_t
    ctypedef uint32_t uint_least32_t
    ctypedef uint64_t uint_least64_t
    ctypedef int8_t int_fast8_t
    ctypedef int16_t int_fast16_t
    ctypedef int32_t int_fast32_t
    ctypedef int64_t int_fast64_t
    ctypedef uint8_t uint_fast8_t
    ctypedef uint16_t uint_fast16_t
    ctypedef uint32_t uint_fast32_t
    ctypedef uint64_t uint_fast64_t
    ctypedef int64_t quad_t
    ctypedef quad_t* qaddr_t
    ctypedef int32_t swblk_t
    ctypedef uint64 nodeidx64_t
    ctypedef uint32 nodeidx32_t
    ctypedef flags_t aflags_t  #  See
    ctypedef uchar reftype_t  # @ }
    ctypedef uchar type_t  # ---------------------------------------------------------...
    ctypedef uchar p_list
    ctypedef uchar color_t  # @ }
    ctypedef uint64 tif_cursor_t  # ---------------------------------------------------------...
    ctypedef int cpidx_t  # ---------------------------------------------------------...
    ctypedef int cplen_t
    ctypedef int twidget_type_t  # ---------------------------------------------------------...
    ctypedef action_ctx_base_t action_update_ctx_t
    ctypedef int input_event_modifiers_t
    ctypedef input_event_modifiers_t view_event_state_t
    ctypedef view_mouse_event_location_t location_t
    ctypedef action_ctx_base_t action_activation_ctx_t  # ---------------------------------------------------------...
    ctypedef uchar optype_t  # ---------------------------------------------------------...
    ctypedef int help_t  #   The interface consists of two structures: - definition...
    ctypedef int ignore_name_def_t  # What name types to ignore
    ctypedef uchar p_string  # Inside a type string, a pascal-like string: dt length, characters
    ctypedef uint64 bmask64_t  # unsigned value that describes a bitmask
    ctypedef uchar bte_t  # ---------------------------------------------------------...
    ctypedef int type_sign_t
    ctypedef int argloc_type_t  # Specifies the location type of a function argument or a...
    ctypedef size_t biggest_t
    ctypedef uint64 typid_t  # @ }
    ctypedef int voff_set_t
    ctypedef int mreg_t
    ctypedef int easet_t
    ctypedef int minsn_ptr_set_t
    ctypedef int strings_t
    ctypedef uint64 uvlr_t
    ctypedef int64 svlr_t
    ctypedef int maymust_t  # ---------------------------------------------------------...
    ctypedef int user_numforms_t  # Number formats are attached to (ea,opnum) pairs
    ctypedef int lvar_mapping_t  # Local variable mapping (is used to merge variables)
    ctypedef int udcall_map_t  # All user-defined function calls (map address -> udcall)
    ctypedef size_t mbitmap_t  # ---------------------------------------------------------...
    ctypedef uint8 mopt_t  # ---------------------------------------------------------...
    ctypedef mba_t mbl_array_t
    ctypedef int user_cmts_t  # Comments are attached to tree locations:
    ctypedef int user_iflags_t  # citem_t::iflags are attached to (ea,op) pairs
    ctypedef int user_unions_t  # union field selections they are represented as a vector...
    ctypedef int user_labels_t
    ctypedef int eamap_t
    ctypedef int boundaries_t  # map of instruction boundaries. may contain INS_EPILOG...
    ctypedef int cmt_type_t  # Comment types
    ctypedef size_t iterator_word

    # =========================================================================
    # Enums
    # =========================================================================
    cdef enum:
        pool_size
        pool_nelems
    cdef enum tty_control_t:  # Teletype control
        TCT_UNKNOWN
        TCT_OWNER
        TCT_NOT_OWNER
    cdef enum:
        QMOVE_CROSS_FS  # UNIX: allow moving between different filesystem
        QMOVE_OVERWRITE  # Overwrite existing file
        QMOVE_OVR_RO  # Overwrite file even if it is write-protected
    cdef enum range_kind_t:  # ---------------------------------------------------------...
        RANGE_KIND_UNKNOWN
        RANGE_KIND_FUNC
        RANGE_KIND_SEGMENT
        RANGE_KIND_HIDDEN_RANGE
    cdef enum filetype_t:  # ---------------------------------------------------------...
        f_EXE_old  # MS DOS EXE File
        f_COM_old  # MS DOS COM File
        f_BIN  # Binary File
        f_DRV  # MS DOS Driver
        f_WIN  # New Executable (NE)
        f_HEX  # Intel Hex Object File
        f_MEX  # MOS Technology Hex Object File
        f_LX  # Linear Executable (LX)
        f_LE  # Linear Executable (LE)
        f_NLM  # Netware Loadable Module (NLM)
        f_COFF  # Common Object File Format (COFF)
        f_PE  # Portable Executable (PE)
        f_OMF  # Object Module Format
        f_SREC  # Motorola SREC (S-record)
        f_ZIP  # ZIP file (this file is never loaded to IDA database)
        f_OMFLIB  # Library of OMF Modules
        f_AR  # ar library
        f_LOADER  # file is loaded using LOADER DLL
        f_ELF  # Executable and Linkable Format (ELF)
        f_W32RUN  # Watcom DOS32 Extender (W32RUN)
        f_AOUT  # Linux a.out (AOUT)
        f_PRC  # PalmPilot program file
        f_EXE  # MS DOS EXE File
        f_COM  # MS DOS COM File
        f_AIXAR  # AIX ar library
        f_MACHO  # Mac OS X Mach-O
        f_PSXOBJ  # Sony Playstation PSX object file
        f_MD1IMG  # Mediatek Firmware Image
    cdef enum storage_type_t:  # ---------------------------------------------------------...
        STT_CUR = -1  # use current storage type (may be used only as...
        STT_VA = 0  # regular storage: virtual arrays, an explicit...
        STT_MM = 1  # memory map: sparse storage. useful for huge objects
        STT_DBG = 2  # memory map: temporary debugger storage. used internally
    cdef enum inftag_t:
        INF_VERSION
        INF_PROCNAME
        INF_GENFLAGS
        INF_LFLAGS
        INF_DATABASE_CHANGE_COUNT
        INF_FILETYPE
        INF_OSTYPE
        INF_APPTYPE
        INF_ASMTYPE
        INF_SPECSEGS
        INF_AF
        INF_AF2
        INF_BASEADDR
        INF_START_SS
        INF_START_CS
        INF_START_IP
        INF_START_EA
        INF_START_SP
        INF_MAIN
        INF_MIN_EA
        INF_MAX_EA
        INF_OMIN_EA
        INF_OMAX_EA
        INF_LOWOFF
        INF_HIGHOFF
        INF_MAXREF
        INF_PRIVRANGE
        INF_PRIVRANGE_START_EA
        INF_PRIVRANGE_END_EA
        INF_NETDELTA
        INF_XREFNUM
        INF_TYPE_XREFNUM
        INF_REFCMTNUM
        INF_XREFFLAG
        INF_MAX_AUTONAME_LEN
        INF_NAMETYPE
        INF_SHORT_DEMNAMES
        INF_LONG_DEMNAMES
        INF_DEMNAMES
        INF_LISTNAMES
        INF_INDENT
        INF_CMT_INDENT
        INF_MARGIN
        INF_LENXREF
        INF_OUTFLAGS
        INF_CMTFLG
        INF_LIMITER
        INF_BIN_PREFIX_SIZE
        INF_PREFFLAG
        INF_STRLIT_FLAGS
        INF_STRLIT_BREAK
        INF_STRLIT_ZEROES
        INF_STRTYPE
        INF_STRLIT_PREF
        INF_STRLIT_SERNUM
        INF_DATATYPES
        INF_OBSOLETE_CC
        INF_CC_ID
        INF_CC_CM
        INF_CC_SIZE_I
        INF_CC_SIZE_B
        INF_CC_SIZE_E
        INF_CC_DEFALIGN
        INF_CC_SIZE_S
        INF_CC_SIZE_L
        INF_CC_SIZE_LL
        INF_CC_SIZE_LDBL
        INF_ABIBITS
        INF_APPCALL_OPTIONS
        INF_FILE_FORMAT_NAME  # file format name for loader modules
        INF_GROUPS  # segment group information (see init_groups())
        INF_H_PATH  # C header path
        INF_C_MACROS  # C predefined macros
        INF_INCLUDE  # assembler include file name
        INF_DUALOP_GRAPH  # Graph text representation options
        INF_DUALOP_TEXT  # Text text representation options
        INF_MD5  # MD5 of the input file
        INF_IDA_VERSION  # version of ida which created the database
        INF_STR_ENCODINGS  # a list of encodings for the program strings
        INF_DBG_BINPATHS  # unused (20 indexes)
        INF_SHA256  # SHA256 of the input file
        INF_ABINAME  # ABI name (processor specific)
        INF_ARCHIVE_PATH  # archive file path
        INF_PROBLEMS  # problem lists
        INF_SELECTORS  # 2..63 are for selector_t blob (see init_selectors())
        INF_NOTEPAD  # notepad blob, occupies 1000 indexes (1MB of text)
        INF_SRCDBG_PATHS  # source debug paths, occupies 20 indexes
        INF_SRCDBG_UNDESIRED  # user-closed source files, occupies 20 indexes
        INF_INITIAL_VERSION  # initial version of database
        INF_CTIME  # database creation timestamp
        INF_ELAPSED  # seconds database stayed open
        INF_NOPENS  # how many times the database is opened
        INF_CRC32  # input file crc32
        INF_IMAGEBASE  # image base
        INF_IDSNODE  # ids modnode id (for import_module)
        INF_FSIZE  # input file size
        INF_OUTFILEENC  # output file encoding index
        INF_INPUT_FILE_PATH
        INF_COMPILER_INFO  # more inf fields
        INF_CALLCNV  # more inf fields
        INF_LAST  # more inf fields
    cdef enum hook_type_t:  # ---------------------------------------------------------...
        HT_IDP  # Hook to the processor module. The callback...
        HT_UI  # Hook to the user interface. The callback will...
        HT_DBG  # Hook to the debugger. The callback will...
        HT_IDB  # Hook to the database events. These events are...
        HT_DEV  # Internal debugger events. Not stable and...
        HT_VIEW  # Custom/IDA views notifications. Refer to...
        HT_OUTPUT  # Output window notifications. Refer to...
        HT_GRAPH  # Handling graph operations (::graph_notification_t)
        HT_IDD  # Hook to the debugger plugin. The callback will...
        HT_LAST
    cdef enum fpvalue_kind_t:  # Floating value kinds. They are useful when checking for NaN/Inf
        FPV_BADARG  # wrong value of max_exp
        FPV_NORM  # regular value
        FPV_NAN  # NaN
        FPV_PINF  # positive infinity
        FPV_NINF  # negative infinity
    cdef enum fpvalue_error_t:  #  Return values for ieee_realcvt and processor_t::realcvt request
        REAL_ERROR_OK = 1  # no error
        REAL_ERROR_FORMAT = -1  # realcvt: not supported format for current .idp
        REAL_ERROR_RANGE = -2  # realcvt: number too big (small) for store (mem...
        REAL_ERROR_BADDATA = -3  # realcvt: illegal real data for load (IEEE data...
        REAL_ERROR_FPOVER = 2  # floating overflow or underflow
        REAL_ERROR_BADSTR = 3  # asctoreal: illegal input string
        REAL_ERROR_ZERODIV = 4  # ediv: divide by 0
        REAL_ERROR_INTOVER = 5  # eetol*: integer overflow
    cdef enum:
        QOS_CLASS_USER_INTERACTIVE = 33
        QOS_CLASS_USER_INITIATED = 25
        QOS_CLASS_DEFAULT = 21
        QOS_CLASS_UTILITY = 17
        QOS_CLASS_BACKGROUND = 9
        QOS_CLASS_UNSPECIFIED = 0
    cdef enum:
        SWITCH_INFO_VERSION
    cdef enum move_segm_code_t:  #  Return values for move_segm() add rebase_program() @ {
        MOVE_SEGM_OK = 0  # all ok
        MOVE_SEGM_PARAM = -1  # The specified segment does not exist
        MOVE_SEGM_ROOM = -2  # Not enough free room at the target address
        MOVE_SEGM_IDP = -3  # IDP module forbids moving the segment
        MOVE_SEGM_CHUNK = -4  # Too many chunks are defined, can't move
        MOVE_SEGM_LOADER = -5  # The segment has been moved but the loader complained
        MOVE_SEGM_ODD = -6  # Cannot move segments by an odd number of bytes
        MOVE_SEGM_ORPHAN = -7  # Orphan bytes hinder segment movement
        MOVE_SEGM_DEBUG = -8  # Debugger segments cannot be moved
        MOVE_SEGM_SOURCEFILES = -9  # Source files ranges of addresses hinder...
        MOVE_SEGM_MAPPING = -10  # Memory mapping ranges of addresses hinder...
        MOVE_SEGM_INVAL = -11  # Invalid argument (delta/target does not fit...
    cdef enum notify_recerr_t:  # whether or not a message should be printed, letting the...
        nr_none
        nr_once
    cdef enum mbox_kind_t:  # Message box kinds
        mbox_internal  # internal error
        mbox_info
        mbox_warning
        mbox_error
        mbox_nomem
        mbox_feedback
        mbox_readerror
        mbox_writeerror
        mbox_filestruct
        mbox_wait
        mbox_hide
        mbox_replace
    cdef enum choose_type_t:  # List chooser types
        chtype_generic  # the generic choose() function
        chtype_idasgn  # see choose_idasgn()
        chtype_entry  # see choose_entry()
        chtype_name  # see choose_name()
        chtype_stkvar_xref  # see choose_stkvar_xref()
        chtype_xref  # see choose_xref()
        chtype_func  # see choose_func()
        chtype_segm  # see choose_segm()
        chtype_strpath  # see choose_struc_path()
        chtype_idatil  # see choose_til()
        chtype_srcp  # see choose_srcp()
        chtype_struct  # see choose_struct()
        chtype_enum  # see choose_enum()
        chtype_enum_by_value_and_size  # see choose_enum_by_value()
    cdef enum beep_t:
        beep_default
    cdef enum tcc_renderer_type_t:  # TWidget renderer type
        TCCRT_INVALID  # invalid
        TCCRT_FLAT  # flat view
        TCCRT_GRAPH  # graph view
        TCCRT_PROXIMITY  # proximity view
    cdef enum tcc_place_type_t:  # TWidget ::place_t type
        TCCPT_INVALID  # invalid
        TCCPT_PLACE  # ::place_t
        TCCPT_SIMPLELINE_PLACE  # ::simpleline_place_t
        TCCPT_IDAPLACE  # ::idaplace_t
        TCCPT_TIPLACE  # ::tiplace_t
    cdef enum vme_button_t:  # Represents mouse button for view_mouse_event_t objects
        VME_UNKNOWN  # unknown mouse button
        VME_LEFT_BUTTON  # left mouse button
        VME_RIGHT_BUTTON  # right mouse button
        VME_MID_BUTTON  # middle mouse button
    cdef enum data_kind_t:  # data format to display
        dk_float
        dk_int
        dk_addr_names
        dk_addr_text
    cdef enum int_format_t:
        if_hex
        if_signed
        if_unsigned
    cdef enum byte_kind_t:  # result of get_byte_value()
        BK_VALID  # has a valid value
        BK_INVALIDADDR  # address is invalid
        BK_NOVALUE  # address is valid but contains no value
    cdef enum lecvt_code_t:  # ---------------------------------------------------------...
        LECVT_CANCELED = -1
        LECVT_ERROR = 0
        LECVT_OK = 1
    cdef enum action_state_t:  # Action states - returned by action_handler_t::update()
        AST_ENABLE_ALWAYS  # enable action and do not call...
        AST_ENABLE_FOR_IDB  # enable action for the current idb. call...
        AST_ENABLE_FOR_WIDGET  # enable action for the current widget. call...
        AST_ENABLE  # enable action - call...
        AST_DISABLE_ALWAYS  # disable action and do not call...
        AST_DISABLE_FOR_IDB  # analog of ::AST_ENABLE_FOR_IDB
        AST_DISABLE_FOR_WIDGET  # analog of ::AST_ENABLE_FOR_WIDGET
        AST_DISABLE  # analog of ::AST_ENABLE
    cdef enum:
        POPUP_INS
        POPUP_DEL
        POPUP_EDIT
        POPUP_REFRESH
        NSTDPOPUPS
    cdef enum cbres_t:  # return value of ins(), del(), edit(), enter(), refresh()...
        NOTHING_CHANGED
        ALL_CHANGED
        SELECTION_CHANGED
    cdef enum navaddr_type_t:  # ---------------------------------------------------------...
        nat_lib
        nat_fun
        nat_cod
        nat_dat
        nat_und
        nat_ext
        nat_err
        nat_gap
        nat_cur
        nat_auto  # auto-analysis cursor color
        nat_lum  # related to lumina
        nat_hlo  # highlight outline
        nat_last
    cdef enum custom_viewer_handler_id_t:  # Custom viewer & code viewer handler types
        CVH_USERDATA
        CVH_KEYDOWN  # see ::custom_viewer_keydown_t
        CVH_POPUP  # see ::custom_viewer_popup_t
        CVH_DBLCLICK  # see ::custom_viewer_dblclick_t
        CVH_CURPOS  # see ::custom_viewer_curpos_t
        CVH_CLOSE  # see ::custom_viewer_close_t
        CVH_CLICK  # see ::custom_viewer_click_t
        CVH_QT_AWARE  # see set_custom_viewer_qt_aware()
        CVH_HELP  # see ::custom_viewer_help_t
        CVH_MOUSEMOVE  # see ::custom_viewer_mouse_moved_t
        CDVH_USERDATA  # see set_code_viewer_user_data()
        CDVH_SRCVIEW  # see set_code_viewer_is_source()
        CDVH_LINES_CLICK  # see ::code_viewer_lines_click_t
        CDVH_LINES_DBLCLICK  # see ::code_viewer_lines_click_t
        CDVH_LINES_POPUP  # see ::code_viewer_lines_click_t
        CDVH_LINES_DRAWICON  # see ::code_viewer_lines_icon_t
        CDVH_LINES_LINENUM  # see ::code_viewer_lines_linenum_t
        CDVH_LINES_ICONMARGIN  # see set_code_viewer_lines_icon_margin()
        CDVH_LINES_RADIX  # see set_code_viewer_lines_radix()
        CDVH_LINES_ALIGNMENT  # see set_code_viewer_lines_alignment()
    cdef enum msg_notification_t:  # ---------------------------------------------------------...
        msg_activated  # The message window is activated. 
        msg_deactivated  # The message window is deactivated. 
        msg_click  # Click event. 
        msg_dblclick  # Double click event. 
        msg_closed  # View closed. 
        msg_keydown  # Key down event. 
    cdef enum view_notification_t:  # ---------------------------------------------------------...
        view_activated  # A view is activated 
        view_deactivated  # A view is deactivated 
        view_keydown  # Key down event 
        view_click  # Click event 
        view_dblclick  # Double click event 
        view_curpos  # Cursor position changed 
        view_created  # A view is being created. 
        view_close  # View closed 
        view_switched  # A view's renderer has changed. 
        view_mouse_over  # The user moved the mouse over (or out of) a...
        view_loc_changed  # The location for the view has changed (can be...
        view_mouse_moved  # The mouse moved on the view 
    cdef enum input_event_kind_t:  # ---------------------------------------------------------...
        iek_unknown
        iek_shortcut
        iek_key_press
        iek_key_release
        iek_mouse_button_press
        iek_mouse_button_release
        iek_mouse_wheel
    cdef enum:
        MFF_MAGIC
    cdef enum action_attr_t:  # Codes for getting/setting action attributes
        AA_NONE  # no effect
        AA_LABEL  # see update_action_label()
        AA_SHORTCUT  # see update_action_shortcut()
        AA_TOOLTIP  # see update_action_tooltip()
        AA_ICON  # see update_action_icon()
        AA_STATE  # see update_action_state()
        AA_CHECKABLE  # see update_action_checkable()
        AA_CHECKED  # see update_action_checked()
        AA_VISIBILITY  # see update_action_visibility()
    cdef enum cb_id:  #  @ {
        CB_INIT = -1
        CB_YES = -2  # the user pressed 'Yes' button
        CB_CLOSE = -3  # the form is closed by the window manager...
        CB_INVISIBLE = -4  # corresponds to ui_widget_invisible
        CB_DESTROYING = -5  # the actual widget tree is being destroyed
        CB_NO = -6  # the user pressed 'No' button
        CB_CANCEL = -7  # the user pressed 'Cancel' button or Esc
    cdef enum cref_t:  # CODE xref types
        fl_U  # unknown -- for compatibility with old...
        fl_CF  # Call Far This xref creates a function at the...
        fl_CN  # Call Near This xref creates a function at the...
        fl_JF  # Jump Far
        fl_JN  # Jump Near
        fl_USobsolete  # User specified (obsolete)
        fl_F  # Ordinary flow: used to specify execution flow...
    cdef enum dref_t:  # DATA xref types
        dr_U  # Unknown -- for compatibility with old...
        dr_O  # Offset The reference uses 'offset' of data...
        dr_W  # Write access
        dr_R  # Read access
        dr_T  # Text (for forced operands only) Name of data...
        dr_I  # Informational (a derived java class references...
        dr_S  # Reference to enum member (symbolic constant)
    cdef enum cfg_input_kind_t:
        cik_string
        cik_filename
        cik_path
    cdef enum event_t:  # Callback notification codes. These are passed to...
        ev_init  # The IDP module is just loaded. 
        ev_term  # The IDP module is being unloaded
        ev_newprc  # Before changing processor type. 
        ev_newasm  # Before setting a new assembler. 
        ev_newfile  # A new file has been loaded. 
        ev_oldfile  # An old file has been loaded. 
        ev_newbinary  # IDA is about to load a binary file. 
        ev_endbinary  # IDA has loaded a binary file. 
        ev_set_idp_options  # Set IDP-specific configuration option Also see...
        ev_set_proc_options  # Called if the user specified an option string...
        ev_ana_insn  # Analyze one instruction and fill 'out'...
        ev_emu_insn  # Emulate instruction, create cross-references,...
        ev_out_header  # Function to produce start of disassembled text 
        ev_out_footer  # Function to produce end of disassembled text 
        ev_out_segstart  # Function to produce start of segment 
        ev_out_segend  # Function to produce end of segment 
        ev_out_assumes  # Function to produce assume directives when...
        ev_out_insn  # Generate text representation of an instruction...
        ev_out_mnem  # Generate instruction mnemonics. This callback...
        ev_out_operand  # Generate text representation of an instruction...
        ev_out_data  # Generate text representation of data items...
        ev_out_label  # The kernel is going to generate an instruction...
        ev_out_special_item  # Generate text representation of an item in a...
        ev_gen_regvar_def  # Generate register variable definition line. 
        ev_gen_src_file_lnnum  # Callback: generate analog of:  directive. 
        ev_creating_segm  # A new segment is about to be created. 
        ev_moving_segm  # May the kernel move the segment? 
        ev_coagulate  # Try to define some unexplored bytes. This...
        ev_undefine  # An item in the database (insn or data) is...
        ev_treat_hindering_item  # An item hinders creation of another item. 
        ev_rename  # The kernel is going to rename a byte. 
        ev_is_far_jump  # is indirect far jump or call instruction?...
        ev_is_sane_insn  # Is the instruction sane for the current file type?. 
        ev_is_cond_insn  # Is conditional instruction? 
        ev_is_call_insn  # Is the instruction a "call"? 
        ev_is_ret_insn  # Is the instruction a "return"? 
        ev_may_be_func  # Can a function start here? 
        ev_is_basic_block_end  # Is the current instruction end of a basic...
        ev_is_indirect_jump  # Determine if instruction is an indirect jump....
        ev_is_insn_table_jump  # Reserved
        ev_is_switch  # Find 'switch' idiom or override processor...
        ev_calc_switch_cases  # Calculate case values and targets for a custom...
        ev_create_switch_xrefs  # Create xrefs for a custom jump table. 
        ev_is_align_insn  # Is the instruction created only for alignment...
        ev_is_alloca_probe  # Does the function at 'ea' behave as __alloca_probe? 
        ev_delay_slot_insn  # Get delay slot instruction 
        ev_is_sp_based  # Check whether the operand is relative to stack...
        ev_can_have_type  # Can the operand have a type as offset,...
        ev_cmp_operands  # Compare instruction operands 
        ev_adjust_refinfo  # Called from apply_fixup before converting...
        ev_get_operand_string  # Request text string for operand (cli, java, ...). 
        ev_get_reg_name  # Generate text representation of a register....
        ev_str2reg  # Convert a register name to a register number....
        ev_get_autocmt  # Callback: get dynamic auto comment. Will be...
        ev_get_bg_color  # Get item background color. Plugins can hook...
        ev_is_jump_func  # Is the function a trivial "jump" function?. 
        ev_func_bounds  # find_func_bounds() finished its work. The...
        ev_verify_sp  # All function instructions have been analyzed....
        ev_verify_noreturn  # The kernel wants to set 'noreturn' flags for a...
        ev_create_func_frame  # Create a function frame for a newly created...
        ev_get_frame_retsize  # Get size of function return address in bytes...
        ev_get_stkvar_scale_factor  # Should stack variable references be multiplied...
        ev_demangle_name  # Demangle a C++ (or another language) name into...
        ev_add_cref  # A code reference is being created. 
        ev_add_dref  # A data reference is being created. 
        ev_del_cref  # A code reference is being deleted. 
        ev_del_dref  # A data reference is being deleted. 
        ev_coagulate_dref  # Data reference is being analyzed. plugin may...
        ev_may_show_sreg  # The kernel wants to display the segment...
        ev_loader_elf_machine  # ELF loader machine type checkpoint. A plugin...
        ev_auto_queue_empty  # One analysis queue is empty. 
        ev_validate_flirt_func  # Flirt has recognized a library function. This...
        ev_adjust_libfunc_ea  # Called when a signature module has been...
        ev_assemble  # Assemble an instruction. (display a warning if...
        ev_extract_address  # Extract address from a string. 
        ev_realcvt  # Floating point -> IEEE conversion 
        ev_gen_asm_or_lst  # Callback: generating asm or lst file. The...
        ev_gen_map_file  # Generate map file. If not implemented the...
        ev_create_flat_group  # Create special segment representing the flat group. 
        ev_getreg  # IBM PC only internal request, should never be...
        ev_analyze_prolog  # Analyzes function prolog, epilog, and updates...
        ev_calc_spdelta  # Calculate amount of change to sp for the given...
        ev_calcrel  # Reserved
        ev_find_reg_value  # Find register value via a register tracker....
        ev_find_op_value  # Find operand value via a register tracker. The...
        ev_replaying_undo  # Replaying an undo/redo buffer 
        ev_ending_undo  # Ended undoing/redoing an action 
        ev_set_code16_mode  # Some processors have ISA 16-bit mode e.g. ARM...
        ev_get_code16_mode  # Get ISA 16-bit mode 
        ev_get_procmod  # Get pointer to the processor module object....
        ev_asm_installed  # After setting a new assembler 
        ev_get_reg_accesses  # Get info about the registers that are...
        ev_is_control_flow_guard  # Detect if an instruction is a "thunk call" to...
        ev_broadcast  # Broadcast call 
        ev_create_merge_handlers  # Create merge handlers, if needed 
        ev_privrange_changed  # Privrange interval has been moved to a new...
        ev_cvt64_supval  # perform 32-64 conversion for a netnode array element 
        ev_cvt64_hashval  # perform 32-64 conversion for a hash value 
        ev_get_regfinder  # Get pointer to the regfinder object. This...
        ev_gen_stkvar_def  # Generate stack variable definition line...
        ev_is_addr_insn  # Does the instruction calculate some address...
        ev_last_cb_before_debugger  # START OF DEBUGGER CALLBACKS
        ev_next_exec_insn  # Get next address to be executed This function...
        ev_calc_step_over  # Calculate the address of the instruction which...
        ev_calc_next_eas  # Calculate list of addresses the instruction in...
        ev_get_macro_insn_head  # Calculate the start of a macro instruction....
        ev_get_dbr_opnum  # Get the number of the operand to be displayed...
        ev_insn_reads_tbit  # Check if insn will read the TF bit. 
        ev_clean_tbit  # Clear the TF bit after an insn like pushf...
        ev_get_idd_opinfo  # Get operand information. This callback is used...
        ev_get_reg_info  # Get register information by its name. example:...
        ev_update_call_stack  # Calculate the call stack trace for the given...
        ev_last_cb_before_type_callbacks  # START OF TYPEINFO CALLBACKS TODO: get this...
        ev_setup_til  # Setup default type libraries. (called after...
        ev_get_abi_info  # Get all possible ABI names and optional...
        ev_max_ptr_size  # Get maximal size of a pointer in bytes. 
        ev_get_default_enum_size  # Get default enum size. Not generated anymore....
        ev_get_cc_regs  # Get register allocation convention for given...
        ev_get_simd_types  # Get SIMD-related types according to given...
        ev_calc_cdecl_purged_bytes
        ev_calc_purged_bytes  # Calculate number of purged bytes by the given...
        ev_calc_retloc  # Calculate return value location. 
        ev_calc_arglocs  # Calculate function argument locations. This...
        ev_calc_varglocs  # Calculate locations of the arguments that...
        ev_adjust_argloc  # Adjust argloc according to its type/size and...
        ev_lower_func_type  # Get function arguments which should be...
        ev_equal_reglocs  # Are 2 register arglocs the same?. We need this...
        ev_use_stkarg_type  # Use information about a stack argument. 
        ev_use_regarg_type  # Use information about register argument. 
        ev_use_arg_types  # Use information about callee arguments. 
        ev_arg_addrs_ready  # Argument address info is ready. 
        ev_decorate_name  # Decorate/undecorate a C symbol name. 
        ev_arch_changed  # The loader is done parsing arch-related...
        ev_get_stkarg_area_info  # Get some metrics of the stack argument area. 
        ev_last_cb_before_loader
        ev_loader  # This code and higher ones are reserved for the...
    cdef enum access_type_t:  # Possible memory and register access types.
        NO_ACCESS = 0
        WRITE_ACCESS = 1
        READ_ACCESS = 2
        RW_ACCESS = 3
    cdef enum setproc_level_t:  # Flags passed as 'level' parameter to set_processor_type()
        SETPROC_IDB  # set processor type for old idb
        SETPROC_LOADER  # set processor type for new idb; if the user...
        SETPROC_LOADER_NON_FATAL  # the same as SETPROC_LOADER but non-fatal failures.
        SETPROC_USER  # set user-specified processor used for -p and...
    cdef enum local_type_change_t:
        LTC_NONE  # no event (internal use)
        LTC_ADDED  # added a local type
        LTC_DELETED  # deleted a local type
        LTC_EDITED  # edited a local type
        LTC_ALIASED  # added a type alias
        LTC_COMPILER  # changed the compiler and calling convention
        LTC_TIL_LOADED  # loaded a til file
        LTC_TIL_UNLOADED  # unloaded a til file
        LTC_TIL_COMPACTED  # numbered types have been compacted
    cdef enum event_code_t:  # IDB event codes
        closebase  # The database will be closed now
        savebase  # The database is being saved
        upgraded  # The database has been upgraded and the...
        auto_empty  # Info: all analysis queues are empty. This...
        auto_empty_finally  # Info: all analysis queues are empty...
        determined_main  # The main() function has been determined. 
        extlang_changed  # The list of extlangs or the default extlang...
        idasgn_loaded  # FLIRT signature has been loaded for normal...
        kernel_config_loaded  # This event is issued when ida.cfg is parsed. 
        loader_finished  # External file loader finished its work. Use...
        flow_chart_created  # Gui has retrieved a function flow chart....
        compiler_changed  # The kernel has changed the compiler information. ( 
        changing_ti  # An item typestring (c/c++ prototype) is to be changed. 
        ti_changed  # An item typestring (c/c++ prototype) has been changed. 
        changing_op_ti  # An operand typestring (c/c++ prototype) is to...
        op_ti_changed  # An operand typestring (c/c++ prototype) has...
        changing_op_type  # An operand type (offset, hex, etc...) is to be...
        op_type_changed  # An operand type (offset, hex, etc...) has been...
        segm_added  # A new segment has been created. 
        deleting_segm  # A segment is to be deleted. 
        segm_deleted  # A segment has been deleted. 
        changing_segm_start  # Segment start address is to be changed. 
        segm_start_changed  # Segment start address has been changed. 
        changing_segm_end  # Segment end address is to be changed. 
        segm_end_changed  # Segment end address has been changed. 
        changing_segm_name  # Segment name is being changed. 
        segm_name_changed  # Segment name has been changed. 
        changing_segm_class  # Segment class is being changed. 
        segm_class_changed  # Segment class has been changed. 
        segm_attrs_updated  # Segment attributes has been changed. 
        segm_moved  # Segment has been moved. 
        allsegs_moved  # Program rebasing is complete. This event is...
        func_added  # The kernel has added a function. 
        func_updated  # The kernel has updated a function. 
        set_func_start  # Function chunk start address will be changed. 
        set_func_end  # Function chunk end address will be changed. 
        deleting_func  # The kernel is about to delete a function. 
        frame_deleted  # The kernel has deleted a function frame. 
        thunk_func_created  # A thunk bit has been set for a function. 
        func_tail_appended  # A function tail chunk has been appended. 
        deleting_func_tail  # A function tail chunk is to be removed. 
        func_tail_deleted  # A function tail chunk has been removed. 
        tail_owner_changed  # A tail chunk owner has been changed. 
        func_noret_changed  # #FUNC_NORET bit has been changed. 
        stkpnts_changed  # Stack change points have been modified. 
        updating_tryblks  # About to update tryblk information 
        tryblks_updated  # Updated tryblk information 
        deleting_tryblks  # About to delete tryblk information in given range 
        sgr_changed  # The kernel has changed a segment register value. 
        make_code  # An instruction is being created. 
        make_data  # A data item is being created. 
        destroyed_items  # Instructions/data have been destroyed in [ea1,ea2). 
        renamed  # The kernel has renamed a byte. See also the...
        byte_patched  # A byte has been patched. 
        changing_cmt  # An item comment is to be changed. 
        cmt_changed  # An item comment has been changed. 
        changing_range_cmt  # Range comment is to be changed. 
        range_cmt_changed  # Range comment has been changed. 
        extra_cmt_changed  # An extra comment has been changed. 
        item_color_changed  # An item color has been changed. 
        callee_addr_changed  # Callee address has been updated by the user. 
        bookmark_changed  # Boomarked position changed. 
        sgr_deleted  # The kernel has deleted a segment register value. 
        adding_segm  # A segment is being created. 
        func_deleted  # A function has been deleted. 
        dirtree_mkdir  # Dirtree: a directory has been created. 
        dirtree_rmdir  # Dirtree: a directory has been deleted. 
        dirtree_link  # Dirtree: an item has been linked/unlinked. 
        dirtree_move  # Dirtree: a directory or item has been moved. 
        dirtree_rank  # Dirtree: a directory or item rank has been changed. 
        dirtree_rminode  # Dirtree: an inode became unavailable. 
        dirtree_segm_moved  # Dirtree: inodes were changed due to a segment...
        local_types_changed  # Local types have been changed 
        lt_udm_created  # local type udt member has been added 
        lt_udm_deleted  # local type udt member has been deleted 
        lt_udm_renamed  # local type udt member has been renamed 
        lt_udm_changed  # local type udt member has been changed 
        lt_udt_expanded  # A structure type has been expanded/shrank. 
        frame_created  # A function frame has been created. 
        frame_udm_created  # Frame member has been added. 
        frame_udm_deleted  # Frame member has been deleted. 
        frame_udm_renamed  # Frame member has been renamed. 
        frame_udm_changed  # Frame member has been changed. 
        frame_expanded  # A frame type has been expanded/shrank. 
        idasgn_matched_ea  # A FLIRT match has been found 
        lt_edm_created  # local type enum member has been added 
        lt_edm_deleted  # local type enum member has been deleted 
        lt_edm_renamed  # local type enum member has been renamed 
        lt_edm_changed  # local type enum member has been changed 
        local_type_renamed  # Local type has been renamed 
    cdef enum fc_block_type_t:  # Flow chart block types
        fcb_normal  # normal block
        fcb_indjump  # block ends with indirect jump
        fcb_ret  # return block
        fcb_cndret  # conditional return block
        fcb_noret  # noreturn block
        fcb_enoret  # external noreturn block (does not belong to...
        fcb_extern  # external normal block
        fcb_error  # block passes execution past the function end
    cdef enum edge_type_t:
        EDGE_NONE
        EDGE_TREE
        EDGE_FORWARD
        EDGE_BACK
        EDGE_CROSS
        EDGE_SUBGRAPH  # edge of a subgraph (used in collapse)
    cdef enum ofile_type_t:  # ---------------------------------------------------------...
        OFILE_MAP  # MAP file
        OFILE_EXE  # Executable file
        OFILE_IDC  # IDC file
        OFILE_LST  # Disassembly listing
        OFILE_ASM  # Assembly
        OFILE_DIF  # Difference
    cdef enum path_type_t:  # ---------------------------------------------------------...
        PATH_TYPE_CMD  # full path to the file specified in the command line
        PATH_TYPE_IDB  # full path of IDB file
        PATH_TYPE_ID0  # full path of ID0 file
    cdef enum ucdr_kind_t:  # @ }
        UCDR_STRLIT  # string literals
        UCDR_NAME  # regular (unmangled) names
        UCDR_MANGLED  # mangled names
        UCDR_TYPE  # type names
    cdef enum nametype_t:
        VNT_IDENT  # identifier (e.g., function name)
        VNT_TYPE  # type name (can contain ' < ', '>', ...)
        VNT_UDTMEM  # UDT (structure, union, enum) member
        VNT_STRLIT  # string literal
        VNT_VISIBLE  # visible cp (obsolete; will be deleted)
    cdef enum debug_name_how_t:  # Specify strategy for retrieving debug names
        DEBNAME_EXACT  # find a name at exactly the specified address
        DEBNAME_LOWER  # find a name with the address >= the specified address
        DEBNAME_UPPER  # find a name with the address >  the specified address
        DEBNAME_NICE  # find a name with the address < = the specified address
    cdef enum demreq_type_t:  # @ }
        DQT_NPURGED_8 = -8  # only calculate number of purged bytes (sizeof(arg)==8)
        DQT_NPURGED_4 = -4  # only calculate number of purged bytes (sizeof(arg)==4)
        DQT_NPURGED_2 = -2  # only calculate number of purged bytes (sizeof(arg)==2)
        DQT_COMPILER = 0  # only detect compiler that generated the name
        DQT_NAME_TYPE = 1  # only detect the name type (data/code)
        DQT_FULL = 2  # really demangle
    cdef enum argreg_policy_t:  # ---------------------------------------------------------...
        ARGREGS_POLICY_UNDEFINED
        ARGREGS_GP_ONLY  # GP registers used for all arguments
        ARGREGS_INDEPENDENT  # FP/GP registers used separately (like gcc64)
        ARGREGS_BY_SLOTS  # fixed FP/GP register per each slot (like vc64)
        ARGREGS_FP_MASKS_GP  # FP register also consumes one or more GP regs...
        ARGREGS_MIPS_O32  # MIPS ABI o32
        ARGREGS_RISCV  # Risc-V API FP arguments are passed in GP...
    cdef enum reg_kind_t:  # Init registers (sequential)
        GPREGS
        FPREGS
    cdef enum abs_t:  # ---------------------------------------------------------...
        ABS_UNK
        ABS_NO
        ABS_YES
    cdef enum sclass_t:
        SC_UNK  # unknown
        SC_TYPE  # typedef
        SC_EXT  # extern
        SC_STAT  # static
        SC_REG  # register
        SC_AUTO  # auto
        SC_FRIEND  # friend
        SC_VIRT  # virtual
    cdef enum tinfo_code_t:  # Error codes various tinfo functions:
        TERR_OK = 0  # ok
        TERR_SAVE_ERROR = -1  # failed to save
        TERR_SERIALIZE = -2  # failed to serialize
        TERR_BAD_NAME = -3  # name %s is not acceptable
        TERR_BAD_ARG = -4  # bad argument
        TERR_BAD_TYPE = -5  # bad type
        TERR_BAD_SIZE = -6  # bad size %d
        TERR_BAD_INDEX = -7  # bad index %d
        TERR_BAD_ARRAY = -8  # arrays are forbidden as function arguments
        TERR_BAD_BF = -9  # bitfields are forbidden as function arguments
        TERR_BAD_OFFSET = -10  # bad member offset %s
        TERR_BAD_UNIVAR = -11  # unions cannot have variable sized members
        TERR_BAD_VARLAST = -12  # variable sized member must be the last member...
        TERR_OVERLAP = -13  # the member overlaps with other members that...
        TERR_BAD_SUBTYPE = -14  # recursive structure nesting is forbidden
        TERR_BAD_VALUE = -15  # value 0x%I64X is not acceptable
        TERR_NO_BMASK = -16  # bitmask 0x%I64X is not found
        TERR_BAD_BMASK = -17  # Bad enum member mask 0x%I64X. The specified...
        TERR_BAD_MSKVAL = -18  # bad bmask and value combination...
        TERR_BAD_REPR = -19  # bad or incompatible field representation
        TERR_GRP_NOEMPTY = -20  # could not delete group mask for not empty group 0x%I64X
        TERR_DUPNAME = -21  # duplicate name %s
        TERR_UNION_BF = -22  # unions cannot have bitfields
        TERR_BAD_TAH = -23  # bad bits in the type attributes (TAH bits)
        TERR_BAD_BASE = -24  # bad base class
        TERR_BAD_GAP = -25  # bad gap
        TERR_NESTED = -26  # recursive structure nesting is forbidden
        TERR_NOT_COMPAT = -27  # the new type is not compatible with the old type
        TERR_BAD_LAYOUT = -28  # failed to calculate the structure/union layout
        TERR_BAD_GROUPS = -29  # bad group sizes for bitmask enum
        TERR_BAD_SERIAL = -30  # enum value has too many serials
        TERR_ALIEN_NAME = -31  # enum member name is used in another enum
        TERR_STOCK = -32  # stock type info cannot be modified
        TERR_ENUM_SIZE = -33  # bad enum size
        TERR_NOT_IMPL = -34  # not implemented
        TERR_TYPE_WORSE = -35  # the new type is worse than the old type
        TERR_BAD_FX_SIZE = -36  # cannot extend struct beyond fixed size
        TERR_STRUCT_SIZE = -37  # bad fixed structure size
        TERR_NOT_FOUND = -38  # member not found
        TERR_COUNT = 39
    cdef enum stock_type_id_t:  # IDs for common types
        STI_PCHAR  # char *
        STI_PUCHAR  # uint8 *
        STI_PCCHAR  # const char *
        STI_PCUCHAR  # const uint8 *
        STI_PBYTE  # _BYTE *
        STI_PINT  # int *
        STI_PUINT  # unsigned int *
        STI_PVOID  # void *
        STI_PPVOID  # void **
        STI_PCVOID  # const void *
        STI_ACHAR  # char[]
        STI_AUCHAR  # uint8[]
        STI_ACCHAR  # const char[]
        STI_ACUCHAR  # const uint8[]
        STI_FPURGING  # void __userpurge(int)
        STI_FDELOP  # void __cdecl(void *)
        STI_MSGSEND  # void *(void *, const char *, ...)
        STI_AEABI_LCMP  # int __fastcall __pure(int64 x, int64 y)
        STI_AEABI_ULCMP  # int __fastcall __pure(uint64 x, uint64 y)
        STI_DONT_USE  # unused stock type id; should not be used
        STI_SIZE_T  # size_t
        STI_SSIZE_T  # ssize_t
        STI_AEABI_MEMCPY  # void __fastcall(void *, const void *, size_t)
        STI_AEABI_MEMSET  # void __fastcall(void *, size_t, int)
        STI_AEABI_MEMCLR  # void __fastcall(void *, size_t)
        STI_RTC_CHECK_2  # int16 __fastcall(int16 x)
        STI_RTC_CHECK_4  # int32 __fastcall(int32 x)
        STI_RTC_CHECK_8  # int64 __fastcall(int64 x)
        STI_COMPLEX64  # struct complex64_t { float real, imag; }
        STI_COMPLEX128  # struct complex128_t { double real, imag; }
        STI_PUNKNOWN  # _UNKNOWN *
        STI_LAST
    cdef enum etf_flag_t:  # Constants to be used the editing methods  @ {
        ETF_NO_SAVE = 1  # don't save to til (normally typerefs are saved...
        ETF_NO_LAYOUT = 2  # don't calc type layout before editing
        ETF_MAY_DESTROY = 4  # may destroy other members
        ETF_COMPATIBLE = 8  # new type must be compatible with the old
        ETF_FUNCARG = 16  # udm - member is a function argument (cannot...
        ETF_FORCENAME = 32  # anyway use name, see below for more usage description
        ETF_AUTONAME = 64  # udm - generate a member name if was not...
        ETF_BYTIL = 128  # udm - new type was created by the type subsystem
        ETF_NO_ARRAY = 256  # add_udm, set_udm_type - do not convert type to...
    cdef enum gtd_udt_t:  # Constants to be used with get_udt_details()
        GTD_CALC_LAYOUT  # calculate udt layout
        GTD_NO_LAYOUT  # don't calculate udt layout please note that...
        GTD_DEL_BITFLDS  # delete udt bitfields
    cdef enum gtd_func_t:  # Constants to be used with get_func_details()
        GTD_CALC_ARGLOCS  # calculate func arg locations
        GTD_NO_ARGLOCS  # don't calculate func arg locations please note...
    cdef enum gts_code_t:  # Constants to be used with get_size()
        GTS_NESTED  # nested type (embedded into a udt)
        GTS_BASECLASS  # is baseclass of a udt
    cdef enum gta_prop_t:  # Various type properties (properties are 64-bit scalar values)
        GTA_DECLALIGN  # declared alignment
        GTA_RESOLVE  # real type (fully resolve eventual type references)
        GTA_REALTYPE  # real type (do not fully resolve type refs)
        GTA_TYPE_SIGN  # get type sign
        GTA_FROM_SUBTIL  # is from a subtil (not from main til)
        GTA_IS_FORWARD  # is forward declaration?
        GTA_IS_FUNCPTR  # is a pointer to a function?
        GTA_ORDINAL  # get initial type ordinal
        GTA_FINAL_ORDINAL  # get final (resolved) type ordinal
        GTA_PTR_OBJ  # ptr: pointed type
        GTA_SAFE_PTR_OBJ  # ptr: pointed type or type itself
        GTA_ARRAY_ELEM  # array: array element
        GTA_ARRAY_NELEMS  # array: number of elements
        GTA_PTRARR_SUBTIF  # ptr &array : pointed object or array element
        GTA_PTRARR_SIZE  # ptr &array : get size of subtype
        GTA_UNPADDED_SIZE  # udt: sizeof baseclass when embedded into a...
        GTA_UDT_NMEMBERS  # udt: get number of udt members
        GTA_IS_SMALL_UDT  # udt: is small udt (can be passed in regs)
        GTA_ONEMEM_TYPE  # udt &array : object consisting of one member:...
        GTA_ENUM_BASE_TYPE  # enum: get enum base type
        GTA_FUNC_CC  # func: calling convention
        GTA_PURGED_BYTES  # func: number of purged bytes
        GTA_IS_HIGH_TYPE  # func: is high type
        GTA_FUNC_NARGS  # func: number of arguments
        GTA_FUNC_RET  # func: get function return type
        GTA_FUNC_ARG  # func: get type of function arg
        GTA_LAST_FUNC_ARG
        GTA_IS_SSE_TYPE  # is a SSE vector type?
        GTA_IS_ANON_UDT  # is anonymous struct/union?
        GTA_OBSOLETE1
        GTA_HAS_VFTABLE  # has vftable?
        GTA_IS_SHIFTED_PTR  # is a shifted pointer?
        GTA_IS_VARSTRUCT  # is a variable-size structure?
        GTA_IS_VARMEMBER  # is a variable member type?
        GTA_IS_TYPEDEF  # is a typedef?
        GTA_FINAL_ELEM  # if array, skip possible arrays, return a non-array type
        GTA_FORWARD_TYPE  # if a forward declaration, return either...
        GTA_BITMASK  # enum: is bitmask or regular enum
        GTA_ENUM_RADIX  # enum: get enum radix
        GTA_EDM  # enum: get enum type member by index
        GTA_EDM_BYVAL  # enum: find enum type member by value/serial/bmask
        GTA_EDM_BYNAME  # enum: find enum type member by name
        GTA_HAS_UNION  # has members of type "union"?
        GTA_UDM_TID  # udt: get member TID
        GTA_ALIAS  # get type alias
        GTA_EDM_TID  # enum: get enum member tid
        GTA_FRAME_FUNC  # frame: get function address for the frame
        GTA_UDM_IS_BYTIL  # udm: was the member created due to the type system
        GTA_OBSOLETE2
        GTA_EDT_NMEMBERS  # enum: get number of enum members
        GTA_ENUM_WIDTH  # enum: get enum width
        GTA_ENUM_REPR  # enum: get enum value representation
        GTA_UDT_BITS  # udt: get udt_type_data_t::taudt_bits
    cdef enum sta_prop_t:
        STA_DECLALIGN  # set declared alignment
        STA_TYPE_SIGN  # set type sign
        STA_UDT_ALIGN  # calculate udt field alignments
        STA_UDT_METHODS  # set udt member functions
        STA_RENAME  # set type name
        STA_COMMENT  # set type comment
        STA_CLR_MODIFS  # clear 'const/volatile' bits
        STA_SET_SDA  # udt: set struct alignment
        STA_SET_PACK  # udt: set struct packing
        STA_ADD_UDM  # udt: add a struct member
        STA_DEL_UDMS  # udt: del struct members
        STA_UDM_NAME  # udt: rename a struct member
        STA_UDM_TYPE  # udt: set type of a struct member
        STA_UDM_CMT  # udt: set comment of a struct member
        STA_UDM_REPR  # udt: set repr of a struct member
        STA_EXPAND_UDT  # udt: expand/shrink struct
        STA_ENUM_WIDTH  # enum: set the width of enum base type
        STA_ENUM_SIGN  # enum: set enum sign
        STA_BITMASK  # enum: make/unmake enum a bitmask
        STA_ENUM_REPR  # enum: set enum base repr
        STA_ADD_EDM  # enum: add enum member
        STA_DEL_EDMS  # enum: del enum members
        STA_EDM_NAME  # enum: rename enum member
        STA_EDM_CMT  # enum: set comment of an enum member
        STA_EDIT_EDM  # enum: change constant value and/or bitmask
        STA_ALIAS  # set type alias
        STA_ALIGNMENT  # set type alignment
        STA_UDM_SET_BYTIL  # udm: the member is created due to the type system
        STA_FIXED_STRUCT  # struct: use fixed member offsets
        STA_STRUCT_SIZE  # struct: set struct size (only for fixed structs)
        STA_FUNCARG_NAME  # func: rename a function argument
        STA_FUNCARG_TYPE  # func: set type of a function argument
        STA_FUNC_RETTYPE  # func: set function return type
        STA_DEL_FUNCARGS  # func: del function arguments
        STA_ADD_FUNCARG  # func: add function argument
        STA_FUNC_CC  # func: set calling convention
        STA_ENUM_RADIX  # enum: set enum radix
        STA_FUNCARG_LOC  # func: set argument location
        STA_FUNC_RETLOC  # func: set location of function return value
        STA_TUPLE  # struct: set as tuple
    cdef enum gta_pdata_t:
        GTP_NAME  # get referenced name
        GTP_NEXT_NAME  # get immediately next referenced name
        GTP_FINAL_NAME  # get final referenced name
        GTP_TIL  # get type library
        GTP_UDT_METHODS  # get udt member functions
        GTP_COMMENT  # get type comment
        GTP_RPTCMT  # get repeatable type comment
        GTP_BIT_BUCKETS  # get bit buckets
        GTP_NICE_NAME  # get the referenced name and apply regular...
    cdef enum bitmask_cvt_stance_t:  # Set or clear the 'bitmask' attribute of an enum. This...
        ENUMBM_OFF  # convert to ordinal enum
        ENUMBM_ON  # convert to bitmask enum
        ENUMBM_AUTO  # convert to bitmask if the outcome is nice and useful
    cdef enum format_functype_t:  # ---------------------------------------------------------...
        FMTFUNC_PRINTF
        FMTFUNC_SCANF
        FMTFUNC_STRFTIME
        FMTFUNC_STRFMON
    cdef enum update_type_t:  # See begin_type_updating()
        UTP_ENUM
        UTP_STRUCT
    cdef enum:
        MAX_VLR_SIZE
    cdef enum cmpop_t:
        CMP_NZ
        CMP_Z
        CMP_AE
        CMP_B
        CMP_A
        CMP_BE
        CMP_GT
        CMP_GE
        CMP_LT
        CMP_LE
    cdef enum merror_t:  # ---------------------------------------------------------...
        MERR_OK = 0  # ok
        MERR_BLOCK = 1  # no error, switch to new block
        MERR_INTERR = -1  # internal error
        MERR_INSN = -2  # cannot convert to microcode
        MERR_MEM = -3  # not enough memory
        MERR_BADBLK = -4  # bad block found
        MERR_BADSP = -5  # positive sp value has been found
        MERR_PROLOG = -6  # prolog analysis failed
        MERR_SWITCH = -7  # wrong switch idiom
        MERR_EXCEPTION = -8  # exception analysis failed
        MERR_HUGESTACK = -9  # stack frame is too big
        MERR_LVARS = -10  # local variable allocation failed
        MERR_BITNESS = -11  # 16-bit functions cannot be decompiled
        MERR_BADCALL = -12  # could not determine call arguments
        MERR_BADFRAME = -13  # function frame is wrong
        MERR_UNKTYPE = -14  # undefined type %s (currently unused error code)
        MERR_BADIDB = -15  # inconsistent database information
        MERR_SIZEOF = -16  # wrong basic type sizes in compiler settings
        MERR_REDO = -17  # redecompilation has been requested
        MERR_CANCELED = -18  # decompilation has been cancelled
        MERR_RECDEPTH = -19  # max recursion depth reached during lvar allocation
        MERR_OVERLAP = -20  # variables would overlap: %s
        MERR_PARTINIT = -21  # partially initialized variable %s
        MERR_COMPLEX = -22  # too complex function
        MERR_LICENSE = -23  # no license available
        MERR_ONLY32 = -24  # only 32-bit functions can be decompiled for...
        MERR_ONLY64 = -25  # only 64-bit functions can be decompiled for...
        MERR_BUSY = -26  # already decompiling a function
        MERR_FARPTR = -27  # far memory model is supported only for pc
        MERR_EXTERN = -28  # special segments cannot be decompiled
        MERR_FUNCSIZE = -29  # too big function
        MERR_BADRANGES = -30  # bad input ranges
        MERR_BADARCH = -31  # current architecture is not supported
        MERR_DSLOT = -32  # bad instruction in the delay slot
        MERR_STOP = -33  # no error, stop the analysis
        MERR_CLOUD = -34  # cloud: %s
        MERR_EMULATOR = -35  # emulator: %s
        MERR_MAX_ERR = 35
        MERR_LOOP = -36  # internal code: redo last loop (never reported)
    cdef enum mcode_t:  # Instructions marked with *F may have the FPINSN bit set...
        m_nop  # nop                       // no operation
        m_stx  # stx  l,    {r=sel, d=off} // store register to...
        m_ldx  # ldx  {l=sel,r=off}, d     // load register...
        m_ldc  # ldc  l=const,     d       // load constant
        m_mov  # mov  l,           d       // move             ...
        m_neg  # neg  l,           d       // negate
        m_lnot  # lnot l,           d       // logical not
        m_bnot  # bnot l,           d       // bitwise not
        m_xds  # xds  l,           d       // extend (signed)
        m_xdu  # xdu  l,           d       // extend (unsigned)
        m_low  # low  l,           d       // take low part
        m_high  # high l,           d       // take high part
        m_add  # add  l,   r,      d       // l + r -> dst
        m_sub  # sub  l,   r,      d       // l - r -> dst
        m_mul  # mul  l,   r,      d       // l * r -> dst
        m_udiv  # udiv l,   r,      d       // l / r -> dst
        m_sdiv  # sdiv l,   r,      d       // l / r -> dst
        m_umod  # umod l,   r,      d       // l % r -> dst
        m_smod  # smod l,   r,      d       // l % r -> dst
        m_or  # or   l,   r,      d       // bitwise or
        m_and  # and  l,   r,      d       // bitwise and
        m_xor  # xor  l,   r,      d       // bitwise xor
        m_shl  # shl  l,   r,      d       // shift logical left
        m_shr  # shr  l,   r,      d       // shift logical right
        m_sar  # sar  l,   r,      d       // shift arithmetic right
        m_cfadd  # cfadd l,  r,    d=carry   // calculate carry  ...
        m_ofadd  # ofadd l,  r,    d=overf   // calculate...
        m_cfshl  # cfshl l,  r,    d=carry   // calculate carry  ...
        m_cfshr  # cfshr l,  r,    d=carry   // calculate carry  ...
        m_sets  # sets  l,          d=byte  SF=1          Sign
        m_seto  # seto  l,  r,      d=byte  OF=1         ...
        m_setp  # setp  l,  r,      d=byte  PF=1         ...
        m_setnz  # setnz l,  r,      d=byte  ZF=0          Not...
        m_setz  # setz  l,  r,      d=byte  ZF=1          Equal ...
        m_setae  # setae l,  r,      d=byte  CF=0         ...
        m_setb  # setb  l,  r,      d=byte  CF=1         ...
        m_seta  # seta  l,  r,      d=byte  CF=0 & ZF=0  ...
        m_setbe  # setbe l,  r,      d=byte  CF=1 | ZF=1  ...
        m_setg  # setg  l,  r,      d=byte  SF=OF & ZF=0  Signed Greater
        m_setge  # setge l,  r,      d=byte  SF=OF         Signed...
        m_setl  # setl  l,  r,      d=byte  SF!=OF        Signed Less
        m_setle  # setle l,  r,      d=byte  SF!=OF | ZF=1 Signed...
        m_jcnd  # jcnd   l,         d       // d is mop_v or mop_b
        m_jnz  # jnz    l, r,      d       // ZF=0          Not...
        m_jz  # jz     l, r,      d       // ZF=1         ...
        m_jae  # jae    l, r,      d       // CF=0         ...
        m_jb  # jb     l, r,      d       // CF=1         ...
        m_ja  # ja     l, r,      d       // CF=0 & ZF=0  ...
        m_jbe  # jbe    l, r,      d       // CF=1 | ZF=1  ...
        m_jg  # jg     l, r,      d       // SF=OF & ZF=0 ...
        m_jge  # jge    l, r,      d       // SF=OF        ...
        m_jl  # jl     l, r,      d       // SF!=OF        Signed Less
        m_jle  # jle    l, r,      d       // SF!=OF | ZF=1...
        m_jtbl  # jtbl   l, r=mcases        // Table jump
        m_ijmp  # ijmp       {r=sel, d=off} // indirect...
        m_goto  # goto   l                  // l is mop_v or mop_b
        m_call  # call   l          d       // l is mop_v or...
        m_icall  # icall  {l=sel, r=off} d   // indirect call
        m_ret  # ret
        m_push  # push   l
        m_pop  # pop               d
        m_und  # und               d       // undefine
        m_ext  # ext  in1, in2,  out1      // external insn,...
        m_f2i  # f2i    l,    d       int(l) => d; convert fp...
        m_f2u  # f2u    l,    d       uint(l)=> d; convert fp...
        m_i2f  # i2f    l,    d       fp(l)  => d; convert...
        m_u2f  # i2f    l,    d       fp(l)  => d; convert...
        m_f2f  # f2f    l,    d       l      => d; change fp...
        m_fneg  # fneg   l,    d       -l     => d; change sign ...
        m_fadd  # fadd   l, r, d       l + r  => d; add         ...
        m_fsub  # fsub   l, r, d       l - r  => d; subtract    ...
        m_fmul  # fmul   l, r, d       l * r  => d; multiply    ...
        m_fdiv  # fdiv   l, r, d       l / r  => d; divide      ...
    cdef enum type_source_t:  # Type source (where the type information comes from)
        GUESSED_NONE  # not guessed, specified by the user
        GUESSED_WEAK  # not guessed, comes from idb
        GUESSED_FUNC  # guessed as a function
        GUESSED_DATA  # guessed as a data item
        TS_NOELL  # can be used in set_type() to avoid merging...
        TS_SHRINK  # can be used in set_type() to prefer smaller arguments
        TS_DONTREF  # do not mark type as referenced (referenced_types)
        TS_MASK  # all high bits
    cdef enum side_effect_t:  # ---------------------------------------------------------...
        NO_SIDEFF  # change operand size but ignore side effects if...
        WITH_SIDEFF  # change operand size and handle side effects
        ONLY_SIDEFF  # only handle side effects
        ANY_REGSIZE  # any register size is permitted
        ANY_FPSIZE  # any size of floating operand is permitted
    cdef enum funcrole_t:  # Function roles. They are used to calculate use/def lists...
        ROLE_UNK  # unknown function role
        ROLE_EMPTY  # empty, does not do anything (maybe spoils regs)
        ROLE_MEMSET  # memset(void *dst, uchar value, size_t count);
        ROLE_MEMSET32  # memset32(void *dst, uint32 value, size_t count);
        ROLE_MEMSET64  # memset64(void *dst, uint64 value, size_t count);
        ROLE_MEMCPY  # memcpy(void *dst, const void *src, size_t count);
        ROLE_STRCPY  # strcpy(char *dst, const char *src);
        ROLE_STRLEN  # strlen(const char *src);
        ROLE_STRCAT  # strcat(char *dst, const char *src);
        ROLE_TAIL  # char *tail(const char *str);
        ROLE_BUG  # BUG() helper macro: never returns, causes exception
        ROLE_ALLOCA  # alloca() function
        ROLE_BSWAP  # bswap() function (any size)
        ROLE_PRESENT  # present() function (used in patterns)
        ROLE_CONTAINING_RECORD  # CONTAINING_RECORD() macro
        ROLE_FASTFAIL  # __fastfail()
        ROLE_READFLAGS  # __readeflags, __readcallersflags
        ROLE_IS_MUL_OK  # is_mul_ok
        ROLE_SATURATED_MUL  # saturated_mul
        ROLE_BITTEST  # [lock] bt
        ROLE_BITTESTANDSET  # [lock] bts
        ROLE_BITTESTANDRESET  # [lock] btr
        ROLE_BITTESTANDCOMPLEMENT  # [lock] btc
        ROLE_VA_ARG  # va_arg() macro
        ROLE_VA_COPY  # va_copy() function
        ROLE_VA_START  # va_start() function
        ROLE_VA_END  # va_end() function
        ROLE_ROL  # rotate left
        ROLE_ROR  # rotate right
        ROLE_CFSUB3  # carry flag after subtract with carry
        ROLE_OFSUB3  # overflow flag after subtract with carry
        ROLE_ABS  # integer absolute value
        ROLE_3WAYCMP0  # 3-way compare helper, returns -1/0/1
        ROLE_3WAYCMP1  # 3-way compare helper, returns 0/1/2
        ROLE_WMEMCPY  # wchar_t *wmemcpy(wchar_t *dst, const wchar_t...
        ROLE_WMEMSET  # wchar_t *wmemset(wchar_t *dst, wchar_t wc, size_t n)
        ROLE_WCSCPY  # wchar_t *wcscpy(wchar_t *dst, const wchar_t *src);
        ROLE_WCSLEN  # size_t wcslen(const wchar_t *s)
        ROLE_WCSCAT  # wchar_t *wcscat(wchar_t *dst, const wchar_t *src)
        ROLE_SSE_CMP4  # e.g. _mm_cmpgt_ss
        ROLE_SSE_CMP8  # e.g. _mm_cmpgt_sd
    cdef enum mblock_type_t:  # ---------------------------------------------------------...
        BLT_NONE  # unknown block type
        BLT_STOP  # stops execution regularly (must be the last block)
        BLT_0WAY  # does not have successors (tail is a noret function)
        BLT_1WAY  # passes execution to one block (regular or goto block)
        BLT_2WAY  # passes execution to two blocks (conditional jump)
        BLT_NWAY  # passes execution to many blocks (switch idiom)
        BLT_XTRN  # external block (out of function address)
    cdef enum warnid_t:  # ---------------------------------------------------------...
        WARN_VARARG_REGS  # 0 cannot handle register arguments in vararg...
        WARN_ILL_PURGED  # 1 odd caller purged bytes %d, correcting
        WARN_ILL_FUNCTYPE  # 2 invalid function type '%s' has been ignored
        WARN_VARARG_TCAL  # 3 cannot handle tail call to vararg
        WARN_VARARG_NOSTK  # 4 call vararg without local stack
        WARN_VARARG_MANY  # 5 too many varargs, some ignored
        WARN_ADDR_OUTARGS  # 6 cannot handle address arithmetics in...
        WARN_DEP_UNK_CALLS  # 7 found interdependent unknown calls
        WARN_ILL_ELLIPSIS  # 8 erroneously detected ellipsis type has been ignored
        WARN_GUESSED_TYPE  # 9 using guessed type %s;
        WARN_EXP_LINVAR  # 10 failed to expand a linear variable
        WARN_WIDEN_CHAINS  # 11 failed to widen chains
        WARN_BAD_PURGED  # 12 inconsistent function type and number of...
        WARN_CBUILD_LOOPS  # 13 too many cbuild loops
        WARN_NO_SAVE_REST  # 14 could not find valid save-restore pair for %s
        WARN_ODD_INPUT_REG  # 15 odd input register %s
        WARN_ODD_ADDR_USE  # 16 odd use of a variable address
        WARN_MUST_RET_FP  # 17 function return type is incorrect (must be...
        WARN_ILL_FPU_STACK  # 18 inconsistent fpu stack
        WARN_SELFREF_PROP  # 19 self-referencing variable has been detected
        WARN_WOULD_OVERLAP  # 20 variables would overlap: %s
        WARN_ARRAY_INARG  # 21 array has been used for an input argument
        WARN_MAX_ARGS  # 22 too many input arguments, some ignored
        WARN_BAD_FIELD_TYPE  # 23 incorrect structure member type for %s::%s, ignored
        WARN_WRITE_CONST  # 24 write access to const memory at %a has been detected
        WARN_BAD_RETVAR  # 25 wrong return variable
        WARN_FRAG_LVAR  # 26 fragmented variable at %s may be wrong
        WARN_HUGE_STKOFF  # 27 exceedingly huge offset into the stack frame
        WARN_UNINITED_REG  # 28 reference to an uninitialized register has...
        WARN_FIXED_INSN  # 29 fixed broken insn
        WARN_WRONG_VA_OFF  # 30 wrong offset of va_list variable
        WARN_CR_NOFIELD  # 31 CONTAINING_RECORD: no field '%s' in struct...
        WARN_CR_BADOFF  # 32 CONTAINING_RECORD: too small offset %d for...
        WARN_BAD_STROFF  # 33 user specified stroff has not been processed: %s
        WARN_BAD_VARSIZE  # 34 inconsistent variable size for '%s'
        WARN_UNSUPP_REG  # 35 unsupported processor register '%s'
        WARN_UNALIGNED_ARG  # 36 unaligned function argument '%s'
        WARN_BAD_STD_TYPE  # 37 corrupted or unexisting local type '%s'
        WARN_BAD_CALL_SP  # 38 bad sp value at call
        WARN_MISSED_SWITCH  # 39 wrong markup of switch jump, skipped it
        WARN_BAD_SP  # 40 positive sp value %a has been found
        WARN_BAD_STKPNT  # 41 wrong sp change point
        WARN_UNDEF_LVAR  # 42 variable '%s' is possibly undefined
        WARN_JUMPOUT  # 43 control flows out of bounds
        WARN_BAD_VALRNG  # 44 values range analysis failed
        WARN_BAD_SHADOW  # 45 ignored the value written to the shadow...
        WARN_OPT_VALRNG  # 46 conditional instruction was optimized away...
        WARN_RET_LOCREF  # 47 returning address of temporary local variable '%s'
        WARN_BAD_MAPDST  # 48 too short map destination '%s' for variable '%s'
        WARN_BAD_INSN  # 49 bad instruction
        WARN_ODD_ABI  # 50 encountered odd instruction for the current ABI
        WARN_UNBALANCED_STACK  # 51 unbalanced stack, ignored a potential tail call
        WARN_OPT_VALRNG2  # 52 mask 0x%X is shortened because %s < = 0x%X"
        WARN_OPT_VALRNG3  # 53 masking with 0X%X was optimized away...
        WARN_OPT_USELESS_JCND  # 54 simplified comparisons for '%s': %s became %s
        WARN_SUBFRAME_OVERFLOW  # 55 call arguments overflow the function chunk frame
        WARN_OPT_VALRNG4  # 56 the cases %s were optimized away because %s
        WARN_MAX  # may be used in notes as a placeholder when the...
    cdef enum mba_maturity_t:  # ---------------------------------------------------------...
        MMAT_ZERO  # microcode does not exist
        MMAT_GENERATED  # generated microcode
        MMAT_PREOPTIMIZED  # preoptimized pass is complete
        MMAT_LOCOPT  # local optimization of each basic block is...
        MMAT_CALLS  # detected call arguments. see also hxe_calls_done
        MMAT_GLBOPT1  # performed the first pass of global optimization
        MMAT_GLBOPT2  # most global optimization passes are done
        MMAT_GLBOPT3  # completed all global optimization. microcode...
        MMAT_LVARS  # allocated local variables
    cdef enum memreg_index_t:  # ---------------------------------------------------------...
        MMIDX_GLBLOW  # global memory: low part
        MMIDX_LVARS  # stack: local variables
        MMIDX_RETADDR  # stack: return address
        MMIDX_SHADOW  # stack: shadow arguments
        MMIDX_ARGS  # stack: regular stack arguments
        MMIDX_GLBHIGH  # global memory: high part
    cdef enum gctype_t:  # ---------------------------------------------------------...
        GC_REGS_AND_STKVARS  # registers and stkvars (restricted memory only)
        GC_ASR  # all the above and assertions
        GC_XDSU  # only registers calculated with FULL_XDSU
        GC_END  # number of chain types
        GC_DIRTY_ALL  # bitmask to represent all chains
    cdef enum ctype_t:  # ---------------------------------------------------------...
        cot_empty
        cot_comma  # x, y
        cot_asg  # x = y
        cot_asgbor  # x |= y
        cot_asgxor  # x ^= y
        cot_asgband  # x & = y
        cot_asgadd  # x += y
        cot_asgsub  # x -= y
        cot_asgmul  # x *= y
        cot_asgsshr  # x >>= y signed
        cot_asgushr  # x >>= y unsigned
        cot_asgshl  # x < < = y
        cot_asgsdiv  # x /= y signed
        cot_asgudiv  # x /= y unsigned
        cot_asgsmod  # x %= y signed
        cot_asgumod  # x %= y unsigned
        cot_tern  # x ? y : z
        cot_lor  # x || y
        cot_land  # x & & y
        cot_bor  # x | y
        cot_xor  # x ^ y
        cot_band  # x & y
        cot_eq  # x == y int or fpu (see EXFL_FPOP)
        cot_ne  # x != y int or fpu (see EXFL_FPOP)
        cot_sge  # x >= y signed or fpu (see EXFL_FPOP)
        cot_uge  # x >= y unsigned
        cot_sle  # x < = y signed or fpu (see EXFL_FPOP)
        cot_ule  # x < = y unsigned
        cot_sgt  # x >  y signed or fpu (see EXFL_FPOP)
        cot_ugt  # x >  y unsigned
        cot_slt  # x < y signed or fpu (see EXFL_FPOP)
        cot_ult  # x < y unsigned
        cot_sshr  # x >> y signed
        cot_ushr  # x >> y unsigned
        cot_shl  # x < < y
        cot_add  # x + y
        cot_sub  # x - y
        cot_mul  # x * y
        cot_sdiv  # x / y signed
        cot_udiv  # x / y unsigned
        cot_smod  # x % y signed
        cot_umod  # x % y unsigned
        cot_fadd  # x + y fp
        cot_fsub  # x - y fp
        cot_fmul  # x * y fp
        cot_fdiv  # x / y fp
        cot_fneg  # -x fp
        cot_neg  # -x
        cot_cast  # (type)x
        cot_lnot  # !x
        cot_bnot  # ~x
        cot_ptr  # *x, access size in 'ptrsize'
        cot_ref  #  &x
        cot_postinc  # x++
        cot_postdec  # x--
        cot_preinc  # ++x
        cot_predec  # --x
        cot_call  # x(...)
        cot_idx  # x[y]
        cot_memref  # x.m
        cot_memptr  # x->m, access size in 'ptrsize'
        cot_num  # n
        cot_fnum  # fpc
        cot_str  # string constant (user representation)
        cot_obj  # obj_ea
        cot_var  # v
        cot_insn  # instruction in expression, internal representation only
        cot_sizeof  # sizeof(x)
        cot_helper  # arbitrary name
        cot_type  # arbitrary type
        cot_last
        cit_empty  # instruction types start here
        cit_block  # block-statement: { ... }
        cit_expr  # expression-statement: expr;
        cit_if  # if-statement
        cit_for  # for-statement
        cit_while  # while-statement
        cit_do  # do-statement
        cit_switch  # switch-statement
        cit_break  # break-statement
        cit_continue  # continue-statement
        cit_return  # return-statement
        cit_goto  # goto-statement
        cit_asm  # asm-statement
        cit_try  # C++ try-statement
        cit_throw  # C++ throw-statement
        cit_end
    cdef enum ctree_maturity_t:  # Ctree maturity level. The level will increase as we...
        CMAT_ZERO  # does not exist
        CMAT_BUILT  # just generated
        CMAT_TRANS1  # applied first wave of transformations
        CMAT_NICE  # nicefied expressions
        CMAT_TRANS2  # applied second wave of transformations
        CMAT_CPA  # corrected pointer arithmetic
        CMAT_TRANS3  # applied third wave of transformations
        CMAT_CASTED  # added necessary casts
        CMAT_FINAL  # ready-to-use
    cdef enum item_preciser_t:  # ---------------------------------------------------------...
        ITP_EMPTY  # nothing
        ITP_ARG1  # , (64 entries are reserved for 64 call arguments)
        ITP_ARG64  # ,
        ITP_BRACE1  # (
        ITP_INNER_LAST
        ITP_ASM  # __asm-line
        ITP_ELSE  # else-line
        ITP_DO  # do-line
        ITP_SEMI  # semicolon
        ITP_CURLY1  # {
        ITP_CURLY2  # }
        ITP_BRACE2  # )
        ITP_COLON  # : (label)
        ITP_BLOCK1  # opening block comment. this comment is printed...
        ITP_BLOCK2  # closing block comment.
        ITP_TRY  # C++ try statement
        ITP_CASE  # bit for switch cases
        ITP_SIGN  # if this bit is set too, then we have a...
    cdef enum cmt_retrieval_type_t:  # Comment retrieval type. Ctree remembers what comments...
        RETRIEVE_ONCE  # Retrieve comment if it has not been used yet
        RETRIEVE_ALWAYS  # Retrieve comment even if it has been used
    cdef enum use_curly_t:  # Should curly braces be printed?
        CALC_CURLY_BRACES  # print curly braces if necessary
        NO_CURLY_BRACES  # don't print curly braces
        USE_CURLY_BRACES  # print curly braces without any checks
    cdef enum cursor_item_type_t:  # Type of the cursor item.
        VDI_NONE  # undefined
        VDI_EXPR  # c-tree item
        VDI_LVAR  # declaration of local variable
        VDI_FUNC  # the function itself (the very first line with...
        VDI_TAIL  # cursor is at (beyond) the line end (commentable line)
    cdef enum allow_unused_labels_t:  # Unused label disposition.
        FORBID_UNUSED_LABELS  # Unused labels cause interr
        ALLOW_UNUSED_LABELS  # Unused labels are permitted
    cdef enum hexrays_event_t:  # Decompiler events. Use install_hexrays_callback() to...
        hxe_flowchart  # Flowchart has been generated. 
        hxe_stkpnts  # SP change points have been calculated. 
        hxe_prolog  # Prolog analysis has been finished. 
        hxe_microcode  # Microcode has been generated. 
        hxe_preoptimized  # Microcode has been preoptimized. 
        hxe_locopt  # Basic block level optimization has been finished. 
        hxe_prealloc  # Local variables: preallocation step begins. 
        hxe_glbopt  # Global optimization has been finished. If...
        hxe_pre_structural  # Structure analysis is starting. 
        hxe_structural  # Structural analysis has been finished. 
        hxe_maturity  # Ctree maturity level is being changed. 
        hxe_interr  # Internal error has occurred. 
        hxe_combine  # Trying to combine instructions of basic block. 
        hxe_print_func  # Printing ctree and generating text. 
        hxe_func_printed  # Function text has been generated. Plugins may...
        hxe_resolve_stkaddrs  # The optimizer is about to resolve stack addresses. 
        hxe_build_callinfo  # Analyzing a call instruction. 
        hxe_callinfo_built  # A call instruction has been anallyzed. 
        hxe_calls_done  # All calls have been analyzed. 
        hxe_begin_inlining  # Starting to inline outlined functions. 
        hxe_inlining_func  # A set of ranges is going to be inlined. 
        hxe_inlined_func  # A set of ranges got inlined. 
        hxe_collect_warnings  # Collect warning messages from plugins. These...
        hxe_open_pseudocode = 100  # User interface related events:
        hxe_switch_pseudocode  # Existing pseudocode view has been reloaded...
        hxe_refresh_pseudocode  # Existing pseudocode text has been refreshed....
        hxe_close_pseudocode  # Pseudocode view is being closed. 
        hxe_keyboard  # Keyboard has been hit. 
        hxe_right_click  # Mouse right click. Use hxe_populating_popup...
        hxe_double_click  # Mouse double click. 
        hxe_curpos  # Current cursor position has been changed. (for...
        hxe_create_hint  # Create a hint for the current item. 
        hxe_text_ready  # Decompiled text is ready. 
        hxe_populating_popup  # Populating popup menu. We can add menu items now. 
        lxe_lvar_name_changed  # Local variable got renamed. 
        lxe_lvar_type_changed  # Local variable type got changed. 
        lxe_lvar_cmt_changed  # Local variable comment got changed. 
        lxe_lvar_mapping_changed  # Local variable mapping got changed. 
        hxe_cmt_changed  # Comment got changed. 
        hxe_mba_maturity  # Maturity level of an MBA was changed. 
    cdef enum input_device_t:  # Type of the input device. How the user command has been invoked
        USE_KEYBOARD  # Keyboard
        USE_MOUSE  # Mouse
    cdef enum hexcall_t:  # API call numbers
        hx_user_numforms_begin
        hx_user_numforms_end
        hx_user_numforms_next
        hx_user_numforms_prev
        hx_user_numforms_first
        hx_user_numforms_second
        hx_user_numforms_find
        hx_user_numforms_insert
        hx_user_numforms_erase
        hx_user_numforms_clear
        hx_user_numforms_size
        hx_user_numforms_free
        hx_user_numforms_new
        hx_lvar_mapping_begin
        hx_lvar_mapping_end
        hx_lvar_mapping_next
        hx_lvar_mapping_prev
        hx_lvar_mapping_first
        hx_lvar_mapping_second
        hx_lvar_mapping_find
        hx_lvar_mapping_insert
        hx_lvar_mapping_erase
        hx_lvar_mapping_clear
        hx_lvar_mapping_size
        hx_lvar_mapping_free
        hx_lvar_mapping_new
        hx_udcall_map_begin
        hx_udcall_map_end
        hx_udcall_map_next
        hx_udcall_map_prev
        hx_udcall_map_first
        hx_udcall_map_second
        hx_udcall_map_find
        hx_udcall_map_insert
        hx_udcall_map_erase
        hx_udcall_map_clear
        hx_udcall_map_size
        hx_udcall_map_free
        hx_udcall_map_new
        hx_user_cmts_begin
        hx_user_cmts_end
        hx_user_cmts_next
        hx_user_cmts_prev
        hx_user_cmts_first
        hx_user_cmts_second
        hx_user_cmts_find
        hx_user_cmts_insert
        hx_user_cmts_erase
        hx_user_cmts_clear
        hx_user_cmts_size
        hx_user_cmts_free
        hx_user_cmts_new
        hx_user_iflags_begin
        hx_user_iflags_end
        hx_user_iflags_next
        hx_user_iflags_prev
        hx_user_iflags_first
        hx_user_iflags_second
        hx_user_iflags_find
        hx_user_iflags_insert
        hx_user_iflags_erase
        hx_user_iflags_clear
        hx_user_iflags_size
        hx_user_iflags_free
        hx_user_iflags_new
        hx_user_unions_begin
        hx_user_unions_end
        hx_user_unions_next
        hx_user_unions_prev
        hx_user_unions_first
        hx_user_unions_second
        hx_user_unions_find
        hx_user_unions_insert
        hx_user_unions_erase
        hx_user_unions_clear
        hx_user_unions_size
        hx_user_unions_free
        hx_user_unions_new
        hx_user_labels_begin
        hx_user_labels_end
        hx_user_labels_next
        hx_user_labels_prev
        hx_user_labels_first
        hx_user_labels_second
        hx_user_labels_find
        hx_user_labels_insert
        hx_user_labels_erase
        hx_user_labels_clear
        hx_user_labels_size
        hx_user_labels_free
        hx_user_labels_new
        hx_eamap_begin
        hx_eamap_end
        hx_eamap_next
        hx_eamap_prev
        hx_eamap_first
        hx_eamap_second
        hx_eamap_find
        hx_eamap_insert
        hx_eamap_erase
        hx_eamap_clear
        hx_eamap_size
        hx_eamap_free
        hx_eamap_new
        hx_boundaries_begin
        hx_boundaries_end
        hx_boundaries_next
        hx_boundaries_prev
        hx_boundaries_first
        hx_boundaries_second
        hx_boundaries_find
        hx_boundaries_insert
        hx_boundaries_erase
        hx_boundaries_clear
        hx_boundaries_size
        hx_boundaries_free
        hx_boundaries_new
        hx_block_chains_begin
        hx_block_chains_end
        hx_block_chains_next
        hx_block_chains_prev
        hx_block_chains_get
        hx_block_chains_find
        hx_block_chains_insert
        hx_block_chains_erase
        hx_block_chains_clear
        hx_block_chains_size
        hx_block_chains_free
        hx_block_chains_new
        hx_hexrays_alloc
        hx_hexrays_free
        hx_valrng_t_clear
        hx_valrng_t_copy
        hx_valrng_t_assign
        hx_valrng_t_compare
        hx_valrng_t_set_eq
        hx_valrng_t_set_cmp
        hx_valrng_t_reduce_size
        hx_valrng_t_intersect_with
        hx_valrng_t_unite_with
        hx_valrng_t_inverse
        hx_valrng_t_has
        hx_valrng_t_print
        hx_valrng_t_dstr
        hx_valrng_t_cvt_to_single_value
        hx_valrng_t_cvt_to_cmp
        hx_get_merror_desc
        hx_must_mcode_close_block
        hx_is_mcode_propagatable
        hx_negate_mcode_relation
        hx_swap_mcode_relation
        hx_get_signed_mcode
        hx_get_unsigned_mcode
        hx_mcode_modifies_d
        hx_operand_locator_t_compare
        hx_vd_printer_t_print
        hx_file_printer_t_print
        hx_qstring_printer_t_print
        hx_dstr
        hx_is_type_correct
        hx_is_small_udt
        hx_is_nonbool_type
        hx_is_bool_type
        hx_partial_type_num
        hx_get_float_type
        hx_get_int_type_by_width_and_sign
        hx_get_unk_type
        hx_dummy_ptrtype
        hx_get_member_type
        hx_make_pointer
        hx_create_typedef
        hx_get_type
        hx_set_type
        hx_vdloc_t_dstr
        hx_vdloc_t_compare
        hx_vdloc_t_is_aliasable
        hx_print_vdloc
        hx_arglocs_overlap
        hx_lvar_locator_t_compare
        hx_lvar_locator_t_dstr
        hx_lvar_t_dstr
        hx_lvar_t_is_promoted_arg
        hx_lvar_t_accepts_type
        hx_lvar_t_set_lvar_type
        hx_lvar_t_set_width
        hx_lvar_t_append_list
        hx_lvar_t_append_list_
        hx_lvars_t_find_stkvar
        hx_lvars_t_find
        hx_lvars_t_find_lvar
        hx_restore_user_lvar_settings
        hx_save_user_lvar_settings
        hx_modify_user_lvars
        hx_modify_user_lvar_info
        hx_locate_lvar
        hx_restore_user_defined_calls
        hx_save_user_defined_calls
        hx_parse_user_call
        hx_convert_to_user_call
        hx_install_microcode_filter
        hx_udc_filter_t_cleanup
        hx_udc_filter_t_init
        hx_udc_filter_t_apply
        hx_bitset_t_bitset_t
        hx_bitset_t_copy
        hx_bitset_t_add
        hx_bitset_t_add_
        hx_bitset_t_add__
        hx_bitset_t_sub
        hx_bitset_t_sub_
        hx_bitset_t_sub__
        hx_bitset_t_cut_at
        hx_bitset_t_shift_down
        hx_bitset_t_has
        hx_bitset_t_has_all
        hx_bitset_t_has_any
        hx_bitset_t_dstr
        hx_bitset_t_empty
        hx_bitset_t_count
        hx_bitset_t_count_
        hx_bitset_t_last
        hx_bitset_t_fill_with_ones
        hx_bitset_t_fill_gaps
        hx_bitset_t_has_common
        hx_bitset_t_intersect
        hx_bitset_t_is_subset_of
        hx_bitset_t_compare
        hx_bitset_t_goup
        hx_ivl_t_dstr
        hx_ivl_t_compare
        hx_ivlset_t_add
        hx_ivlset_t_add_
        hx_ivlset_t_addmasked
        hx_ivlset_t_sub
        hx_ivlset_t_sub_
        hx_ivlset_t_has_common
        hx_ivlset_t_print
        hx_ivlset_t_dstr
        hx_ivlset_t_count
        hx_ivlset_t_has_common_
        hx_ivlset_t_contains
        hx_ivlset_t_includes
        hx_ivlset_t_intersect
        hx_ivlset_t_compare
        hx_rlist_t_print
        hx_rlist_t_dstr
        hx_mlist_t_addmem
        hx_mlist_t_print
        hx_mlist_t_dstr
        hx_mlist_t_compare
        hx_get_temp_regs
        hx_is_kreg
        hx_reg2mreg
        hx_mreg2reg
        hx_get_mreg_name
        hx_install_optinsn_handler
        hx_remove_optinsn_handler
        hx_install_optblock_handler
        hx_remove_optblock_handler
        hx_simple_graph_t_compute_dominators
        hx_simple_graph_t_compute_immediate_dominators
        hx_simple_graph_t_depth_first_preorder
        hx_simple_graph_t_depth_first_postorder
        hx_simple_graph_t_goup
        hx_mutable_graph_t_resize
        hx_mutable_graph_t_goup
        hx_mutable_graph_t_del_edge
        hx_lvar_ref_t_compare
        hx_lvar_ref_t_var
        hx_stkvar_ref_t_compare
        hx_stkvar_ref_t_get_stkvar
        hx_fnumber_t_print
        hx_fnumber_t_dstr
        hx_mop_t_copy
        hx_mop_t_assign
        hx_mop_t_swap
        hx_mop_t_erase
        hx_mop_t_print
        hx_mop_t_dstr
        hx_mop_t_create_from_mlist
        hx_mop_t_create_from_ivlset
        hx_mop_t_create_from_vdloc
        hx_mop_t_create_from_scattered_vdloc
        hx_mop_t_create_from_insn
        hx_mop_t_make_number
        hx_mop_t_make_fpnum
        hx_mop_t__make_gvar
        hx_mop_t_make_gvar
        hx_mop_t_make_reg_pair
        hx_mop_t_make_helper
        hx_mop_t_is_bit_reg
        hx_mop_t_may_use_aliased_memory
        hx_mop_t_is01
        hx_mop_t_is_sign_extended_from
        hx_mop_t_is_zero_extended_from
        hx_mop_t_equal_mops
        hx_mop_t_lexcompare
        hx_mop_t_for_all_ops
        hx_mop_t_for_all_scattered_submops
        hx_mop_t_is_constant
        hx_mop_t_get_stkoff
        hx_mop_t_make_low_half
        hx_mop_t_make_high_half
        hx_mop_t_make_first_half
        hx_mop_t_make_second_half
        hx_mop_t_shift_mop
        hx_mop_t_change_size
        hx_mop_t_preserve_side_effects
        hx_mop_t_apply_ld_mcode
        hx_mcallarg_t_print
        hx_mcallarg_t_dstr
        hx_mcallarg_t_set_regarg
        hx_mcallinfo_t_lexcompare
        hx_mcallinfo_t_set_type
        hx_mcallinfo_t_get_type
        hx_mcallinfo_t_print
        hx_mcallinfo_t_dstr
        hx_mcases_t_compare
        hx_mcases_t_print
        hx_mcases_t_dstr
        hx_vivl_t_extend_to_cover
        hx_vivl_t_intersect
        hx_vivl_t_print
        hx_vivl_t_dstr
        hx_chain_t_print
        hx_chain_t_dstr
        hx_chain_t_append_list
        hx_chain_t_append_list_
        hx_block_chains_t_get_chain
        hx_block_chains_t_print
        hx_block_chains_t_dstr
        hx_graph_chains_t_for_all_chains
        hx_graph_chains_t_release
        hx_minsn_t_init
        hx_minsn_t_copy
        hx_minsn_t_set_combined
        hx_minsn_t_swap
        hx_minsn_t_print
        hx_minsn_t_dstr
        hx_minsn_t_setaddr
        hx_minsn_t_optimize_subtree
        hx_minsn_t_for_all_ops
        hx_minsn_t_for_all_insns
        hx_minsn_t__make_nop
        hx_minsn_t_equal_insns
        hx_minsn_t_lexcompare
        hx_minsn_t_is_noret_call
        hx_minsn_t_is_helper
        hx_minsn_t_find_call
        hx_minsn_t_has_side_effects
        hx_minsn_t_find_opcode
        hx_minsn_t_find_ins_op
        hx_minsn_t_find_num_op
        hx_minsn_t_modifies_d
        hx_minsn_t_is_between
        hx_minsn_t_may_use_aliased_memory
        hx_minsn_t_serialize
        hx_minsn_t_deserialize
        hx_getf_reginsn
        hx_getb_reginsn
        hx_mblock_t_init
        hx_mblock_t_print
        hx_mblock_t_dump
        hx_mblock_t_vdump_block
        hx_mblock_t_insert_into_block
        hx_mblock_t_remove_from_block
        hx_mblock_t_for_all_insns
        hx_mblock_t_for_all_ops
        hx_mblock_t_for_all_uses
        hx_mblock_t_optimize_insn
        hx_mblock_t_optimize_block
        hx_mblock_t_build_lists
        hx_mblock_t_optimize_useless_jump
        hx_mblock_t_append_use_list
        hx_mblock_t_append_def_list
        hx_mblock_t_build_use_list
        hx_mblock_t_build_def_list
        hx_mblock_t_find_first_use
        hx_mblock_t_find_redefinition
        hx_mblock_t_is_rhs_redefined
        hx_mblock_t_find_access
        hx_mblock_t_get_valranges
        hx_mblock_t_get_valranges_
        hx_mblock_t_get_reginsn_qty
        hx_mba_ranges_t_range_contains
        hx_mba_t_stkoff_vd2ida
        hx_mba_t_stkoff_ida2vd
        hx_mba_t_idaloc2vd
        hx_mba_t_idaloc2vd_
        hx_mba_t_vd2idaloc
        hx_mba_t_vd2idaloc_
        hx_mba_t_term
        hx_mba_t_get_curfunc
        hx_mba_t_set_maturity
        hx_mba_t_optimize_local
        hx_mba_t_build_graph
        hx_mba_t_get_graph
        hx_mba_t_analyze_calls
        hx_mba_t_optimize_global
        hx_mba_t_alloc_lvars
        hx_mba_t_dump
        hx_mba_t_vdump_mba
        hx_mba_t_print
        hx_mba_t_verify
        hx_mba_t_mark_chains_dirty
        hx_mba_t_insert_block
        hx_mba_t_remove_block
        hx_mba_t_copy_block
        hx_mba_t_remove_empty_and_unreachable_blocks
        hx_mba_t_merge_blocks
        hx_mba_t_for_all_ops
        hx_mba_t_for_all_insns
        hx_mba_t_for_all_topinsns
        hx_mba_t_find_mop
        hx_mba_t_create_helper_call
        hx_mba_t_get_func_output_lists
        hx_mba_t_arg
        hx_mba_t_alloc_fict_ea
        hx_mba_t_map_fict_ea
        hx_mba_t_serialize
        hx_mba_t_deserialize
        hx_mba_t_save_snapshot
        hx_mba_t_alloc_kreg
        hx_mba_t_free_kreg
        hx_mba_t_inline_func
        hx_mba_t_locate_stkpnt
        hx_mba_t_set_lvar_name
        hx_mbl_graph_t_is_accessed_globally
        hx_mbl_graph_t_get_ud
        hx_mbl_graph_t_get_du
        hx_cdg_insn_iterator_t_next
        hx_codegen_t_clear
        hx_codegen_t_emit
        hx_codegen_t_emit_
        hx_change_hexrays_config
        hx_get_hexrays_version
        hx_open_pseudocode
        hx_close_pseudocode
        hx_get_widget_vdui
        hx_decompile_many
        hx_hexrays_failure_t_desc
        hx_send_database
        hx_gco_info_t_append_to_list
        hx_get_current_operand
        hx_remitem
        hx_negated_relation
        hx_swapped_relation
        hx_get_op_signness
        hx_asgop
        hx_asgop_revert
        hx_cnumber_t_print
        hx_cnumber_t_value
        hx_cnumber_t_assign
        hx_cnumber_t_compare
        hx_var_ref_t_compare
        hx_ctree_visitor_t_apply_to
        hx_ctree_visitor_t_apply_to_exprs
        hx_ctree_parentee_t_recalc_parent_types
        hx_cfunc_parentee_t_calc_rvalue_type
        hx_citem_locator_t_compare
        hx_citem_t_contains_expr
        hx_citem_t_contains_label
        hx_citem_t_find_parent_of
        hx_citem_t_find_closest_addr
        hx_cexpr_t_assign
        hx_cexpr_t_compare
        hx_cexpr_t_replace_by
        hx_cexpr_t_cleanup
        hx_cexpr_t_put_number
        hx_cexpr_t_print1
        hx_cexpr_t_calc_type
        hx_cexpr_t_equal_effect
        hx_cexpr_t_is_child_of
        hx_cexpr_t_contains_operator
        hx_cexpr_t_get_high_nbit_bound
        hx_cexpr_t_get_low_nbit_bound
        hx_cexpr_t_requires_lvalue
        hx_cexpr_t_has_side_effects
        hx_cexpr_t_maybe_ptr
        hx_cexpr_t_dstr
        hx_cif_t_assign
        hx_cif_t_compare
        hx_cloop_t_assign
        hx_cfor_t_compare
        hx_cwhile_t_compare
        hx_cdo_t_compare
        hx_creturn_t_compare
        hx_cthrow_t_compare
        hx_cgoto_t_compare
        hx_casm_t_compare
        hx_cinsn_t_assign
        hx_cinsn_t_compare
        hx_cinsn_t_replace_by
        hx_cinsn_t_cleanup
        hx_cinsn_t_new_insn
        hx_cinsn_t_create_if
        hx_cinsn_t_print
        hx_cinsn_t_print1
        hx_cinsn_t_is_ordinary_flow
        hx_cinsn_t_contains_insn
        hx_cinsn_t_collect_free_breaks
        hx_cinsn_t_collect_free_continues
        hx_cinsn_t_dstr
        hx_cblock_t_compare
        hx_carglist_t_compare
        hx_ccase_t_compare
        hx_ccases_t_compare
        hx_cswitch_t_compare
        hx_ccatch_t_compare
        hx_ctry_t_compare
        hx_ctree_item_t_get_udm
        hx_ctree_item_t_get_edm
        hx_ctree_item_t_get_lvar
        hx_ctree_item_t_get_ea
        hx_ctree_item_t_get_label_num
        hx_ctree_item_t_print
        hx_ctree_item_t_dstr
        hx_lnot
        hx_new_block
        hx_vcreate_helper
        hx_vcall_helper
        hx_make_num
        hx_make_ref
        hx_dereference
        hx_save_user_labels
        hx_save_user_cmts
        hx_save_user_numforms
        hx_save_user_iflags
        hx_save_user_unions
        hx_restore_user_labels
        hx_restore_user_cmts
        hx_restore_user_numforms
        hx_restore_user_iflags
        hx_restore_user_unions
        hx_cfunc_t_build_c_tree
        hx_cfunc_t_verify
        hx_cfunc_t_print_dcl
        hx_cfunc_t_print_func
        hx_cfunc_t_get_func_type
        hx_cfunc_t_get_lvars
        hx_cfunc_t_get_stkoff_delta
        hx_cfunc_t_find_label
        hx_cfunc_t_remove_unused_labels
        hx_cfunc_t_get_user_cmt
        hx_cfunc_t_set_user_cmt
        hx_cfunc_t_get_user_iflags
        hx_cfunc_t_set_user_iflags
        hx_cfunc_t_has_orphan_cmts
        hx_cfunc_t_del_orphan_cmts
        hx_cfunc_t_get_user_union_selection
        hx_cfunc_t_set_user_union_selection
        hx_cfunc_t_save_user_labels
        hx_cfunc_t_save_user_cmts
        hx_cfunc_t_save_user_numforms
        hx_cfunc_t_save_user_iflags
        hx_cfunc_t_save_user_unions
        hx_cfunc_t_get_line_item
        hx_cfunc_t_get_warnings
        hx_cfunc_t_get_eamap
        hx_cfunc_t_get_boundaries
        hx_cfunc_t_get_pseudocode
        hx_cfunc_t_refresh_func_ctext
        hx_cfunc_t_gather_derefs
        hx_cfunc_t_find_item_coords
        hx_cfunc_t_cleanup
        hx_close_hexrays_waitbox
        hx_decompile
        hx_gen_microcode
        hx_create_cfunc
        hx_mark_cfunc_dirty
        hx_clear_cached_cfuncs
        hx_has_cached_cfunc
        hx_get_ctype_name
        hx_create_field_name
        hx_install_hexrays_callback
        hx_remove_hexrays_callback
        hx_vdui_t_set_locked
        hx_vdui_t_refresh_view
        hx_vdui_t_refresh_ctext
        hx_vdui_t_switch_to
        hx_vdui_t_get_number
        hx_vdui_t_get_current_label
        hx_vdui_t_clear
        hx_vdui_t_refresh_cpos
        hx_vdui_t_get_current_item
        hx_vdui_t_ui_rename_lvar
        hx_vdui_t_rename_lvar
        hx_vdui_t_ui_set_call_type
        hx_vdui_t_ui_set_lvar_type
        hx_vdui_t_set_lvar_type
        hx_vdui_t_set_noptr_lvar
        hx_vdui_t_ui_edit_lvar_cmt
        hx_vdui_t_set_lvar_cmt
        hx_vdui_t_ui_map_lvar
        hx_vdui_t_ui_unmap_lvar
        hx_vdui_t_map_lvar
        hx_vdui_t_set_udm_type
        hx_vdui_t_rename_udm
        hx_vdui_t_set_global_type
        hx_vdui_t_rename_global
        hx_vdui_t_rename_label
        hx_vdui_t_jump_enter
        hx_vdui_t_ctree_to_disasm
        hx_vdui_t_calc_cmt_type
        hx_vdui_t_edit_cmt
        hx_vdui_t_edit_func_cmt
        hx_vdui_t_del_orphan_cmts
        hx_vdui_t_set_num_radix
        hx_vdui_t_set_num_enum
        hx_vdui_t_set_num_stroff
        hx_vdui_t_invert_sign
        hx_vdui_t_invert_bits
        hx_vdui_t_collapse_item
        hx_vdui_t_collapse_lvars
        hx_vdui_t_split_item
        hx_select_udt_by_offset
        hx_catchexpr_t_compare
        hx_mba_t_split_block
        hx_mba_t_remove_blocks
        hx_cfunc_t_recalc_item_addresses
        hx_int64_emulator_t_mop_value
        hx_int64_emulator_t_minsn_value

    # =========================================================================
    # Template Classes
    # =========================================================================
    cdef cppclass qvector[T]:
        qvector() except +
        qvector(const qvector[T]& x) except +
        T& operator[](size_t idx)
        T& at(size_t idx)
        T& front()
        T& back()
        size_t size() const
        bint empty() const
        size_t capacity() const
        void reserve(size_t cnt) except +
        void push_back(const T& x) except +
        void pop_back() except +
        void clear() except +
        void resize(size_t newsize) except +
        void swap(qvector[T]& r) except +
        ctypedef T* iterator
        ctypedef const T* const_iterator
        iterator begin()
        iterator end()
        iterator erase(iterator it) except +
        iterator insert(iterator it, const T& x) except +
        const T* find(const T& x) const
        bint has(const T& x) const
        bint add_unique(const T& x) except +
    cdef cppclass _qstring[T]:
        _qstring() except +
        _qstring(const T* ptr) except +
        _qstring(const _qstring[T]& r) except +
        size_t length() const
        size_t size() const
        bint empty() const
        const T* c_str() const
        T& operator[](size_t idx)
        void clear() except +
        void resize(size_t newsize, T c) except +
        _qstring[T]& append(const T* ptr) except +
        _qstring[T]& append(const _qstring[T]& r) except +
        size_t find(const T* str, size_t pos) const
        size_t find(T c, size_t pos) const
        _qstring[T] substr(size_t pos, size_t len) except +
        bint operator==(const _qstring[T]& r) const
        bint operator!=(const _qstring[T]& r) const
        int compare(const _qstring[T]& r) const
    cdef cppclass qstack[T](qvector[T]):
        T& top()
        void push(const T& x) except +
        T pop() except +
    cdef cppclass qrefcnt_t[T]:
        qrefcnt_t() except +
        qrefcnt_t(T* p) except +
        qrefcnt_t(const qrefcnt_t[T]& r) except +
        T& operator*()
        bint operator==(const qrefcnt_t[T]& r) const
        bint operator!=(const qrefcnt_t[T]& r) const
        void reset()
        T* release()
        T* get()

    # =========================================================================
    # Template Instantiation Typedefs
    # =========================================================================
    ctypedef _qstring[char] qstring  # IDA string type
    ctypedef qvector[uint8_t] bytevec_t  # Vector of bytes
    ctypedef qvector[int] intvec_t  # Vector of ints
    ctypedef qvector[ea_t] eavec_t  # Vector of addresses
    ctypedef qvector[sval_t] svalvec_t  # Vector of signed values
    ctypedef qvector[uval_t] uvalvec_t  # Vector of unsigned values
    ctypedef qvector[qstring] qstrvec_t  # Vector of strings
    ctypedef qvector[bint] boolvec_t  # Vector of bools
    ctypedef qvector[sval_t] casevec_t  # Vector of case values
    ctypedef _qstring[uchar] qtype
    ctypedef _qstring[wchar16_t] qwstring
    ctypedef qvector[channel_redir_t] channel_redirs_t
    ctypedef qvector[plugin_option_t] plugin_option_vec_t
    ctypedef qvector[range_t] rangevec_base_t
    ctypedef qvector[rangeset_t] array_of_rangesets
    ctypedef qvector[rangeset_t*] rangeset_crefvec_t
    ctypedef qvector[callcnv_t] callcnvs_t
    ctypedef qvector[refinfo_desc_t] refinfo_desc_vec_t
    ctypedef qvector[compiled_binpat_t] compiled_binpat_vec_t
    ctypedef qvector[simpleline_t] strvec_t  # A collection of simple lines to populate a custom view....
    ctypedef qvector[sync_source_t] sync_source_vec_t
    ctypedef qvector[twinline_t] text_t  # A group of lines in a text window
    ctypedef qvector[twinline_t*] section_lines_refs_t  # ---------------------------------------------------------...
    ctypedef qvector[section_lines_refs_t] sections_lines_refs_t
    ctypedef qvector[line_rendering_output_entry_t*] line_rendering_output_entries_refs_t
    ctypedef qvector[cpidx_t] cpidxvec_t
    ctypedef qvector[line_section_t] line_sections_t
    ctypedef qvector[tagged_line_section_t] tagged_line_section_vec_t
    ctypedef qvector[chooser_row_info_t] chooser_row_info_vec_t
    ctypedef qvector[reg_info_t] reginfovec_t
    ctypedef qvector[reg_access_t] reg_access_vec_t
    ctypedef qvector[intvec_t] array_of_intvec_t
    ctypedef qvector[intmap_t] array_of_intmap_t
    ctypedef qvector[node_set_t] array_of_node_set_t
    ctypedef qvector[qbasic_block_t] blocks_t
    ctypedef qvector[idp_name_t] idp_names_t
    ctypedef qvector[idp_desc_t] idp_descs_t
    ctypedef qvector[snapshot_t*] snapshots_t
    ctypedef qvector[ea_name_t] ea_name_vec_t
    ctypedef qvector[type_attr_t] type_attrs_t  # this vector must be sorted by keys
    ctypedef qvector[argloc_t] arglocs_t
    ctypedef qvector[argpart_t] argpartvec_t
    ctypedef qvector[comp_t] compvec_t  # Collection of compiler descriptions
    ctypedef qvector[tinfo_t] tinfovec_t
    ctypedef qvector[simd_info_t] simd_info_vec_t
    ctypedef qvector[funcarg_t] funcargvec_t
    ctypedef qvector[edm_t] edmvec_t  # vector of enum values. for regular enums, no sorting...
    ctypedef qvector[regobj_t] regobjvec_t
    ctypedef qvector[valstr_t] valstrvec_t
    ctypedef qvector[uint32] ordvec_t  # @ }
    ctypedef qvector[minsn_t*] minsnptrs_t
    ctypedef qvector[mop_t*] mopptrs_t
    ctypedef qvector[mop_t] mopvec_t
    ctypedef qvector[uint64] uint64vec_t
    ctypedef qvector[mreg_t] mregvec_t
    ctypedef qrefcnt_t[cfunc_t] cfuncptr_t
    ctypedef qvector[lvar_saved_info_t] lvar_saved_infos_t
    ctypedef qvector[bitset_t] array_of_bitsets
    ctypedef qvector[ivlset_t] array_of_ivlsets
    ctypedef qvector[mlist_t] mlistvec_t
    ctypedef qvector[mcallarg_t] mcallargs_t
    ctypedef qvector[block_chains_t] block_chains_vec_t  # ---------------------------------------------------------...
    ctypedef qvector[hexwarn_t] hexwarns_t
    ctypedef qvector[citem_t*] citem_pointers_t  # Vector of parents
    ctypedef qvector[cinsn_t*] cinsnptrvec_t  # Vector of pointers to statements.
    ctypedef qvector[catchexpr_t] catchexprs_t
    ctypedef qvector[ccatch_t] ccatchvec_t
    ctypedef qvector[cblock_pos_t] cblock_posvec_t
    ctypedef qvector[cfuncptr_t] cfuncptrs_t
    ctypedef qstack[history_item_t] history_t  # Navigation history.
    ctypedef qvector[ui_stroff_op_t] ui_stroff_ops_t

    # =========================================================================
    # Forward Declarations
    # =========================================================================
    cdef cppclass cfgopt_handler2_t
    cdef cppclass cfgopt_handler3_t
    cdef cppclass cfgopt_handler_t
    cdef cppclass cliopt_handler_t
    cdef cppclass config_changed_cb_t
    cdef cppclass enum__t
    cdef cppclass fd_set
    cdef cppclass hook_cb_t
    cdef cppclass macro_ructor_t
    cdef cppclass parents_t
    cdef cppclass qmutex_t
    cdef cppclass qsemaphore_t
    cdef cppclass regval_getter_t
    cdef cppclass testf_t
    cdef cppclass time_t
    cdef cppclass usage_printer_t
    cdef cppclass va_list

    # =========================================================================
    # Classes
    # =========================================================================
    cdef cppclass ida_movable_type
    cdef cppclass qrefcnt_obj_t:  # ------------------------------------------------------------
        int refcnt  # counter
        qrefcnt_obj_t()  # Constructor
        void release()  # Call destructor. We use release() instead of opera
        qrefcnt_obj_t& operator=(qrefcnt_obj_t&)
        qrefcnt_obj_t& operator=(qrefcnt_obj_t&&)
    cdef cppclass reloc_info_t:  # Relocation information (relocatable objects - see ::relobj_t
        pass
    cdef cppclass relobj_t:  # Relocatable object
        ea_t base  # current base
        reloc_info_t ri  # relocation info
        relobj_t()
        bint relocate(ea_t ea, bint mf)
    cdef cppclass qlist
    cdef cppclass listnode_t:
        listnode_t* next
        listnode_t* prev
        void fix_links(int len)
    cdef cppclass const_iterator
    cdef cppclass channel_redir_t:  # Tools for command line parsing
        int fd  # channel number
        qstring file  # file name to redirect to/from. if empty, the chann
        int flags
        int start  # begin of the redirection string in the command lin
        int length  # length of the redirection string in the command li
        bint is_input() const  # @ }
        bint is_output() const
        bint is_append() const
        bint is_quoted() const
    cdef cppclass cliopt_t:
        char shortname
        char* longname
        char* help
        int nargs  # number of arguments. Can be 0, 1 or -1. If '-1', i
    cdef cppclass cliopts_t:
        qstring prog_name
        qstring epilog
        bint print_usage
        void add(cliopt_t* opts, int nopts)
        int apply(int argc, char** argv, void* ud)
        cliopt_t* find_short(char shortname) const
        cliopt_t* find_long(char* longname) const
        void usage(bint is_error) const
    cdef cppclass plugin_option_t:  # Named option, supports two kinds of options: string option: 
        qstring name
        qstring value
        char* get_value(char* default_value) const
        bint get_string(qstring* out, char* desired_name, char* default_value) const
        bint get_bool(bint* out, char* desired_name, bint default_value) const
    cdef cppclass plugin_options_t:
        plugin_option_t* find(qstring& name) const
        bint erase(char* name)
    cdef cppclass instant_dbgopts_t:  # Options for instant debugging
        qstring debmod  # name of debugger module
        qstring env  # config variables for debmod. example: DEFAULT_CPU=
        qstring host  # remote hostname (if remote debugging)
        qstring pass_  # password for the remote debugger server
        int port  # port number for the remote debugger server
        int pid  # process to attach to (-1: ask the user)
        int event_id  # event to trigger upon attaching
        bint attach  # should attach to a process?
    cdef cppclass launch_process_params_t:  # Information for launching a process with IDA API Note: all s
        int cb  # size of this structure
        int flags
        char* path  # file to run
        char* args  # command line arguments
        int in_handle  # handle for stdin or -1
        int out_handle  # handle for stdout or -1
        int err_handle  # handle for stderr or -1
        char* env  # zero separated environment variables that will be 
        char* startdir  # current directory for the new process
        void* info  # os specific info (on windows it points to PROCESS_
    cdef cppclass qmutex_locker_t:  # Mutex locker object. Will lock a given mutex upon creation a
        pass
    cdef cppclass _opaque_pthread_attr_t:
        long __sig
    cdef cppclass _opaque_pthread_cond_t:
        long __sig
        _opaque_pthread_cond_t(_opaque_pthread_cond_t&)
        _opaque_pthread_cond_t(_opaque_pthread_cond_t&&)
        _opaque_pthread_cond_t& operator=(_opaque_pthread_cond_t&)
        _opaque_pthread_cond_t& operator=(_opaque_pthread_cond_t&&)
    cdef cppclass _opaque_pthread_condattr_t:
        long __sig
    cdef cppclass _opaque_pthread_mutex_t:
        long __sig
        _opaque_pthread_mutex_t(_opaque_pthread_mutex_t&)
        _opaque_pthread_mutex_t(_opaque_pthread_mutex_t&&)
        _opaque_pthread_mutex_t& operator=(_opaque_pthread_mutex_t&)
        _opaque_pthread_mutex_t& operator=(_opaque_pthread_mutex_t&&)
    cdef cppclass _opaque_pthread_mutexattr_t:
        long __sig
        _opaque_pthread_mutexattr_t()
        _opaque_pthread_mutexattr_t(_opaque_pthread_mutexattr_t&)
        _opaque_pthread_mutexattr_t(_opaque_pthread_mutexattr_t&&)
    cdef cppclass _opaque_pthread_once_t:
        long __sig
    cdef cppclass _opaque_pthread_rwlock_t:
        long __sig
    cdef cppclass _opaque_pthread_rwlockattr_t:
        long __sig
    cdef cppclass _opaque_pthread_t:
        long __sig
    cdef cppclass range_t:  # ------------------------------------------------------------
        ea_t start_ea  # start_ea included
        ea_t end_ea  # end_ea excluded
        range_t(ea_t ea1, ea_t ea2)
        bint operator==(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator!=(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator<(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator>(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator<=(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator>=(range_t& r) const  # Compare two range_t instances, based on the start_
        int compare(range_t& r) const  # Compare two range_t instances, based on the start_
        bint contains(ea_t ea) const  # Is 'ea' in the address range?
        bint contains(range_t& r) const  # Is every ea in 'r' also in this range_t?
        bint overlaps(range_t& r) const  # Is there an ea in 'r' that is also in this range_t
        void clear()  # Set #start_ea, #end_ea to 0
        bint empty() const  # Is the size of the range_t < = 0?
        asize_t size() const  # Get #end_ea - #start_ea
        void intersect(range_t& r)  # Assign the range_t to the intersection between the
        void extend(ea_t ea)  # Ensure that the range_t includes 'ea'
        size_t print(char* buf, size_t bufsize) const  # Print the range_t. 
        range_t(range_t&)
        range_t(range_t&&)
        range_t& operator=(range_t&)
        range_t& operator=(range_t&&)
    cdef cppclass rangevec_t:
        rangevec_t()
        rangevec_t(rangevec_t&)
        rangevec_t(rangevec_t&&)
    cdef cppclass rangeset_t:  # An ordered set of non-overlapping address ranges
        rangeset_t()  # Constructor
        rangeset_t(range_t& range)  # Constructor - Initialize set with 'range'
        rangeset_t(rangeset_t& ivs)  # Constructor - Initialize set with 'ivs'
        rangeset_t& operator=(rangeset_t& ivs)
        void swap(rangeset_t& r)  # Set this = 'r' and 'r' = this. See qvector::swap()
        bint add(range_t& range)  # Add an address range to the set. If 'range' inters
        bint add(ea_t start, ea_t _end)  # Create a new range_t from 'start' and 'end' and ad
        bint add(rangeset_t& aset)  # Add each element of 'aset' to the set. 
        bint sub(range_t& range)  # Subtract an address range from the set. All subset
        bint sub(ea_t ea)  # Subtract an ea (an range of size 1) from the set. 
        bint sub(rangeset_t& aset)  # Subtract each range in 'aset' from the set 
        bint has_common(range_t& range) const  # Is there an ea in 'range' that is also in the rang
        bint includes(range_t& range) const  # Is every ea in 'range' contained in the rangeset?
        size_t print(char* buf, size_t bufsize) const  # Print each range_t in the rangeset
        asize_t count() const  # Size in bytes
        range_t& getrange(int idx) const  # Get the range_t at index 'idx'
        range_t& lastrange() const  # Get the last range_t in the set
        size_t nranges() const  # Get the number of range_t elements in the set
        bint empty() const  # Does the set have zero elements
        void clear()  # Delete all elements from the set. See qvector::cle
        bint has_common(rangeset_t& aset) const  # Does any element of 'aset' overlap with an element
        bint contains(ea_t ea) const  # Does an element of the rangeset contain 'ea'? See 
        bint contains(rangeset_t& aset) const  # Is every element in 'aset' contained in an element
        bint intersect(rangeset_t& aset)  # Set the rangeset to its intersection with 'aset'. 
        bint is_subset_of(rangeset_t& aset) const  # Is every element in the rangeset contained in an e
        bint is_equal(rangeset_t& aset) const  # Do this rangeset and 'aset' have identical element
        bint operator==(rangeset_t& aset) const
        bint operator!=(rangeset_t& aset) const
        const_iterator begin() const
        const_iterator end() const
        iterator begin()
        iterator end()
        const_iterator lower_bound(ea_t ea) const  # Get the first range that contains at least one ea_
        const_iterator upper_bound(ea_t ea) const  # Get the first range such that every ea_t value in 
        range_t* find_range(ea_t ea) const  # Get the element from the set that contains 'ea'. 
        range_t* cached_range() const  # When searching the rangeset, we keep a cached elem
        ea_t next_addr(ea_t ea) const  # Get the smallest ea_t value greater than 'ea' cont
        ea_t prev_addr(ea_t ea) const  # Get the largest ea_t value less than 'ea' containe
        ea_t next_range(ea_t ea) const  # Get the smallest ea_t value greater than 'ea' that
        ea_t prev_range(ea_t ea) const  # Get the largest ea_t value less than 'ea' that is 
        int move_chunk(ea_t from_, ea_t to, asize_t size)  # Subtract the address range (from, from+size) and a
        int check_move_args(ea_t from_, ea_t to, asize_t size)  # Check if the intended move_chunk() arguments are c
        rangevec_t& as_rangevec() const  # Return underlying rangevec_t object
    cdef cppclass range64_t:  # ------------------------------------------------------------
        uint64 start
        uint64 end
        range64_t(uint64 _start, uint64 _end)
        bint operator==(range64_t& r) const
        bint operator!=(range64_t& r) const
        bint operator<(range64_t& r) const
        bint operator>(range64_t& r) const
        bint operator<=(range64_t& r) const
        bint operator>=(range64_t& r) const
        int compare(range64_t& r) const
        bint contains(uint64 x) const
        bint contains(range64_t& r) const
        bint overlaps(range64_t& r) const
        void clear()
        bint empty() const
        uint64 size() const
        void intersect(range64_t& r)
        void extend(uint64 ea)
        range64_t(range64_t&)
        range64_t(range64_t&&)
    cdef cppclass range64vec_t:
        range64_t* find_range(uint64 off) const
    cdef cppclass compiler_info_t:  # Information about the target compiler
        comp_t id  # compiler id (see
        cm_t cm  # memory model and calling convention (see see also 
        uchar size_i  # sizeof(int)
        uchar size_b  # sizeof(bool)
        uchar size_e  # sizeof(enum)
        uchar defalign  # default alignment for structures
        uchar size_s  # short
        uchar size_l  # long
        uchar size_ll  # longlong
        uchar size_ldbl  # longdouble (if different from
        callcnv_t _new_callcnv  # do not access directly; use get_cc/set_cc
        callcnv_t get_cc() const
        void set_cc(callcnv_t cc)
        compiler_info_t()
        compiler_info_t(compiler_info_t&)
        compiler_info_t(compiler_info_t&&)
    cdef cppclass idainfo:
        char zero  # this field is not present in the database
        ushort version  # Version of database
        ushort s_genflags
        uint32 lflags
        uint32 database_change_count  # incremented after each byte and regular segment mo
        ushort filetype  # The input file type
        ushort ostype  # OS type the program is for bit definitions in libf
        ushort apptype  # Application type bit definitions in libfuncs.hpp
        uchar asmtype  # target assembler number
        uchar specsegs  # What format do special segments use? 0-unspecified
        uint32 af
        uint32 af2
        uval_t baseaddr  # base address of the program (paragraphs)
        sel_t start_ss  # selector of the initial stack segment
        sel_t start_cs  # selector of the segment with the main entry point
        ea_t start_ip  # IP register value at the start of program executio
        ea_t start_ea  # Linear address of program entry point
        ea_t start_sp  # SP register value at the start of program executio
        ea_t main  # address of main()
        ea_t min_ea  # current limits of program
        ea_t max_ea  # maxEA is excluded
        ea_t omin_ea  # original minEA (is set after loading the input fil
        ea_t omax_ea  # original maxEA (is set after loading the input fil
        ea_t lowoff  # Low  limit for offsets (used in calculation of 'vo
        ea_t highoff  # High limit for offsets (used in calculation of 'vo
        uval_t maxref  # Max tail for references
        range_t privrange  # Range of addresses reserved for internal use. Init
        sval_t netdelta  # Delta value to be added to all addresses for mappi
        uchar xrefnum  # Number of references to generate in the disassembl
        uchar type_xrefnum  # Number of references to generate in the struct & e
        uchar refcmtnum  # Number of comment lines to generate for refs to st
        uchar s_xrefflag
        ushort max_autoname_len  # max autogenerated name length (without zero byte)
        char nametype
        uint32 short_demnames  # short form of demangled names
        uint32 long_demnames  # long form of demangled names see demangle.h for de
        uchar demnames
        uchar listnames
        uchar indent  # Indentation for instructions
        uchar cmt_indent  # Indentation for comments
        ushort margin  # max length of data lines
        ushort lenxref  # max length of line with xrefs
        uint32 outflags
        uchar s_cmtflg
        uchar s_limiter
        short bin_prefix_size  # Number of instruction bytes (opcodes) to show in l
        uchar s_prefflag
        uchar strlit_flags
        uchar strlit_break  # string literal line break symbol
        char strlit_zeroes  # leading zeroes
        int32 strtype  # current ascii string type see nalt.hpp for string 
        uval_t strlit_sernum  # serial number
        uval_t datatypes  # data types allowed in data carousel
        compiler_info_t cc  # Target compiler
        uint32 abibits  # ABI features. Depends on info returned by get_abi_
        uint32 appcall_options  # appcall options, see idd.hpp
        uint32 padding
    cdef cppclass ea_helper_t:  # ------------------------------------------------------------
        uval_t mask32
        uval_t mask64
        uval_t mask
        int ea_size
        bint enabled  # can be disabled for old databases
        void setup(bint is_64bit)
        void disable()
        bint is_enabled() const
        sval_t ea2sval(uval_t v) const
        uval_t trunc_uval(uval_t v) const
        ea_t uval2ea(uval_t v) const
        bint fits_ea_space(ea_t ea) const
        bint fits_ea_space(range_t& r) const
        ea_t trunc_ea(ea_t ea) const
        ea_t ea_space_end() const
        ea_t to_ea(sel_t cs, uval_t ip) const
        ea_t fix_ea_tid(ea_t ea) const
        bint is_ea_add_ok(uval_t x, uval_t y) const
        sval_t sval_max() const
        sval_t sval_min() const
        bint like_badaddr(ea_t ea) const
        ea_t align_ea(ea_t ea, int size) const
        bint advance_ea(ea_t* ea, asize_t n) const
    cdef cppclass post_event_visitor_t:  # Implements action to take when the event was processed by th
        post_event_visitor_t& operator=(post_event_visitor_t&)
    cdef cppclass dbctx_t
    cdef cppclass idbattr_valmap_t:  # ------------------------------------------------------------
        uint64 value
        char* valname
    cdef cppclass idbattr_info_t:  # ------------------------------------------------------------
        char* name  # human-readable name. if null, then the field will 
        uintptr_t offset  # field position: offset within a structure (IDI_STR
        size_t width  # field width in bytes
        uint64 bitmask  # mask for bitfields (0-not bitfield)
        uchar tag  # tag of node value (if IDI_NODEVAL is set)
        idbattr_valmap_t* vmap  # array value=>name (terminated by empty element)
        char* individual_node  # individual node name (nullptr - use default)
        uint idi_flags
        uint32 maxsize  # max bytes reserved for storage in netnode
        bint is_node_altval() const
        bint is_node_supval() const
        bint is_node_valobj() const
        bint is_node_blob() const
        bint is_node_var() const
        bint is_struc_field() const
        bint is_cstr() const
        bint is_qstring() const
        bint is_bytearray() const
        bint is_buf_var() const
        bint is_decimal() const
        bint is_hexadecimal() const
        bint is_readonly_var() const
        bint is_incremented() const
        bint is_val_mapped() const
        bint is_hash() const
        bint use_hlpstruc() const
        bint is_bitmap() const
        bint is_onoff() const
        bint is_scalar_var() const
        bint is_bitfield() const
        bint is_boolean() const
        bint has_individual_node() const
        char* str_true() const
        char* str_false() const
        size_t ridx() const
        char* hashname() const
        bint operator<(idbattr_info_t& r) const
    cdef cppclass fpvalue_t:  # ------------------------------------------------------------
        void clear()
        bint operator==(fpvalue_t& r) const
        bint operator!=(fpvalue_t& r) const
        bint operator<(fpvalue_t& r) const
        bint operator>(fpvalue_t& r) const
        bint operator<=(fpvalue_t& r) const
        bint operator>=(fpvalue_t& r) const
        int compare(fpvalue_t& r) const
        fpvalue_error_t from_half(uint16 fpval)  # Convert to the processor-independent representatio
        fpvalue_error_t from_float(float fpval)
        fpvalue_error_t from_double(double fpval)
        fpvalue_error_t to_half(uint16* fpval) const  # Convert from the processor-independent representat
        fpvalue_error_t to_float(float* fpval) const
        fpvalue_error_t to_double(double* fpval) const
        fpvalue_error_t from_10bytes(void* fpval)  # Conversions for 10-byte floating point values.
        fpvalue_error_t to_10bytes(void* fpval) const
        fpvalue_error_t from_12bytes(void* fpval)  # Conversions for 12-byte floating point values.
        fpvalue_error_t to_12bytes(void* fpval) const
        fpvalue_error_t from_str(char** p_str)  # Convert string to IEEE. 
        void to_str(char* buf, size_t bufsize, uint mode) const  # Convert IEEE to string. 
        void from_sval(sval_t x)  # Convert integer to IEEE
        void from_int64(int64 x)
        void from_uint64(uint64 x)
        fpvalue_error_t to_sval(sval_t* out, bint round) const  # Convert IEEE to integer (+-0.5 if round)
        fpvalue_error_t to_int64(int64* out, bint round) const
        fpvalue_error_t to_uint64(uint64* out, bint round) const
        fpvalue_error_t fadd(fpvalue_t& y)  # Arithmetic operations
        fpvalue_error_t fsub(fpvalue_t& y)
        fpvalue_error_t fmul(fpvalue_t& y)
        fpvalue_error_t fdiv(fpvalue_t& y)
        fpvalue_error_t mul_pow2(int32 power_of_2)  # Multiply by a power of 2.
        void eabs()  # Calculate absolute value.
        bint is_negative() const  # Is negative value?
        void negate()  # Negate.
        fpvalue_kind_t get_kind() const  # Get value kind.
    cdef cppclass exception_ptr:
        exception_ptr()
        exception_ptr(nullptr_t)
        exception_ptr(exception_ptr&)
        exception_ptr& operator=(exception_ptr&)
    cdef cppclass logic_error:
        logic_error(int&)
        logic_error(char*)
        logic_error(logic_error&)
        logic_error& operator=(logic_error&)
        char* what() const
    cdef cppclass runtime_error:
        runtime_error(int&)
        runtime_error(char*)
        runtime_error(runtime_error&)
        runtime_error& operator=(runtime_error&)
        char* what() const
    cdef cppclass domain_error:
        domain_error(int& __s)
        domain_error(char* __s)
        domain_error(domain_error&)
        domain_error& operator=(domain_error&)
    cdef cppclass invalid_argument:
        invalid_argument(int& __s)
        invalid_argument(char* __s)
        invalid_argument(invalid_argument&)
        invalid_argument& operator=(invalid_argument&)
    cdef cppclass length_error:
        length_error(int& __s)
        length_error(char* __s)
        length_error(length_error&)
        length_error& operator=(length_error&)
    cdef cppclass out_of_range:
        out_of_range(int& __s)
        out_of_range(char* __s)
        out_of_range(out_of_range&)
        out_of_range& operator=(out_of_range&)
    cdef cppclass range_error:
        range_error(int& __s)
        range_error(char* __s)
        range_error(range_error&)
        range_error& operator=(range_error&)
    cdef cppclass overflow_error:
        overflow_error(int& __s)
        overflow_error(char* __s)
        overflow_error(overflow_error&)
        overflow_error& operator=(overflow_error&)
    cdef cppclass underflow_error:
        underflow_error(int& __s)
        underflow_error(char* __s)
        underflow_error(underflow_error&)
        underflow_error& operator=(underflow_error&)
    cdef cppclass timespec:
        long tv_nsec
    cdef cppclass altadjust_visitor_t:  # visitor to be used by altadjust2 to skip the adjustment of s
        bint should_skip(nodeidx_t ea)
        altadjust_visitor_t& operator=(altadjust_visitor_t&)
        altadjust_visitor_t& operator=(altadjust_visitor_t&&)
    cdef cppclass netnode:  # Definition of the IDA database node. Note that the size of t
        netnode(nodeidx_t num)  # Constructor to create a netnode to access informat
        netnode(char* _name, size_t namlen, bint do_create)  # Construct an instance of netnode class to access t
        bint exist(char* _name)  # Does the netnode with the specified name exist?
        bint create(char* _name, size_t namlen)  # Create a named netnode. 
        bint create()  # Create unnamed netnode. 
        void kill()  # Delete a netnode with all information attached to 
        ssize_t get_name(qstring* buf) const  # Get the netnode name. 
        bint rename(char* newname, size_t namlen)  # Rename a netnode. 
        ssize_t valobj(void* buf, size_t bufsize) const  # Get value of netnode. Netnode values are arbitrary
        ssize_t valstr(qstring* buf) const  # Get string value of netnode. See explanations for 
        ssize_t valstr(char* buf, size_t bufsize) const
        bint set(void* value, size_t length)  # Set value of netnode. 
        bint delvalue()  # Delete value of netnode. 
        bint set_long(nodeidx_t x)  # Value of netnode as a long number:
        bint value_exists() const
        nodeidx_t long_value() const
        nodeidx_t altval(nodeidx_t alt, uchar tag) const  # Get altval element of the specified array. 
        nodeidx_t altval_ea(ea_t ea, uchar tag) const
        bint altset(nodeidx_t alt, nodeidx_t value, uchar tag)  # Set value of altval array. 
        bint altset_ea(ea_t ea, nodeidx_t value, uchar tag)
        bint altdel(nodeidx_t alt, uchar tag)  # Delete element of altval array. 
        bint altdel_ea(ea_t ea, uchar tag)
        bint easet(ea_t ea, ea_t addr, uchar tag)  # Store/retrieve/delete an address value in the netn
        ea_t eaget(ea_t ea, uchar tag) const
        bint eadel(ea_t ea, uchar tag)
        bint easet_idx(nodeidx_t idx, ea_t addr, uchar tag)
        ea_t eaget_idx(nodeidx_t idx, uchar tag)
        bint easet_idx8(uchar idx, ea_t addr, uchar tag)
        ea_t eaget_idx8(uchar idx, uchar tag) const
        bint eadel_idx8(uchar idx, uchar tag)
        nodeidx_t altfirst(uchar tag) const  # Get first existing element of altval array. 
        nodeidx_t altnext(nodeidx_t cur, uchar tag) const  # Get next existing element of altval array. 
        nodeidx_t altlast(uchar tag) const  # Get last element of altval array. 
        nodeidx_t altprev(nodeidx_t cur, uchar tag) const  # Get previous existing element of altval array. 
        size_t altshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the altval array elements. Moves the array e
        void altadjust2(nodeidx_t from_, nodeidx_t to, nodeidx_t size, altadjust_visitor_t& av)
        uchar charval(nodeidx_t alt, uchar tag) const  #  The following functions behave in the same manner
        bint charset(nodeidx_t alt, uchar val, uchar tag)
        bint chardel(nodeidx_t alt, uchar tag)
        uchar charval_ea(ea_t ea, uchar tag) const
        bint charset_ea(ea_t ea, uchar val, uchar tag)
        bint chardel_ea(ea_t ea, uchar tag)
        nodeidx_t charfirst(uchar tag) const
        nodeidx_t charnext(nodeidx_t cur, uchar tag) const
        nodeidx_t charlast(uchar tag) const
        nodeidx_t charprev(nodeidx_t cur, uchar tag) const
        size_t charshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)
        nodeidx_t altval_idx8(uchar alt, uchar tag) const  #  Another set of functions to work with altvals. Th
        bint altset_idx8(uchar alt, nodeidx_t val, uchar tag)
        bint altdel_idx8(uchar alt, uchar tag)
        nodeidx_t altfirst_idx8(uchar tag) const
        nodeidx_t altnext_idx8(uchar cur, uchar tag) const
        nodeidx_t altlast_idx8(uchar tag) const
        nodeidx_t altprev_idx8(uchar cur, uchar tag) const
        uchar charval_idx8(uchar alt, uchar tag) const  #  Another set of functions to work with altvals. - 
        bint charset_idx8(uchar alt, uchar val, uchar tag)
        bint chardel_idx8(uchar alt, uchar tag)
        nodeidx_t charfirst_idx8(uchar tag) const
        nodeidx_t charnext_idx8(uchar cur, uchar tag) const
        nodeidx_t charlast_idx8(uchar tag) const
        nodeidx_t charprev_idx8(uchar cur, uchar tag) const
        bint altdel()  # Delete all elements of altval array. This function
        bint altdel_all(uchar tag)  # Delete all elements of the specified altval array.
        ssize_t supval(nodeidx_t alt, void* buf, size_t bufsize, uchar tag) const  # Get value of the specified supval array element. N
        ssize_t supval_ea(ea_t ea, void* buf, size_t bufsize, uchar tag) const
        ssize_t supstr(qstring* buf, nodeidx_t alt, uchar tag) const  # Get string value of the specified supval array ele
        ssize_t supstr_ea(qstring* buf, ea_t ea, uchar tag) const
        ssize_t supstr(nodeidx_t alt, char* buf, size_t bufsize, uchar tag) const
        ssize_t supstr_ea(ea_t ea, char* buf, size_t bufsize, uchar tag) const
        bint supset(nodeidx_t alt, void* value, size_t length, uchar tag)  # Set value of supval array element. 
        bint supset_ea(ea_t ea, void* value, size_t length, uchar tag)
        bint supdel(nodeidx_t alt, uchar tag)  # Delete supval element. 
        bint supdel_ea(ea_t ea, uchar tag)
        nodeidx_t lower_bound(nodeidx_t cur, uchar tag) const  # Get lower bound of existing elements of supval arr
        nodeidx_t lower_bound_ea(ea_t ea, uchar tag) const
        nodeidx_t supfirst(uchar tag) const  # Get first existing element of supval array. 
        nodeidx_t supnext(nodeidx_t cur, uchar tag) const  # Get next existing element of supval array. 
        nodeidx_t suplast(uchar tag) const  # Get last existing element of supval array. 
        nodeidx_t supprev(nodeidx_t cur, uchar tag) const  # Get previous existing element of supval array. 
        size_t supshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the supval array elements. Moves the array e
        ssize_t supval_idx8(uchar alt, void* buf, size_t bufsize, uchar tag) const  #  The following functions behave in the same manner
        ssize_t supstr_idx8(uchar alt, char* buf, size_t bufsize, uchar tag) const
        ssize_t supstr_idx8(qstring* buf, uchar alt, uchar tag) const
        bint supset_idx8(uchar alt, void* value, size_t length, uchar tag)
        bint supdel_idx8(uchar alt, uchar tag)
        nodeidx_t lower_bound_idx8(uchar alt, uchar tag) const
        nodeidx_t supfirst_idx8(uchar tag) const
        nodeidx_t supnext_idx8(uchar alt, uchar tag) const
        nodeidx_t suplast_idx8(uchar tag) const
        nodeidx_t supprev_idx8(uchar alt, uchar tag) const
        bint supdel()  # Delete all elements of supval array. This function
        bint supdel_all(uchar tag)  # Delete all elements of the specified supval array.
        int supdel_range(nodeidx_t idx1, nodeidx_t idx2, uchar tag)  # Delete range of elements in the specified supval a
        int supdel_range_idx8(uchar idx1, uchar idx2, uchar tag)  # Same as above, but accepts 8-bit indexes
        ssize_t hashval(char* idx, void* buf, size_t bufsize, uchar tag) const  # Get value of the specified hash element. 
        ssize_t hashstr(qstring* buf, char* idx, uchar tag) const  # Similar to supstr(), but accepts a hash index
        ssize_t hashstr(char* idx, char* buf, size_t bufsize, uchar tag) const
        nodeidx_t hashval_long(char* idx, uchar tag) const  # Get value of the specified hash element. 
        bint hashset(char* idx, void* value, size_t length, uchar tag)  # Set value of hash element. 
        bint hashset(char* idx, nodeidx_t value, uchar tag)  # Set value of hash element to long value. 
        bint hashdel(char* idx, uchar tag)  # Delete hash element. 
        ssize_t hashfirst(qstring* buf, uchar tag) const  # Get first existing element of hash. 
        ssize_t hashfirst(char* buf, size_t bufsize, uchar tag) const
        ssize_t hashnext(qstring* buf, char* idx, uchar tag) const  # Get next existing element of hash. 
        ssize_t hashnext(char* idx, char* buf, size_t bufsize, uchar tag) const
        ssize_t hashlast(qstring* buf, uchar tag) const  # Get last existing element of hash. 
        ssize_t hashlast(char* buf, size_t bufsize, uchar tag) const
        ssize_t hashprev(qstring* buf, char* idx, uchar tag) const  # Get previous existing element of supval array. 
        ssize_t hashprev(char* idx, char* buf, size_t bufsize, uchar tag) const
        bint hashdel_all(uchar tag)  # Delete all elements of hash. This function deletes
        size_t blobsize(nodeidx_t _start, uchar tag)  # Get size of blob. 
        size_t blobsize_ea(ea_t ea, uchar tag)
        void* getblob(void* buf, size_t* bufsize, nodeidx_t _start, uchar tag)  # Get blob from a netnode. 
        void* getblob_ea(void* buf, size_t* bufsize, ea_t ea, uchar tag)
        ssize_t getblob(qstring* buf, nodeidx_t _start, uchar tag)  # Get blob from a netnode into a qstring* and make s
        bint setblob(void* buf, size_t size, nodeidx_t _start, uchar tag)  # Store a blob in a netnode. 
        bint setblob_ea(void* buf, size_t size, ea_t ea, uchar tag)
        int delblob(nodeidx_t _start, uchar tag)  # Delete a blob. 
        int delblob_ea(ea_t ea, uchar tag)
        size_t blobshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the blob array elements. Moves the array ele
        bint start()  # Get first netnode in the graph. Sets netnodenumber
        bint end()  # Get last netnode in the graph. Sets netnodenumber 
        bint next()  # Get next netnode in the graph. Sets netnodenumber 
        bint prev()  # Get prev netnode in the graph. Sets netnodenumber 
        size_t copyto(netnode destnode, nodeidx_t count)  # --------------------------------------------------
        size_t moveto(netnode destnode, nodeidx_t count)
        bint operator==(netnode& n) const  # --------------------------------------------------
        bint operator!=(netnode& n) const
        bint operator==(nodeidx_t x) const
        bint operator!=(nodeidx_t x) const
        bint inited()  # @ }
        bint is_available()
    cdef cppclass xrefpos_t:  #  @ { Position of cursor in the window with cross-references 
        ea_t ea
        uchar type  # the type of xref (::cref_t & ::dref_t)
        xrefpos_t(ea_t ea_, uchar type_)
        bint is_valid() const
    cdef cppclass array_parameters_t:  # ------------------------------------------------------------
        int32 flags
        int32 lineitems  # number of items on a line
        int32 alignment  # -1 - don't align. 0  - align automatically. else i
        array_parameters_t(int32 _f, int32 _l, int32 _a)
        bint is_default() const
        array_parameters_t& operator=(array_parameters_t&)
        array_parameters_t& operator=(array_parameters_t&&)
    cdef cppclass switch_info_t:  # ------------------------------------------------------------
        uint32 flags
        ushort ncases  # number of cases (excluding default)
        ea_t jumps  # jump table start address
        ea_t values  # values table address (if #SWI_SPARSE is set)
        uval_t lowcase  # the lowest value in cases
        ea_t defjump  # default jump address (#BADADDR if no default case)
        ea_t startea  # start of the switch idiom
        int jcases  # number of entries in the jump table (SWI_INDIRECT)
        sval_t ind_lowcase
        ea_t elbase  # element base
        int regnum  # the switch expression as a value of the REGNUM reg
        op_dtype_t regdtype  # size of the switch expression register as dtype
        uval_t custom  # information for custom tables (filled and used by 
        int version
        ea_t expr_ea  # the address before that the switch expression is i
        eavec_t marks  # the insns marked as IM_SWITCH. They are used to de
        int get_shift() const  # See #SWI_SHIFT_MASK. possible answers: 0..3.
        void set_shift(int shift)  # See #SWI_SHIFT_MASK
        int get_jtable_element_size() const
        void set_jtable_element_size(int size)
        int get_vtable_element_size() const
        void set_vtable_element_size(int size)
        bint has_default() const
        bint has_elbase() const
        bint is_sparse() const
        bint is_custom() const
        bint is_indirect() const
        bint is_subtract() const
        bint is_nolowcase() const
        bint use_std_table() const
        bint is_user_defined() const
        sval_t get_lowcase() const
        int get_jtable_size() const
        void set_jtable_size(int size)
        void set_elbase(ea_t base)
        void set_expr(int r, op_dtype_t dt)
        bint get_jrange_vrange(range_t* jrange, range_t* vrange) const  # get separate parts of the switch
        int get_version() const
        switch_info_t()
        void clear()
        switch_info_t(switch_info_t&)
        switch_info_t(switch_info_t&&)
        switch_info_t& operator=(switch_info_t&)
        switch_info_t& operator=(switch_info_t&&)
    cdef cppclass custom_data_type_ids_t:  #  @ { Information about custom data types
        int16 dtid  # data type id
        void set(tid_t tid)
        tid_t get_dtid() const
        custom_data_type_ids_t()
        custom_data_type_ids_t(custom_data_type_ids_t&)
        custom_data_type_ids_t(custom_data_type_ids_t&&)
    cdef cppclass refinfo_t:  # Information about a reference
        ea_t target  # reference target (#BADADDR-none)
        ea_t base  # base of reference (may be BADADDR)
        adiff_t tdelta  # offset from the target
        uint32 flags
        reftype_t type() const  # @ }
        bint is_target_optional() const
        bint no_base_xref() const
        bint is_pastend() const
        bint is_rvaoff() const
        bint is_custom() const
        bint is_subtract() const
        bint is_signed() const
        bint is_no_zeros() const
        bint is_no_ones() const
        bint is_selfref() const
        void set_type(reftype_t rt)  # RT can include REFINFO_CUSTOM bit
        void init(uint32 reft_and_flags, ea_t _base, ea_t _target, adiff_t _tdelta)  # init the structure with some default values reft_a
        refinfo_t()
        refinfo_t(refinfo_t&)
        refinfo_t(refinfo_t&&)
        refinfo_t& operator=(refinfo_t&)
        refinfo_t& operator=(refinfo_t&&)
    cdef cppclass custom_refinfo_handler_t:  # Manage a custom refinfo type Custom refinfos are usually use
        int32 cbsize  # size of this structure
        char* name  # Format name, must be unique
        char* desc  # Refinfo description to use in Ctrl-R dialog
        int props  # properties (currently 0)
    cdef cppclass refinfo_desc_t:  # Get descriptions of all standard and custom refinfo types.
        uint32 type  # Refinfo type, see Custom refinfo has REFINFO_CUSTO
        char* name  # Refinfo name
        char* desc  # Refinfo description to use in Ctrl-R dialog
    cdef cppclass strpath_t:  # Information for structure offsets. ids[0] contains the id of
        int len
        adiff_t delta
        strpath_t()
        strpath_t(strpath_t&)
        strpath_t(strpath_t&&)
    cdef cppclass enum_const_t:  # See opinfo_t::ec
        tid_t tid
        uchar serial
        enum_const_t()
        enum_const_t(enum_const_t&)
        enum_const_t(enum_const_t&&)
    cdef cppclass opinfo_t:  # Additional information about an operand type
        refinfo_t ri  # for offset members
        tid_t tid  # for struct, etc. members
        strpath_t path  # for stroff
        int32 strtype  # for strings (
        enum_const_t ec  # for enums
        custom_data_type_ids_t cd  # for custom data
        opinfo_t()
        opinfo_t(opinfo_t&)
        opinfo_t(opinfo_t&&)
    cdef cppclass printop_t:  # ------------------------------------------------------------
        uint32 unused  # not used anymore, use flags64 instead (kept for ba
        opinfo_t ti  # new operand type
        uchar features  # features this instance holds
        int suspop  # out: will be set by print_operand()
        aflags_t aflags  # additional aflags
        flags64_t flags  # new operand representation flags
        printop_t()
        bint is_ti_initialized() const
        void set_ti_initialized(bint v)
        bint is_aflags_initialized() const
        void set_aflags_initialized(bint v)
        bint is_f64() const
        opinfo_t* get_ti() const
    cdef cppclass segment_t:  # Describes a program segment
        uval_t name  # use get/set_segm_name() functions
        uval_t sclass  # use get/set_segm_class() functions
        uval_t orgbase  # this field is IDP dependent. you may keep your inf
        uchar align
        uchar comb
        uchar perm  #  (0 means no information)
        uchar bitness  # Number of bits in the segment addressing - 0: 16 b
        ushort flags
        sel_t sel  # segment selector - should be unique. You can't cha
        uchar type  # segment type (see The kernel treats different segm
        bgcolor_t color  # the segment color
        bint is_16bit() const  # Is a 16-bit segment?
        bint is_32bit() const  # Is a 32-bit segment?
        bint is_64bit() const  # Is a 64-bit segment?
        int abits() const  # Get number of address bits
        int abytes() const  # Get number of address bytes
        bint comorg() const  #  See #SFL_COMORG @ {
        void set_comorg()
        void clr_comorg()
        bint ob_ok() const  #  See #SFL_OBOK @ {
        void set_ob_ok()
        void clr_ob_ok()
        bint is_visible_segm() const  #  See #SFL_HIDDEN @ {
        void set_visible_segm(bint visible)
        bint is_debugger_segm() const  #  See #SFL_DEBUG @ {
        void set_debugger_segm(bint debseg)  # use ::change_segment_status() to change the segmen
        bint is_loader_segm() const  #  See #SFL_LOADER @ {
        void set_loader_segm(bint ldrseg)
        bint is_hidden_segtype() const  #  See #SFL_HIDETYPE @ {
        void set_hidden_segtype(bint hide)
        bint is_header_segm() const  #  See #SFL_HEADER @ {
        void set_header_segm(bint on)
        bint is_ephemeral_segm() const  # Ephemeral segments are not analyzed automatically 
        bint update()  # Update segment information. You must call this fun
        segment_t()  # Constructor
    cdef cppclass lock_segment:  # Helper class to lock a segment pointer so it stays valid
        lock_segment(segment_t* _segm)
    cdef cppclass user_defined_prefix_t:  # Class to generate user-defined prefixes in the disassembly l
        user_defined_prefix_t(size_t prefix_len, void* owner)  # Creating a user-defined prefix object installs it.
        void get_user_defined_prefix(qstring* vout, ea_t ea, insn_t& insn, int lnnum, int indent, char* line)  # Get a user-defined prefix. This callback must be o
        user_defined_prefix_t& operator=(user_defined_prefix_t&)
    cdef cppclass encoder_t:  # A helper class, to encode from UTF-8, -> into the target enc
        bint get_bom(bytevec_t* out) const
        bint encode(qstring* s) const  # returns true if conversion was entirely successful
        bint print(FILE* out, char* format) const  # encode()s the UTF-8 string composed by format + ar
        bint requires_binary_mode() const  # should a file be opened as binary, or should it ra
        encoder_t& operator=(encoder_t&)
    cdef cppclass octet_generator_t:  # Get 8 bits of the program at 'ea'. The main usage of this fu
        uint64 value
        ea_t ea
        int avail_bits
        bint high_byte_first
        octet_generator_t(ea_t _ea)
        void invert_byte_order()
    cdef cppclass data_type_t:  # Information about a data type
        int cbsize  # size of this structure
        void* ud  # user-defined data to be passed to callbacks
        int props  # properties
        char* name  # name of the data type. must be unique
        char* menu_name  # Visible data type name to use in menus if nullptr,
        char* hotkey  # Hotkey for the corresponding menu item if nullptr,
        char* asm_keyword  # keyword to use for this type in the assembly if nu
        asize_t value_size  # size of the value in bytes
        bint is_present_in_menus() const  # Should this type be shown in UI menus 
    cdef cppclass data_format_t:  # Information about a data format
        int32 cbsize  # size of this structure
        void* ud  # user-defined data to be passed to callbacks
        int props  # properties (currently 0)
        char* name  # Format name, must be unique
        char* menu_name  # Visible format name to use in menus if nullptr, no
        char* hotkey  # Hotkey for the corresponding menu item if nullptr,
        asize_t value_size  # size of the value in bytes 0 means any size is ok 
        int32 text_width  # Usual width of the text representation This value 
        bint is_present_in_menus() const  # Should this format be shown in UI menus 
    cdef cppclass compiled_binpat_t:  # ------------------------------------------------------------
        bytevec_t bytes
        bytevec_t mask
        rangevec_t strlits  # range of string literals, in _bytes_ ranges (not C
        int encidx
        compiled_binpat_t()
        bint all_bytes_defined() const
        void qclear()
        bint operator==(compiled_binpat_t& r) const
        bint operator!=(compiled_binpat_t& r) const
    cdef cppclass hidden_range_t:  # Hidden ranges - address ranges which can be replaced by thei
        char* description  # description to display if the range is collapsed
        char* header  # header lines to display if the range is expanded
        char* footer  # footer lines to display if the range is expanded
        bint visible  # the range state
        bgcolor_t color  # range color
    cdef cppclass stkpnt_t:  #   This file also contains routines for working with library 
        pass
    cdef cppclass regvar_t
    cdef cppclass llabel_t
    cdef cppclass regarg_t:  # Register argument description. regargs are destroyed when th
        int reg
        type_t* type
        char* name
        regarg_t()
        regarg_t(regarg_t& r)
        regarg_t& operator=(regarg_t& r)
        void swap(regarg_t& r)
    cdef cppclass func_t:  # ------------------------------------------------------------
        uint64 flags
        uval_t frame  # netnode id of frame structure - see frame.hpp
        asize_t frsize  # size of local variables part of frame in bytes. If
        ushort frregs  # size of saved registers in frame. This range is im
        asize_t argsize  # number of bytes purged from the stack upon returni
        asize_t fpd  # frame pointer delta. (usually 0, i.e. realBP==typi
        bgcolor_t color  # user defined function color
        uint32 pntqty  # number of SP change points
        stkpnt_t* points  # array of SP change points. use ...stkpnt...() func
        int regvarqty  # number of register variables (-1-not read in yet) 
        regvar_t* regvars  # array of register variables. this array is sorted 
        int llabelqty  # number of local labels
        llabel_t* llabels  # local labels array. this array shouldn't be modifi
        int regargqty  # number of register arguments. During analysis IDA 
        regarg_t* regargs  # unsorted array of register arguments. use ...regar
        int tailqty  # number of function tails
        range_t* tails  # array of tails, sorted by ea. use func_tail_iterat
        ea_t owner  # the address of the main function possessing this t
        int refqty  # number of referers
        ea_t* referers  # array of referers (function start addresses). use 
        bint is_far() const  # Is a far function?
        bint does_return() const  # Does function return?
        bint analyzed_sp() const  # Has SP-analysis been performed?
        bint need_prolog_analysis() const  # Needs prolog analysis?
        func_t(ea_t start, ea_t end, flags64_t f)
    cdef cppclass lock_func:  # Helper class to lock a function pointer so it stays valid
        lock_func(func_t* _pfn)
    cdef cppclass lock_func_with_tails_t:  # lint -esym(1788, lock_func_with_tails_t) referenced only by 
        lock_func_with_tails_t(func_t* pfn)
        lock_func_with_tails_t(lock_func_with_tails_t&)
    cdef cppclass func_tail_iterator_t:  # Class to enumerate all function tails sorted by addresses. E
        func_tail_iterator_t()
        func_tail_iterator_t(func_t* _pfn, ea_t ea)
        bint set(func_t* _pfn, ea_t ea)
        bint set_ea(ea_t ea)
        bint set_range(ea_t ea1, ea_t ea2)  # set an arbitrary range
        range_t& chunk() const
        bint first()
        bint last()
        bint next()
        bint prev()
        bint main()
        func_tail_iterator_t(func_tail_iterator_t&)
        func_tail_iterator_t& operator=(func_tail_iterator_t&)
    cdef cppclass func_item_iterator_t:  # Class to enumerate all function instructions and data sorted
        func_item_iterator_t()
        func_item_iterator_t(func_t* pfn, ea_t _ea)
        bint set(func_t* pfn, ea_t _ea)  # Set a function range. if pfn == nullptr then a seg
        bint set_range(ea_t ea1, ea_t ea2)  # Set an arbitrary range
        bint first()
        bint last()
        ea_t current() const
        bint set_ea(ea_t _ea)
        range_t& chunk() const
        bint next_addr()
        bint next_head()
        bint next_code()
        bint next_data()
        bint next_not_tail()
        bint prev_addr()
        bint prev_head()
        bint prev_code()
        bint prev_data()
        bint prev_not_tail()
        bint decode_prev_insn(insn_t* out)
        bint decode_preceding_insn(eavec_t* visited, bint* p_farref, insn_t* out)
        bint succ_code()
        func_item_iterator_t(func_item_iterator_t&)
        func_item_iterator_t(func_item_iterator_t&&)
        func_item_iterator_t& operator=(func_item_iterator_t&&)
    cdef cppclass func_parent_iterator_t:  # Class to enumerate all function parents sorted by addresses.
        func_parent_iterator_t()
        func_parent_iterator_t(func_t* _fnt)
        bint set(func_t* _fnt)
        ea_t parent() const
        bint first()
        bint last()
        bint next()
        bint prev()
        void reset_fnt(func_t* _fnt)
    cdef cppclass sreg_range_t
    cdef cppclass idc_value_t
    cdef cppclass place_t:  #  (location_t would be a better name but it is too late to re
        int lnnum  # Number of line within the current object
        place_t()
        place_t(int ln)
        void print(qstring* vout, void* ud) const  # Generate a short description of the location. This
        uval_t touval(void* ud) const  # Map the location to a number. This mapping is used
        place_t* clone() const  # Clone the location. 
        void copyfrom(place_t* from_)  # Copy the specified location object to the current 
        place_t* makeplace(void* ud, uval_t x, int lnnum) const  # Map a number to a location. When the user clicks o
        int compare(place_t* t2) const  # Deprecated. Please consider compare2(const place_t
        void adjust(void* ud)  # Adjust the current location to point to a displaya
        bint prev(void* ud)  # Move to the previous displayable location. 
        bint next(void* ud)  # Move to the next displayable location. 
        bint beginning(void* ud) const  # Are we at the first displayable object?. 
        bint ending(void* ud) const  # Are we at the last displayable object?. 
        int generate(qstrvec_t* out, int* out_deflnnum, color_t* out_pfx_color, bgcolor_t* out_bgcolor, void* ud, int maxsize) const  # Generate text lines for the current location. 
        void serialize(bytevec_t* out) const  # Serialize this instance. It is fundamental that al
        bint deserialize(uchar** pptr, uchar* end)  # De-serialize into this instance. 'pptr' should be 
        int id() const  # Get the place's ID (i.e., the value returned by re
        char* name() const  # Get this place type name. All instances of a given
        ea_t toea() const  # Map the location to an ea_t. 
        bint rebase(int&)  # Rebase the place instance 
        place_t* enter(uint32*) const  # Visit this place, possibly 'unhiding' a section of
        void leave(uint32) const  # Leave this place, possibly 'hiding' a section of t
        int compare2(place_t* t2, void*) const  # Compare two locations except line numbers (lnnum).
        bint equals(place_t* t2, void* ud) const  # Compare two places for equality, ignoring line num
        place_t& operator=(place_t&)
        place_t& operator=(place_t&&)
        place_t(place_t&)
        place_t(place_t&&)
    cdef cppclass simpleline_t:  # Maintain basic information for a line in a custom view
        qstring line  # line text
        color_t color  # line prefix color
        bgcolor_t bgcolor  # line background color
        simpleline_t()
        simpleline_t(color_t c, char* str)
        simpleline_t(char* str)
        simpleline_t(qstring& str)
    cdef cppclass simpleline_place_t:  # A location in a view populated by a ::strvec_t
        uint32 n  # line number
        simpleline_place_t()
        simpleline_place_t(int _n)
        simpleline_place_t& operator=(simpleline_place_t&)
        simpleline_place_t& operator=(simpleline_place_t&&)
    cdef cppclass idaplace_t:  # A location in a disassembly view
        ea_t ea  # address
        idaplace_t()
        idaplace_t(ea_t x, int ln)
        idaplace_t& operator=(idaplace_t&)
        idaplace_t& operator=(idaplace_t&&)
        idaplace_t(idaplace_t&)
        idaplace_t(idaplace_t&&)
    cdef cppclass hexplace_gen_t:  # A helper, used as 'userdata' for generating lines in a hexpl
        bint is_editing() const
        bint is_editing_text() const
        bint is_curitem_changed() const
        bint is_edited_byte(ea_t ea, uint64* out_value) const
        byte_kind_t get_byte_value(ea_t ea, uint64* out_value, bint* out_edited) const
        void get_encoding(qstring* out) const
        ea_t get_cur_item_ea() const
        void get_cur_item_text(qstring* out) const
        int get_alignment() const
        int get_line_len(ea_t ea) const
        int get_items_per_line() const
        int get_bytes_per_item() const
        int get_item_width(ea_t ea) const
        data_kind_t get_data_kind() const
        int_format_t get_int_format() const
        bint has_central_separator() const
        bint show_text() const
        bint show_segaddr() const
        int get_bitness() const
        bint is_addr_kind() const
        hexplace_gen_t& operator=(hexplace_gen_t&)
        hexplace_gen_t& operator=(hexplace_gen_t&&)
    cdef cppclass hexplace_t:  # ------------------------------------------------------------
        hexplace_t(ea_t _ea, int ln)
        void out_one_item(int& ctx, hexplace_gen_t* hg, int itemno, color_t* color, color_t patch_or_edit) const
        size_t ea2str(char* buf, size_t bufsize, hexplace_gen_t* hg, ea_t ea)  # convert ea to text use seg:off if segment base is 
        hexplace_t& operator=(hexplace_t&)
        hexplace_t& operator=(hexplace_t&&)
    cdef cppclass tiplace_t:  # ------------------------------------------------------------
        uint32 ordinal
        tif_cursor_t cursor
        tiplace_t()
        tiplace_t(uint32 ord, tif_cursor_t c, int _lnnum)
        bint valid_ord() const
        void reset()
        bint is_header() const
        bint is_footer() const
        bint is_index() const
        void set_header()
        void set_footer()
        uint64 calc_udm_offset(void* ud, ssize_t* p_udmidx, int* p_bitoff) const  # for structs: calculate the offset that corresponds
        void set_index_by_offset(void* ud, uint64 offset)  # for structs: calculate the index that corresponds 
        type_t get_kind(void* ud) const  # get the kind of type this place represents 
        bint fill_type_ref(til_type_ref_t* out, void* ud) const  # fill the type information for use in actions 
        tiplace_t& operator=(tiplace_t&)
        tiplace_t& operator=(tiplace_t&&)
    cdef cppclass TWidget:  # A TWidget represents any user-facing widget present in IDA. 
        pass
    cdef cppclass sync_source_t:  # ------------------------------------------------------------
        sync_source_t()
        sync_source_t(TWidget* _view)
        sync_source_t(char* _regname)
        bint operator==(sync_source_t& _o) const
        bint operator!=(sync_source_t& _o) const
        bint is_register() const
        bint is_widget() const
        TWidget* get_widget() const
        char* get_register() const
        sync_source_t(sync_source_t&)
        sync_source_t(sync_source_t&&)
    cdef cppclass synced_group_t:
        bint has_widget(TWidget* v) const
        bint has_register(char* r) const
        bint has(sync_source_t& ss) const
    cdef cppclass twinpos_t:  # ------------------------------------------------------------
        place_t* at  # location in view
        int x  # cursor x
        twinpos_t(place_t* t, int x0)
        twinpos_t(twinpos_t&)
        twinpos_t(twinpos_t&&)
    cdef cppclass twinline_t:  # A line in a text window
        place_t* at  # location in view
        qstring line  # line contents
        color_t prefix_color  # line prefix color
        bgcolor_t bg_color  # line background color
        bint is_default  # is this the default line of the current location?
        twinline_t(place_t* t, color_t pc, bgcolor_t bc)
    cdef cppclass linearray_t:  # The group of lines corresponding to a single place within a 
        linearray_t(void* _ud)
        int set_place(place_t* new_at)  # Position the array. This function must be called b
        void copy_from(linearray_t* src)  # Copy information from one linearray to another. On
        place_t* get_place() const  # Get the current place. If called before down(), th
        bgcolor_t get_bg_color() const  # Get current background color. (the same behavior a
        bgcolor_t get_pfx_color() const  # Get current prefix color. (the same behavior as wi
        int get_dlnnum() const  # Get default line number. (the same behavior as wit
        int get_linecnt() const  # Get number of lines for the current place. (the sa
        void* userdata() const  # Get pointer to user data
        void set_userdata(void* userd)  # Change the user data
        bint beginning() const  # Are we at the beginning?
        bint ending() const  # Are we at the end?
        qstring* down()  # Get the next line going downwards. 'at' for the re
        qstring* up()  # Get the next line going upwards. 'at' for the retr
        void set_max_lines(int n)  # Set max number of lines to generate for a place. 0
    cdef cppclass lines_rendering_input_t:  # ------------------------------------------------------------
        int cb
        sections_lines_refs_t sections_lines  # references to the lines that are used for renderin
        synced_group_t* sync_group  # the 'synced' group 'widget' (see ui_get_lines_rend
    cdef cppclass line_rendering_output_entry_t:  # @ }
        twinline_t* line
        uint32 flags
        bgcolor_t bg_color  # 0x00000000: nothing 0xAABBGGRR: where AA is 0: BBG
        int cpx  # number of char to start from, valid if LROEF_CPS_R
        int nchars  # chars count, valid if LROEF_CPS_RANGE
        line_rendering_output_entry_t(twinline_t* _line, uint32 _flags, bgcolor_t _bg_color)
        line_rendering_output_entry_t(twinline_t* _line, int _cpx, int _nchars, uint32 _flags, bgcolor_t _bg_color)
        bint is_bg_color_empty() const
        bint is_bg_color_key() const
        bint is_bg_color_direct() const
        bint operator==(line_rendering_output_entry_t& r) const
        bint operator!=(line_rendering_output_entry_t& r) const
    cdef cppclass lines_rendering_output_t:  # ------------------------------------------------------------
        line_rendering_output_entries_refs_t entries
        uint32 flags
        void clear()
        bint operator==(lines_rendering_output_t& r) const
        bint operator!=(lines_rendering_output_t& r) const
        void swap(lines_rendering_output_t& r)
    cdef cppclass line_section_t:
        cpidx_t start
        cplen_t length
        bint contains(cpidx_t x) const
        bint is_open() const
        bint is_closed() const
        bint valid() const
        bint operator==(line_section_t& r) const
        bint operator!=(line_section_t& r) const
        line_section_t()
        line_section_t(line_section_t&)
        line_section_t(line_section_t&&)
    cdef cppclass tagged_line_section_t:  # ------------------------------------------------------------
        color_t tag
        tagged_line_section_t()
        bint operator==(tagged_line_section_t& r) const
        bint operator!=(tagged_line_section_t& r) const
        bint valid() const
        bint valid_in(qstring& in_) const
        bint substr(qstring* out, qstring& in_, tagged_line_section_t* end) const
    cdef cppclass tagged_line_sections_t:  # ------------------------------------------------------------
        tagged_line_section_t* first(color_t tag) const
        void sections_at(tagged_line_sections_t* out, cpidx_t x, color_t tag) const
        tagged_line_section_t* nearest_at(cpidx_t x, color_t tag) const  # For example, '// XREF: __loff_t/r _IO_FILE/r'  <on
        tagged_line_section_t* nearest_before(tagged_line_section_t& range, cpidx_t start, color_t tag) const  # For example, '// XREF: __loff_t/r _IO_FILE/r'  <on
        tagged_line_section_t* nearest_after(tagged_line_section_t& range, cpidx_t start, color_t tag) const
    cdef cppclass listing_location_t:  # Holds (live) data about a location being displayed in a list
        int cb
        int* loc
        qstring* text
        tagged_line_sections_t* tagged_sections
    cdef cppclass dirtree_t:  # @ }
        pass
    cdef cppclass chooser_item_attrs_t:  # Chooser item attributes
        int cb  # size of this structure. the callback must check th
        int flags
        bgcolor_t color  # item color
        chooser_item_attrs_t()
        void reset()
        bint operator==(chooser_item_attrs_t& other) const
    cdef cppclass chooser_row_info_t:  # Row data returned by get_chooser_rows().
        qstrvec_t texts  # texts, one per chooser column
        chooser_item_attrs_t attrs  # styling attributes
        int icon  # icon number
        bint operator==(chooser_row_info_t& other) const  # needed by pywraps
        bint operator!=(chooser_row_info_t& other) const
    cdef cppclass chooser_stdact_desc_t:
        int version  # to support the backward compatibility
        char* label  # see action_desc_t
        char* tooltip
        int icon
        chooser_stdact_desc_t(char* _label, char* _tooltip, int _icon)
        action_state_t ucb(action_update_ctx_t*)  # the update callback, see action_handler_t::update(
        chooser_stdact_desc_t& operator=(chooser_stdact_desc_t&)
    cdef cppclass chooser_base_t:  # Chooser object. #chooser
        int x0  # screen position,
        int y0
        int x1
        int y1
        int width  # (in chars)
        int height  # (in chars)
        char* title  # menu title (includes ptr to help). May have choose
        int columns  # number of columns
        int* widths  # column widths - low 16 bits of each value hold the
        char** header
        int icon  # default icon
        int deflt_col  # Column that will have focus.
        chooser_base_t(uint32 flags_, int columns_, int* widths_, char** header_, char* title_, uint16 flags2_)
        void call_destructor()  # called when the corresponding widget is destroyed.
        void* get_chooser_obj()  # get pointer to some custom data. 
        void* get_obj_id(size_t* len) const  # get the id of the chooser data. The choosers are t
        bint is_same(chooser_base_t* other) const  # do the current and the given objects hold the same
        bint can_ins() const  # is an operation allowed?
        bint can_del() const
        bint can_edit() const
        bint can_refresh() const
        bint popup_allowed(int stdact_idx) const  # is a standard action allowed?
        bint is_status_bar_hidden() const
        bint should_restore_geometry() const
        bint is_modal() const  # is choose modal?
        bint has_widget_lifecycle() const  # should chooser object be deleted when the widget g
        bint is_multi() const  # is multi-selection allowed?
        bint ask_item_attrs() const  # should chooser generate ui_get_chooser_item_attrs 
        bint is_force_default() const  # should selection of the already opened non-modal c
        uint get_builtin_number() const  # get number of the built-in chooser
        void set_ask_item_attrs(bint enable)  # enable or disable generation of ui_get_chooser_ite
        void check_version(uint32 ver) const  # check chooser version
        bint is_quick_filter_visible_initially() const  # should the quick filter be visible at startup?
        int get_quick_filter_initial_mode() const  # what mode should the quick filter initially be put
        bint has_dirtree() const  # does the chooser have the ability to show a tree v
        bint has_diff_capability() const  # does the chooser have the ability to participate i
        bint can_sort() const  # does chooser have sorting abilities?
        bint can_filter() const  # does chooser have filtering abilities?
        bint should_rename_trigger_edit() const  # should renaming trigger the 'edit' callback?
        bint is_dirtree_persisted() const  # is the chooser dirtree persisted?
        bint is_lazy_loaded() const  # is the chooser lazy-loaded?
        bint has_inode_to_index() const  # chooser_implement inode2index
        bint init()  # initialize the chooser and populate it. 
        size_t get_count() const  # get the number of elements in the chooser
        void get_row(qstrvec_t* out, int* out_icon, chooser_item_attrs_t* out_attrs, size_t n) const  # get a description of an element. 
        ea_t get_ea(size_t) const  # get the address of an element. When this function 
        void closed()  # The chooser window is closed.
    cdef cppclass renderer_pos_info_t:  # ------------------------------------------------------------
        int node  # the node, or -1 if the current renderer is not a g
        short cx  # the X coords of the character in the current line.
        short cy  # the Y coords of the character. When in graph mode:
        short sx  # the number of chars that are scrolled (flat mode o
        renderer_pos_info_t()  # Constructor
        bint operator==(renderer_pos_info_t& r) const
        bint operator!=(renderer_pos_info_t& r) const
    cdef cppclass selection_item_t:  # ------------------------------------------------------------
        pass
    cdef cppclass view_mouse_event_location_t:  # ------------------------------------------------------------
        ea_t ea  # flat view (rtype == ::TCCRT_FLAT)
        selection_item_t* item  # graph views (rtype != ::TCCRT_FLAT). nullptr if mo
    cdef cppclass view_mouse_event_t:  # Information about a mouse action within a view
        tcc_renderer_type_t rtype  # type of renderer that received the event
        uint32 x  # screen x coordinate
        uint32 y  # screen y coordinate
        location_t location  # location where event was generated
        view_event_state_t state  # contains information about what buttons are CURREN
        vme_button_t button  # represents which mouse button was responsible for 
        renderer_pos_info_t renderer_pos  # position where event was generated, relative to th
    cdef cppclass input_event_t:  # A representation of a user input
        int cb  # size marker
        input_event_kind_t kind  # the kind of event
        input_event_modifiers_t modifiers  # current keyboard (and mouse) modifiers
        TWidget* target  # the target widget
        void* source  # the source event, should it be required for detail
        input_event_shortcut_data_t shortcut
        input_event_keyboard_data_t keyboard
        input_event_mouse_data_t mouse
        input_event_t()
    cdef cppclass input_event_shortcut_data_t:
        char* action_name  # the action that will be triggered
    cdef cppclass input_event_keyboard_data_t:
        int key  # the key that was pressed to generate the event
    cdef cppclass input_event_mouse_data_t:
        int x  # the X position on the widget
        int y  # the Y position on the widget
        vme_button_t button  # the button that was pressed to generate the event
    cdef cppclass cli_t:  # Command line interpreter. Provides functionality for the com
        size_t size  # size of this structure
        int32 flags
        char* sname  # short name (displayed on the button)
        char* lname  # long name (displayed in the menu)
        char* hint  # hint for the input line
    cdef cppclass exec_request_t:  # Execute code in the main thread - to be used with execute_sy
        ssize_t code  # temporary location, used internally
        bint valid() const  # Can this request be executed?
        ssize_t execute()  # Callback to be executed. If this function raises a
        exec_request_t& operator=(exec_request_t&)
    cdef cppclass ui_request_t:  # ------------------------------------------------------------
        bint run()  # Run the UI request 
        ui_request_t& operator=(ui_request_t&)
    cdef cppclass ui_requests_t:  # List of UI requests. The ui_request_t is allocated by the ca
        ui_requests_t()
    cdef cppclass interactive_graph_t:  # @ }
        pass
    cdef cppclass screen_graph_selection_t
    cdef cppclass dirtree_selection_t
    cdef cppclass action_ctx_base_cur_sel_t:  # ------------------------------------------------------------
        twinpos_t from_  # start of selection
        twinpos_t to  # end of selection
        action_ctx_base_cur_sel_t()
        void reset()
    cdef cppclass action_ctx_base_t:  # ------------------------------------------------------------
        TWidget* widget
        twidget_type_t widget_type  # type of current widget
        qstring widget_title  # title of current widget
        chooser_base_t* chooser  # the underlying chooser_base_t (if 'widget' is a ch
        sizevec_t chooser_selection  # current chooser selection (0-based)
        char* action  # action name
        uint32 cur_flags  # Current address information. see
        ea_t cur_ea  # the current EA of the position in the view
        uval_t cur_value  # the possible address, or value the cursor is posit
        func_t* cur_func  # the current function
        func_t* cur_fchunk  # the current function chunk
        segment_t* cur_seg  # the current segment
        action_ctx_base_cur_sel_t cur_sel  # the currently selected range. also see #ACF_HAS_SE
        char* regname  # register name (if widget_type == BWN_CPUREGS and c
        TWidget* focus  # The focused widget in case it is not the 'form' it
        interactive_graph_t* graph  # the current graph (if in a graph view)
        screen_graph_selection_t* graph_selection  # the current graph selection (if in a graph view)
        selection_item_t* hovered  # the current item being hovered (if in a graph view
        dirtree_selection_t* dirtree_selection  # the current dirtree_t selection (if applicable)
        til_type_ref_t* type_ref  # a reference to the current type (if 'widget' is a 
        action_ctx_base_t()  # Constructor
        void reset()  # Invalidate all context info
        bint has_flag(uint32 flag) const  # Check if the given flag is set
    cdef cppclass action_handler_t:  # ------------------------------------------------------------
        int flags  # internal - for version management
        action_handler_t(int _f)  # Constructor
        int activate(action_activation_ctx_t* ctx)  # Activate an action. This function implements the c
        action_state_t update(action_update_ctx_t* ctx)  # Update an action. This is called when the context 
        action_handler_t& operator=(action_handler_t&)
    cdef cppclass action_desc_t:  # Describe an action to be registered (see register_action())
        int cb  # size of this structure
        char* name  # the internal name of the action; must be unique. a
        char* label  # the label of the action, possibly with an accelera
        action_handler_t* handler  # the action handler, for activating/updating. pleas
        void* owner  # either the plugin_t, or plugmod_t responsible for 
        char* shortcut  # an optional shortcut definition. E.g., "Ctrl+Enter
        char* tooltip  # an optional tooltip for the action
        int icon  # an optional icon ID to use
        int flags  # See
    cdef cppclass TPopupMenu:  # ------------------------------------------------------------
        pass
    cdef cppclass addon_info_t:  # Information about an installed add-on (e.g. a plugin)
        size_t cb  # size of this structure
        char* id  # product code, e.g. "com.hexrays.hexx86w". Must be 
        char* name  # descriptive name, e.g. "Hex-Rays x86 Decompiler (W
        char* producer  # e.g. "Hex-Rays SA"
        char* version  # version string, e.g. 1.5.110408
        char* url  # URL of the product http://www.hex-rays.com/decompi
        char* freeform  # any string, e.g. "Copyright (c) 2007-2025 Hex-Rays
        void* custom_data  # custom data (license ID etc). Can be nullptr. Not 
        size_t custom_size
        addon_info_t()  # Constructor
    cdef cppclass strarray_t:  # Map strings to integer values - see strarray()
        int code
        char* text
    cdef cppclass xrefblk_t:  # Structure to enumerate all xrefs. This structure provides a 
        ea_t from_  # the referencing address - filled by first_to(),nex
        ea_t to  # the referenced address - filled by first_from(), n
        bint iscode  # is code reference (::cref_t)? otherwise it is a da
        uchar type  # type of the last returned reference (::cref_t & ::
        bint user  # is user defined xref? otherwise defined by ida
        uchar _flags
        bint first_from(ea_t _from, int flags)  # Get first xref from the given address (store in #t
        bint next_from()  # Get next xref from address provided to first_from(
        bint first_to(ea_t _to, int flags)  # Get xref to given address (store in #from)
        bint next_to()  # Get next xref to address provided to first_to()
        bint next_from(ea_t _from, ea_t _to, int flags)  # Get xref from '_from' that comes after '_to'
        bint next_to(ea_t _from, ea_t _to, int flags)  # Get xref to '_to' that comes after '_from'
    cdef cppclass op_t:  # Operand of an instruction. This structure is filled by the a
        uchar n  # Number of operand (0,1,2). Initialized once at the
        optype_t type  # Type of operand (see
        char offb  # Offset of operand value from the instruction start
        char offo  # Same as #offb (some operands have 2 numeric values
        uchar flags
        op_dtype_t dtype  # Type of operand value (see This is the type of the
        uint16 reg  # number of register (::o_reg)
        uint16 phrase  # number of register phrase (::o_phrase,::o_displ). 
        uval_t value  # operand value (::o_imm) or outer displacement (::o
        ea_t addr  # virtual address pointed or used by the operand. (:
        ea_t specval  # This field may be used as you want.
        char specflag1  #  The following fields are used only in idp modules
        char specflag2
        char specflag3
        char specflag4
        void set_shown()  # Set operand to be shown
        void clr_shown()  # Set operand to hidden
        bint shown() const  # Is operand set to be shown?
        bint is_reg(int r) const  # Is register operand?
        bint is_imm(uval_t v) const  # Is immediate operand?
        op_t()  # @ }
        op_t(op_t&)
        op_t(op_t&&)
        op_t& operator=(op_t&)
        op_t& operator=(op_t&&)
    cdef cppclass insn_t:
        ea_t cs  # Current segment base paragraph. Initialized by the
        ea_t ip  # Virtual address of the instruction (address within
        ea_t ea  # Linear address of the instruction. Initialized by 
        uint16 itype  # Internal code of instruction (only for canonical i
        uint16 size  # Size of instruction in bytes. The analyzer should 
        uint32 auxpref  # processor dependent field
        char segpref  # processor dependent field
        char insnpref  # processor dependent field
        int16 flags
        insn_t()
        bint is_canon_insn(processor_t& ph) const
        uint32 get_canon_feature(processor_t& ph) const
        char* get_canon_mnem(processor_t& ph) const
        bint is_macro() const  # Is a macro instruction?
        bint is_64bit() const
        uint8 get_next_byte()  #  The following functions return the next byte, 2 b
        uint16 get_next_word()
        uint32 get_next_dword()
        uint64 get_next_qword()
        bint create_op_data(ea_t ea_, int opoff, op_dtype_t dtype) const  # Convert to data using information about operand va
        bint create_op_data(ea_t ea_, op_t& op) const  # Convenient alias
        bint create_stkvar(op_t& x, adiff_t v, int flags_) const  # Create or modify a stack variable in the function 
        void add_cref(ea_t to, int opoff, cref_t type) const  # Add a code cross-reference from the instruction. 
        void add_dref(ea_t to, int opoff, dref_t type) const  # Add a data cross-reference from the instruction. S
        ea_t add_off_drefs(op_t& x, dref_t type, int outf) const  # Add xrefs for an operand of the instruction. This 
        insn_t(insn_t&)
        insn_t(insn_t&&)
        insn_t& operator=(insn_t&)
        insn_t& operator=(insn_t&&)
    cdef cppclass outctx_base_t:  # ------------------------------------------------------------
        ea_helper_t& _eah
        ea_t insn_ea  # information for creating one line
        qstring outbuf  # buffer for the current output line once ready, it 
        ssize_t regname_idx  # to rename registers
        int suspop  # controls color for out_long()
        flags_t F32  # please use outctx_t::F instead
        uval_t* outvalues  # at least 2*UA_MAXOP elements
        int outvalue_getn_flags  # additional flags for print_operand()
        void* user_data  # pointer to be used by the processor module for any
        void* kern_data  # internal info used by the kernel
        qstrvec_t* lnar  # vector of output lines
        int lnar_maxsize  # max permitted size of lnar
        int default_lnnum  # index of the most important line in lnar
        qstring line_prefix  # usually segname:offset
        ssize_t prefix_len  # visible length of line_prefix
        int ctxflags  # various bits
        int ind0  # internal data used by the kernel
        ea_t cmt_ea  # indirectly referenced address (used to generate cm
        qstring cmtbuf  # indented comment
        char* cmtptr  # rest of indented comment
        color_t cmtcolor  # comment color
        bint only_main_line() const
        bint multiline() const
        bint force_code() const
        bint stack_view() const
        bint display_voids() const
        bint display_hidden() const
        void set_gen_xrefs(bint on)
        int get_xrefgen_state() const
        void set_gen_cmt(bint on)
        int get_cmtgen_state() const
        int get_binop_state() const
        void clr_gen_label()
        void set_gen_label()
        void set_gen_demangled_label()
        void set_comment_addr(ea_t ea)
        void set_dlbind_opnd()
        bint print_label_now() const
        int forbid_annotations()
        void restore_ctxflags(int saved_flags)
        outctx_base_t(ea_t ea, flags64_t flags, int _suspop)
        outctx_base_t& operator=(outctx_base_t&)
        size_t out_printf(char* format)  # Append a formatted string to the output string. 
        size_t nowarn_out_printf(char* format)
        flags64_t out_value(op_t& x, int outf)  # Output immediate value. Try to use this function t
        void out_symbol(char c)  # Output a character with #COLOR_SYMBOL color.
        void out_chars(char c, int n)  # Append a character multiple times
        void out_spaces(ssize_t len)  # Appends spaces to outbuf until its tag_strlen beco
        void add_spaces(qstring* buf, ssize_t len)
        void out_line(char* str, color_t color)  # Output a string with the specified color.
        void out_keyword(char* str)  # Output a string with #COLOR_KEYWORD color.
        void out_register(char* str)  # Output a character with #COLOR_REG color.
        void out_lvar(char* name, int width)  # Output local variable name with #COLOR_LOCNAME col
        void out_tagon(color_t tag)  # Output "turn color on" escape sequence
        void out_tagoff(color_t tag)  # Output "turn color off" escape sequence
        void out_addr_tag(ea_t ea)  # Output "address" escape sequence
        void out_colored_register_line(char* str)  # Output a colored line with register names in it. T
        void out_char(char c)  # Output one character. The character is output with
        void out_btoa(uval_t Word, char radix)  # Output a number with the specified base (binary, o
        void out_long(sval_t v, char radix)  #  Output a number with appropriate color. Low level
        bint out_name_expr(op_t& x, ea_t ea, adiff_t off)  # Output a name expression. 
        void close_comment()  # Generate the closing comment if if it required by 
        bint flush_outbuf(int indent)  # Move the contents of the output buffer to the line
        bint flush_buf(char* buf, int indent)  # Append contents of 'buf' to the line array. Behave
        int term_outctx(char* prefix)  # Finalize the output context. 
        bint gen_printf(int indent, char* format)  # printf-like function to add lines to the line arra
        bint gen_empty_line()  # Generate empty line. This function does nothing if
        bint gen_border_line(bint solid)  # Generate thin border line. This function does noth
        bint gen_cmt_line(char* format)  # Generate one non-indented comment line, colored wi
        bint gen_collapsed_line(char* format)  # Generate one non-indented comment line, colored wi
        bint gen_block_cmt(char* cmt, color_t color)  # Generate big non-indented comment lines. 
        void setup_outctx(char* prefix, int makeline_flags)  # --------------------------------------------------
        ssize_t retrieve_cmt()
        ssize_t retrieve_name(qstring*, color_t*)
        bint gen_xref_lines()
        void init_lines_array(qstrvec_t* answers, int maxsize)
        ssize_t get_stkvar(op_t& x, uval_t v, sval_t* vv, int* is_sp_based, tinfo_t* _frame)
        void gen_empty_line_without_annotations()
        flags64_t getF() const
    cdef cppclass outctx_t:  # ------------------------------------------------------------
        ea_t bin_ea  # Current binary format EA
        char bin_state  # =0 not generated,1-in process,2-finished
        int gl_bpsize  # binary line prefix size
        int bin_width
        insn_t insn  # valid only when ph.out_insn() is called
        qstring curlabel  # colorized and demangled label of the current addre
        printop_t* wif  # opinfo_t to use for out_value()
        procmod_t* procmod  # processor module and its description
        processor_t& ph
        asm_t& ash
        ea_t prefix_ea
        ea_t next_line_ea  # EA of next line (for prefix)
        flags64_t F
        outctx_t(procmod_t* p, processor_t& ph, asm_t& ash, ea_t ea, flags64_t flags, int _suspop, printop_t* _wif)
        void setup_outctx(char* prefix, int flags)
        int term_outctx(char* prefix)
        ssize_t retrieve_cmt()
        ssize_t retrieve_name(qstring*, color_t*)
        bint gen_xref_lines()
        void out_btoa(uval_t Word, char radix)
        void set_bin_state(int value)
        void out_mnem(int width, char* postfix)  # Output instruction mnemonic for 'insn' using infor
        void out_custom_mnem(char* mnem, int width, char* postfix)  # Output custom mnemonic for 'insn'. E.g. if it shou
        void out_mnemonic()  # Output instruction mnemonic using information in '
        bint out_one_operand(int n)  # Use this function to output an operand of an instr
        size_t get_immvals(uval_t* out, int i)  # Get the immediate values used at the specified add
        void out_immchar_cmts()  # Print all operand values as commented character co
        void gen_func_header(func_t* pfn)
        void gen_func_footer(func_t* pfn)
        void out_data(bint analyze_only)  # display data items and undefined bytes.
        bint out_specea(uchar segtype)  # generate declaration for item in a special segment
        void gen_header_extra()  # convenience functions for processor modules print 
        void gen_header(int flags, char* proc_name, char* proc_flavour)
        void out_fcref_names()  # Print addresses referenced *from* the specified ad
        outctx_t(outctx_t&)
        outctx_t& operator=(outctx_t&)
    cdef cppclass macro_constructor_t:  # Helper class for processor modules to build macro instructio
        size_t reserved
        bint construct_macro(insn_t* insn, bint enable)  # Construct a macro instruction. This function may b
        bint build_macro(insn_t* insn, bint may_go_forward)  # Try to extend the instruction. This function may m
        macro_constructor_t& operator=(macro_constructor_t&)
    cdef cppclass bitrange_t:  # ------------------------------------------------------------
        bitrange_t(uint16 bit_ofs, uint16 size_in_bits)  # Constructor
        void init(uint16 bit_ofs, uint16 size_in_bits)  # Initialize offset and size to given values
        void reset()  # Make the bitrange empty
        bint empty() const  # Is the bitrange empty?
        uint bitoff() const  # Get offset of 1st bit
        uint bitsize() const  # Get size of the value in bits
        uint bytesize() const  # Size of the value in bytes
        uint64 mask64() const  # Convert to mask of 64 bits
        bint has_common(bitrange_t& r) const  # Does have common bits with another bitrange?
        bint apply_mask(bitrange_t& subrange)  # Apply mask to a bitrange 
        void intersect(bitrange_t& r)  # Intersect two ranges
        void create_union(bitrange_t& r)  # Create union of 2 ranges including the hole betwee
        bint sub(bitrange_t& r)  # Subtract a bitrange
        void shift_down(uint cnt)  # Shift range down (left)
        void shift_up(uint cnt)  # Shift range up (right)
        bint extract(bytevec_t* dst, void* src, size_t src_size, bint is_mf) const  #  Extract a value from 'src' according to the bitra
        bint extract(void* dst, size_t dst_size, void* src, size_t src_size, bint is_mf) const
        bint inject(void* dst, size_t dst_size, void* src, size_t src_size, bint is_mf) const  #  Inject a value into 'dst' according to the bitran
        bint inject(void* dst, size_t dst_size, bytevec_t& src, bint is_mf) const
        bint operator==(bitrange_t& r) const  # @ }
        bint operator!=(bitrange_t& r) const  # @ }
        bint operator<(bitrange_t& r) const  # @ }
        bint operator>(bitrange_t& r) const  # @ }
        bint operator<=(bitrange_t& r) const  # @ }
        bint operator>=(bitrange_t& r) const  # @ }
        int compare(bitrange_t& r) const  # @ }
    cdef cppclass lexer_t:  # ------------------------------------------------------------
        pass
    cdef cppclass token_t
    cdef cppclass jvalue_t
    cdef cppclass cfgopt_t:  # ------------------------------------------------------------
        char* name
        void* ptr
        size_t mbroff  # offset of a structure member
        int flags
        size_t buf_size
        num_range_t num_range
        uint32 bit_flags
        params_t params
        void* mbroff_obj
        cfgopt_t(char* _n, char* _p, size_t _sz, bint _long)  # IDPOPT_STR
        cfgopt_t(char* _n, qstring* _p, bint _long)
        cfgopt_t(char* _n, int* _p)  # IDPOPT_NUM
        cfgopt_t(char* _n, uint* _p)
        cfgopt_t(char* _n, char* _p)
        cfgopt_t(char* _n, uchar* _p)
        cfgopt_t(char* _n, short* _p)
        cfgopt_t(char* _n, ushort* _p)
        cfgopt_t(char* _n, int* _p, int _min, int _max)  # IDPOPT_NUM + ranges
        cfgopt_t(char* _n, uint* _p, uint _min, uint _max)
        cfgopt_t(char* _n, char* _p, char _min, char _max)
        cfgopt_t(char* _n, uchar* _p, uchar _min, uchar _max)
        cfgopt_t(char* _n, short* _p, short _min, short _max)
        cfgopt_t(char* _n, ushort* _p, ushort _min, ushort _max)
        cfgopt_t(char* _n, bint* _p, bint _flags)  # IDPOPT_BIT
        cfgopt_t(char* _n, uchar* _p, uchar _flags)
        cfgopt_t(char* _n, ushort* _p, ushort _flags)
        cfgopt_t(char* _n, uint32* _p, uint32 _flags)
        cfgopt_t(char* _n, int64* _p)  # IDPOPT_I64
        cfgopt_t(char* _n, uint64* _p)
        cfgopt_t(char* _n, int64* _p, int64 _min, int64 _max)  # IDPOPT_I64 + ranges
        cfgopt_t(char* _n, uint64* _p, uint64 _min, uint64 _max)
        cfgopt_t(char* _n, jvalue_t* _p)  # IDPOPT_JVL
        int type() const
        int qualifier() const
        bint is_mbroff() const
        bint get_number(int64* out, lexer_t* lx, token_t& _t, int range_bit, int usign_bit) const
        char* apply(int vtype, void* vdata, void* obj) const
        char* apply(lexer_t* lx, int vtype, void* vdata, void* obj) const
    cdef cppclass num_range_t:
        int64 minval
        int64 maxval
        num_range_t(int64 _min, int64 _max)
        num_range_t(num_range_t&)
        num_range_t(num_range_t&&)
    cdef cppclass params_t:
        int64 p1
        int64 p2
        params_t(int64 _p1, int64 _p2)
        params_t(params_t&)
        params_t(params_t&&)
    cdef cppclass cfgopt_set_t:  # ------------------------------------------------------------
        cfgopt_t* opts
        size_t nopts
        void* obj
    cdef cppclass cfgopt_set_vec_t:
        pass
    cdef cppclass regval_t
    cdef cppclass stkpnts_t
    cdef cppclass call_stack_t
    cdef cppclass reg_finder_t
    cdef cppclass merge_data_t
    cdef cppclass idasgn_t
    cdef cppclass bytes_t:  # ------------------------------------------------------------
        uchar len
        uchar* bytes
    cdef cppclass instruc_t:  # ------------------------------------------------------------
        char* name  # instruction name
        uint32 feature  # combination of
    cdef cppclass asm_t:  # ============================================================
        uint32 flag
        uint16 uflag  # user defined flags (local only for IDP) you may de
        char* name  # Assembler name (displayed in menus)
        help_t help  # Help screen number, 0 - no help
        char** header  # array of automatically generated header lines they
        char* origin  # org directive
        char* end  # end directive
        char* cmnt  # comment string (see also cmnt2)
        char ascsep  # string literal delimiter
        char accsep  # char constant delimiter
        char* esccodes  # special chars that cannot appear as is in string a
        char* a_ascii  # string literal directive
        char* a_byte  # byte directive
        char* a_word  # word directive
        char* a_dword  # nullptr if not allowed
        char* a_qword  # nullptr if not allowed
        char* a_oword  # nullptr if not allowed
        char* a_float  # float;  4bytes; nullptr if not allowed
        char* a_double  # double; 8bytes; nullptr if not allowed
        char* a_tbyte  # long double;    nullptr if not allowed
        char* a_packreal  # packed decimal real nullptr if not allowed
        char* a_dups  # array keyword. the following sequences may appear:
        char* a_bss  # uninitialized data directive should include '%s' f
        char* a_equ  # 'equ' Used if AS_UNEQU is set
        char* a_seg  # 'seg ' prefix (example: push seg seg001)
        char* a_curip  # current IP (instruction pointer) symbol in assembl
        char* a_public  # "public" name keyword. nullptr-use default, ""-do 
        char* a_weak  # "weak"   name keyword. nullptr-use default, ""-do 
        char* a_extrn  # "extern" name keyword
        char* a_comdef  # "comm" (communal variable)
        char* a_align  # "align" keyword
        char lbrace  # left brace used in complex expressions
        char rbrace  # right brace used in complex expressions
        char* a_mod  # %  mod     assembler time operation
        char* a_band  #  & bit and assembler time operation
        char* a_bor  # |  bit or  assembler time operation
        char* a_xor  # ^  bit xor assembler time operation
        char* a_bnot  # ~  bit not assembler time operation
        char* a_shl  #  < < shift left assembler time operation
        char* a_shr  # >> shift right assembler time operation
        char* a_sizeof_fmt  # size of type (format string)
        uint32 flag2
        char* cmnt2  # comment close string (usually nullptr) this is use
        char* low8  # low8 operation, should contain %s for the operand
        char* high8  # high8
        char* low16  # low16
        char* high16  # high16
        char* a_include_fmt  # the include directive (format string)
        char* a_vstruc_fmt  # if a named item is a structure and displayed in th
        char* a_rva  # 'rva' keyword for image based offsets (see #REFINF
        char* a_yword  # 32-byte (256-bit) data; nullptr if not allowed req
        char* a_zword  # 64-byte (512-bit) data; nullptr if not allowed req
    cdef cppclass proc_def_t:  # forward declarations for notification helpers
        pass
    cdef cppclass elf_loader_t
    cdef cppclass reader_t
    cdef cppclass extlang_t
    cdef cppclass libfunc_t
    cdef cppclass fixup_data_t
    cdef cppclass idd_opinfo_t
    cdef cppclass event_listener_t:
        size_t listener_flags  # reserved
        event_listener_t& operator=(event_listener_t&)
        event_listener_t()
        event_listener_t(event_listener_t&)
    cdef cppclass processor_t:  # ============================================================
        int32 version  # Expected kernel version, should be #IDP_INTERFACE_
        int32 id  # one of
        uint32 flag  # an ORed combination of
        uint32 flag2  # an ORed combination of
        int32 cnbits  # Number of bits in a byte for code segments (usuall
        int32 dnbits  # Number of bits in a byte for non-code segments (us
        char** psnames  # short processor names (nullptr terminated). Each n
        char** plnames  # long processor names (nullptr terminated). No rest
        asm_t** assemblers  # pointer to array of target assembler definitions. 
        char** reg_names  # array of register names
        int32 regs_num  # number of registers
        int32 reg_first_sreg  # number of first segment register
        int32 reg_last_sreg  # number of last segment register
        int32 segreg_size  # size of a segment register in bytes
        int32 reg_code_sreg  # number of CS register
        int32 reg_data_sreg  # number of DS register
        bytes_t* codestart  # Array of typical code start sequences. This array 
        bytes_t* retcodes  # Array of 'return' instruction opcodes. This array 
        int32 instruc_start  # icode of the first instruction
        int32 instruc_end  # icode of the last instruction + 1
        instruc_t* instruc  # Array of instructions
        size_t tbyte_size  # Size of long double (tbyte) for this processor (me
        int32 icode_return  # Icode of return instruction. It is ok to give any 
        void* unused_slot  # Reserved, currently equals to nullptr
        bint has_idp_opts() const
        bint has_segregs() const
        bint use32() const
        bint use64() const
        bint ti() const
        bint stkup() const
        bint use_tbyte() const
        bint use_mappings() const
        bint has_code16_bit() const
        bint supports_macros() const
        bint supports_calcrel() const
        bint calcrel_in_bits() const
        int get_default_segm_bitness(bint is_64bit_app) const  # Get default segment bitness 
        int cbsize()  #  Number of 8bit bytes required to hold one byte of
        int dbsize()
        int get_proc_index()  # @ }
        ssize_t notify(event_t event_code)
        ssize_t init(char* idp_modname)  # Notification helpers, should be used instead of di
        ssize_t term()
        ssize_t newprc(int pnum, bint keep_cfg)
        ssize_t newasm(int asmnum)
        ssize_t asm_installed(int asmnum)
        ssize_t newfile(char* fname)
        ssize_t oldfile(char* fname)
        ssize_t newbinary(char* filename, int fileoff, ea_t basepara, ea_t binoff, uint64 nbytes)
        ssize_t endbinary(bint ok)
        ssize_t creating_segm(segment_t* seg)
        ssize_t assemble(uchar* _bin, ea_t ea, ea_t cs, ea_t ip, bint _use32, char* line)
        ssize_t ana_insn(insn_t* out)
        ssize_t emu_insn(insn_t& insn)
        ssize_t out_header(outctx_t& ctx)
        ssize_t out_footer(outctx_t& ctx)
        ssize_t out_segstart(outctx_t& ctx, segment_t* seg)
        ssize_t out_segend(outctx_t& ctx, segment_t* seg)
        ssize_t out_assumes(outctx_t& ctx)
        ssize_t out_insn(outctx_t& ctx)
        ssize_t out_mnem(outctx_t& ctx)
        ssize_t out_operand(outctx_t& ctx, op_t& op)
        ssize_t out_data(outctx_t& ctx, bint analyze_only)
        ssize_t out_label(outctx_t& ctx, char* colored_name)
        ssize_t out_special_item(outctx_t& ctx, uchar segtype)
        ssize_t gen_stkvar_def(outctx_t& ctx, udm_t* mptr, sval_t v, tid_t tid)
        ssize_t gen_regvar_def(outctx_t& ctx, regvar_t* v)
        ssize_t gen_src_file_lnnum(outctx_t& ctx, char* file, size_t lnnum)
        ssize_t rename(ea_t ea, char* new_name, int flags)
        ssize_t may_show_sreg(ea_t current_ea)
        ssize_t coagulate(ea_t start_ea)
        void auto_queue_empty(int type)
        ssize_t func_bounds(int* possible_return_code, func_t* pfn, ea_t max_func_end_ea)
        ssize_t may_be_func(insn_t& insn, int state)
        ssize_t is_sane_insn(insn_t& insn, int no_crefs)
        ssize_t cmp_operands(op_t& op1, op_t& op2)
        ssize_t is_jump_func(func_t* pfn, ea_t* jump_target, ea_t* func_pointer)
        ssize_t is_basic_block_end(insn_t& insn, bint call_insn_stops_block)
        ssize_t getreg(uval_t* rv, int regnum)
        ssize_t undefine(ea_t ea)
        ssize_t moving_segm(segment_t* seg, ea_t to, int flags)
        ssize_t is_sp_based(insn_t& insn, op_t& x)
        ssize_t is_far_jump(int icode)
        ssize_t is_call_insn(insn_t& insn)
        ssize_t is_ret_insn(insn_t& insn, uchar iri_flags)
        ssize_t is_align_insn(ea_t ea)
        ssize_t is_addr_insn(int* type, insn_t& insn)
        ssize_t can_have_type(op_t& op)
        ssize_t get_stkvar_scale_factor()
        ssize_t demangle_name(int32* res, qstring* out, char* name, uint32 disable_mask, int demreq)
        ssize_t create_flat_group(ea_t image_base, int bitness, sel_t dataseg_sel)
        ssize_t is_alloca_probe(ea_t ea)
        ssize_t get_reg_name(qstring* buf, int reg, size_t width, int reghi)
        ssize_t gen_asm_or_lst(bint starting, FILE* fp, bint is_asm, int flags, void* outline)
        ssize_t gen_map_file(int* nlines, FILE* fp)
        ssize_t get_autocmt(qstring* buf, insn_t& insn)
        ssize_t loader_elf_machine(linput_t* li, int machine_type, char** p_procname, proc_def_t** p_pd, elf_loader_t* ldr, reader_t* reader)
        ssize_t is_indirect_jump(insn_t& insn)
        ssize_t verify_noreturn(func_t* pfn)
        ssize_t verify_sp(func_t* pfn)
        ssize_t create_func_frame(func_t* pfn)
        ssize_t get_frame_retsize(int* retsize, func_t* pfn)
        ssize_t analyze_prolog(ea_t fct_ea)
        ssize_t calc_spdelta(sval_t* spdelta, insn_t& ins)
        ssize_t calcrel(bytevec_t* out_relbits, size_t* out_consumed, ea_t ea)
        ssize_t get_reg_accesses(reg_accesses_t* accvec, insn_t& insn, int flags)
        ssize_t is_control_flow_guard(int* p_reg, insn_t* insn)
        ssize_t find_reg_value(uval_t* out, insn_t& insn, int reg)
        ssize_t find_op_value(uval_t* out, insn_t& insn, int op)
        ssize_t treat_hindering_item(ea_t hindering_item_ea, flags64_t new_item_flags, ea_t new_item_ea, asize_t new_item_length)
        ssize_t extract_address(ea_t* out_ea, ea_t screen_ea, char* string, size_t x)
        ssize_t str2reg(char* regname)
        ssize_t is_switch(switch_info_t* si, insn_t& insn)
        ssize_t create_switch_xrefs(ea_t jumpea, switch_info_t& si)
        ssize_t calc_switch_cases(void* casevec, eavec_t* targets, ea_t insn_ea, switch_info_t& si)
        ssize_t get_bg_color(bgcolor_t* color, ea_t ea)
        ssize_t validate_flirt_func(ea_t start_ea, char* funcname)
        ssize_t get_operand_string(qstring* buf, insn_t& insn, int opnum)
        ssize_t add_cref(ea_t from_, ea_t to, cref_t type)
        ssize_t add_dref(ea_t from_, ea_t to, dref_t type)
        ssize_t del_cref(ea_t from_, ea_t to, bint expand)
        ssize_t del_dref(ea_t from_, ea_t to)
        ssize_t coagulate_dref(ea_t from_, ea_t to, bint may_define, ea_t* code_ea)
        char* set_idp_options(char* keyword, int vtype, void* value, bint idb_loaded)
        ssize_t set_proc_options(char* options, int confidence)
        ssize_t adjust_libfunc_ea(idasgn_t& sig, libfunc_t& libfun, ea_t* ea)
        fpvalue_error_t realcvt(void* m, fpvalue_t* e, uint16 swt)
        bint delay_slot_insn(ea_t* ea, bint* bexec, bint* fexec)
        ssize_t adjust_refinfo(refinfo_t* ri, ea_t ea, int n, fixup_data_t& fd)
        ssize_t is_cond_insn(insn_t& insn)
        ssize_t set_code16_mode(ea_t ea, bint code16)
        bint get_code16_mode(ea_t ea)
        ssize_t calc_step_over(ea_t* target, ea_t ip)
        ssize_t get_macro_insn_head(ea_t* head, ea_t ip)
        ssize_t get_dbr_opnum(int* opnum, insn_t& insn)
        ssize_t calc_next_eas(eavec_t* res, insn_t& insn, bint over)
        char* get_reg_info(char* regname, bitrange_t* bitrange)
        ssize_t setup_til()
        ssize_t max_ptr_size()
        ssize_t calc_cdecl_purged_bytes(ea_t ea)
        ssize_t equal_reglocs(argloc_t& a1, argloc_t& a2)
        ssize_t _decorate_name(qstring* outbuf, char* name, bint mangle, callcnv_t cc, tinfo_t& type)
        ssize_t _calc_retloc(argloc_t* retloc, tinfo_t& rettype, callcnv_t cc)
        ssize_t _calc_varglocs(func_type_data_t* ftd, regobjs_t* regs, relobj_t* stkargs, int nfixed)
        ssize_t _calc_arglocs(func_type_data_t* fti)
        ssize_t use_stkarg_type(ea_t ea, funcarg_t& arg)
        ssize_t use_regarg_type(int* idx, ea_t ea, void* rargs)
        ssize_t use_arg_types(ea_t ea, func_type_data_t* fti, void* rargs)
        ssize_t calc_purged_bytes(int* p_purged_bytes, func_type_data_t& fti)
        ssize_t get_cc_regs(callregs_t* regs, callcnv_t cc)
        ssize_t get_simd_types(void* out, simd_info_t* simd_attrs, argloc_t* argloc, bint create_tifs)
        ssize_t arg_addrs_ready(ea_t caller, int n, tinfo_t& tif, ea_t* addrs)
        ssize_t adjust_argloc(argloc_t* argloc, tinfo_t* type, int size)
        ssize_t lower_func_type(intvec_t* argnums, func_type_data_t* fti)
        ssize_t get_abi_info(qstrvec_t* abi_names, qstrvec_t* abi_opts, comp_t comp)
        ssize_t arch_changed()
        ssize_t create_merge_handlers(merge_data_t* md)
        ssize_t privrange_changed(range_t& old_privrange, adiff_t delta, qstring* errbuf)
        ssize_t cvt64_supval(nodeidx_t node, uchar tag, nodeidx_t idx, uchar* data, size_t datlen, qstring* errbuf)
        ssize_t cvt64_hashval(nodeidx_t node, uchar tag, char* name, uchar* data, size_t datlen, qstring* errbuf)
        reg_finder_t* get_regfinder()
        int get_stkvar_scale()  # Get the stack variable scaling factor. Useful for 
        bint is_canon_insn(uint16 itype) const  # Does the given value specify a valid instruction f
        char* get_canon_mnem(uint16 itype) const  # Get the instruction name
        uint32 get_canon_feature(uint16 itype) const  # Get the instruction features (combination of
        void ensure_processor()
        size_t sizeof_ldbl() const
        bint is_funcarg_off(func_t* pfn, uval_t frameoff) const
        sval_t lvar_off(func_t* pfn, uval_t frameoff) const
        bint is_lumina_usable() const
    cdef cppclass modctx_t:
        processor_t& ph
        asm_t& ash
        ea_helper_t& _eah
        modctx_t()
        modctx_t& operator=(modctx_t&)
        modctx_t& operator=(modctx_t&&)
        modctx_t(modctx_t&)
        modctx_t(modctx_t&&)
    cdef cppclass procmod_t:  # Each processor module subclasses this class and reacts to HT
        size_t procmod_flags
        procmod_t()
        procmod_t(procmod_t&)
        op_t* make_op_reg(op_t* op, int reg, int8 dtype) const  # The helper methods for
        op_t* make_op_imm(op_t* op, uval_t val, int8 dtype) const
        op_t* make_op_displ(op_t* op, int base_reg, uval_t displ, int8 dtype) const
        op_t* make_op_phrase(op_t* op, int base_reg, int index_reg, int8 dtype) const  # This method puts the index register into the VALUE
    cdef cppclass plugmod_t:
        size_t owner  # internal info used by the kernel
        bint run(size_t arg)  # Invoke the plugin.
        bint hook_event_listener(hook_type_t hook_type, event_listener_t* cb, int hkcb_flags)  # Helper function to hook event listeners.
        plugmod_t& operator=(plugmod_t&)
    cdef cppclass reg_info_t:  # Get register number and size from register name
        int reg  # register number
        int size  # register size
        bint operator==(reg_info_t& r) const
        bint operator!=(reg_info_t& r) const
        bint operator<(reg_info_t& r) const
        bint operator>(reg_info_t& r) const
        bint operator<=(reg_info_t& r) const
        bint operator>=(reg_info_t& r) const
        int compare(reg_info_t& r) const
    cdef cppclass reg_access_t:  # Information about a register accessed by an instruction.
        int regnum  # register number (only entire registers)
        bitrange_t range  # bitrange inside the register
        access_type_t access_type
        uchar opnum  # operand number
        bint have_common_bits(reg_access_t& r) const
        bint operator==(reg_access_t& r) const
        bint operator!=(reg_access_t& r) const
    cdef cppclass reg_accesses_t:
        pass
    cdef cppclass intset_t:  # ------------------------------------------------------------
        size_t print(char* buf, size_t bufsize) const
        char* dstr() const
        bint has(int value) const
        intset_t()
        intset_t(intset_t&)
        intset_t(intset_t&&)
    cdef cppclass intmap_t:  # Map of integer constants to integer constants
        size_t print(char* buf, size_t bufsize) const
        char* dstr() const
    cdef cppclass edge_t:  # ------------------------------------------------------------
        int src  # source node number
        int dst  # destination node number
        edge_t(int x, int y)
        bint operator<(edge_t& y) const
        bint operator==(edge_t& y) const
        bint operator!=(edge_t& y) const
    cdef cppclass edgevec_t:
        pass
    cdef cppclass edgeset_t
    cdef cppclass edge_segs_vec_t
    cdef cppclass edge_infos_t
    cdef cppclass destset_t
    cdef cppclass node_set_t:  # ------------------------------------------------------------
        node_set_t()
        node_set_t(int node)
        node_set_t(gdl_graph_t* g)
        bint add(int node)
        void sub(int node)
        void sub(node_set_t& r)
        void add(node_set_t& r)
        void intersect(node_set_t& r)
        void extract(intvec_t& out) const
        int first() const
        node_set_t(node_set_t&)
        node_set_t(node_set_t&&)
    cdef cppclass node_ordering_t:  # ------------------------------------------------------------
        void clear()
        void resize(int n)
        size_t size() const
        void set(int _node, int num)
        bint clr(int _node)
        int node(size_t _order) const
        int order(int _node)
    cdef cppclass node_iterator:  # ------------------------------------------------------------
        node_iterator(gdl_graph_t* _g, int n)
        node_iterator& operator++()
        bint operator==(node_iterator& n) const
        bint operator!=(node_iterator& n) const
        int operator*() const
        node_iterator(node_iterator&)
        node_iterator(node_iterator&&)
    cdef cppclass gdl_graph_t:  # ------------------------------------------------------------
        char* get_node_label(char* iobuf, int iobufsize, int n) const
        void print_graph_attributes(FILE* fp) const
        bint print_node(FILE* fp, int n) const
        bint print_edge(FILE* fp, int i, int j) const
        void print_node_attributes(FILE* fp, int n) const
        int size() const
        int node_qty() const
        bint exists(int node) const
        int entry() const
        int exit() const
        int nsucc(int node) const
        int npred(int node) const
        int succ(int node, int i) const
        int pred(int node, int i) const
        bint empty() const
        bgcolor_t get_node_color(int n) const
        bgcolor_t get_edge_color(int i, int j) const
        void gen_gdl(FILE* fp) const
        void gen_gdl(char* file) const
        size_t nedge(int node, bint ispred) const
        int edge(int node, int i, bint ispred) const
        int front()
        node_iterator begin() const
        node_iterator end() const
        bint path_exists(int m, int n) const  # does a path from 'm' to 'n' exist?
        void gen_dot(FILE* fp) const
        void gen_dot(char* file) const
        gdl_graph_t& operator=(gdl_graph_t&)
        gdl_graph_t(gdl_graph_t&)
    cdef cppclass cancellable_graph_t:
        bint cancelled
        bint check_cancel() const
        cancellable_graph_t(cancellable_graph_t&)
        cancellable_graph_t& operator=(cancellable_graph_t&)
    cdef cppclass qbasic_block_t:  # ------------------------------------------------------------
        intvec_t succ  # list of node successors
        intvec_t pred  # list of node predecessors
    cdef cppclass qflow_chart_t:  # A flow chart for a function, or a set of address ranges
        qstring title
        range_t bounds  # overall bounds of the qflow_chart_t instance
        func_t* pfn  # the function this instance was built upon
        int flags  # flags. See
        blocks_t blocks  # basic blocks
        int nproper  # number of basic blocks belonging to the specified 
        qflow_chart_t()
        qflow_chart_t(char* _title, func_t* _pfn, ea_t _ea1, ea_t _ea2, int _flags)
        void create(char* _title, func_t* _pfn, ea_t _ea1, ea_t _ea2, int _flags)
        void create(char* _title, rangevec_t& ranges, int _flags)
        void append_to_flowchart(ea_t ea1, ea_t ea2)
        void refresh()
        fc_block_type_t calc_block_type(size_t blknum) const
        bint is_ret_block(size_t blknum) const
        bint is_noret_block(size_t blknum) const
        void print_node_attributes(FILE* fp, int n) const
        int nsucc(int node) const
        int npred(int node) const
        int succ(int node, int i) const
        int pred(int node, int i) const
        char* get_node_label(char* iobuf, int iobufsize, int n) const
        int size() const
        bint print_names() const
        qflow_chart_t(qflow_chart_t&)
        qflow_chart_t& operator=(qflow_chart_t&)
    cdef cppclass linput_t:  # ------------------------------------------------------------
        pass
    cdef cppclass loader_t:  # Loader description block - must be exported from the loader 
        uint32 version  # api version, should be #IDP_INTERFACE_VERSION
        uint32 flags
    cdef cppclass load_info_t:  # ------------------------------------------------------------
        load_info_t* next
        qstring dllname
        qstring ftypename
        qstring processor  # desired processor name
        filetype_t ftype
        uint32 loader_flags  # copy of loader_t::flags
        uint32 lflags
        int pri  # 2-archldr, 1-place first, 0-normal priority
        bint is_archldr()  # @ }
    cdef cppclass impinfo_t:  # See ::importer_t
        char* dllname
        uval_t node
    cdef cppclass plugin_t:  # ------------------------------------------------------------
        int version  # Should be equal to #IDP_INTERFACE_VERSION
        int flags
        char* comment  # Long comment about the plugin. it could appear in 
        char* help  # Multiline help about the plugin
        char* wanted_name  # The preferred short name of the plugin
        char* wanted_hotkey  # The preferred hotkey to run the plugin
        plugin_t()
        plugin_t(plugin_t&)
        plugin_t(plugin_t&&)
    cdef cppclass idadll_t:
        void* entry  # first entry point of DLL
        idadll_t()
        bint is_loaded() const
    cdef cppclass idp_name_t:  # Processor name
        qstring lname  # long processor name
        qstring sname  # short processor name
        bint hidden  # is hidden
        idp_name_t()
    cdef cppclass idp_desc_t:  # Processor module description
        qstring path  # module file name
        qstring family  # processor's family
        idp_names_t names  # processor names
        bint is_script  # the processor module is a script
        bint checked  # internal, for cache management
        idp_desc_t()
    cdef cppclass plugin_info_t:  # ------------------------------------------------------------
        plugin_info_t* next  # next plugin information
        char* path  # full path to the plugin
        char* org_name  # original short name of the plugin
        char* name  # short name of the plugin it will appear in the men
        ushort org_hotkey  # original hotkey to run the plugin
        ushort hotkey  # current hotkey to run the plugin
        size_t arg  # argument used to call the plugin
        plugin_t* entry  # pointer to the plugin if it is already loaded
        idadll_t dllmem
        int flags  # a copy of plugin_t::flags
        char* comment  # a copy of plugin_t::comment
        qstring idaplg_name  # "name" provided by ida-plugin.json or basename of 
        plugin_info_t()
    cdef cppclass dbg_info_t:  # Information for the user interface about available debuggers
        plugin_info_t* pi
        debugger_t* dbg
        dbg_info_t(plugin_info_t* _pi, debugger_t* _dbg)
    cdef cppclass debugger_t
    cdef cppclass snapshot_t:  # Snapshot attributes
        int id  # snapshot ID. This value is computed using qgettime
        uint16 flags
        char filename  # snapshot file name
        snapshots_t children  # snapshot children
        bint operator==(snapshot_t& r) const
        bint operator!=(snapshot_t& r) const
        bint operator<(snapshot_t& r) const
        bint operator>(snapshot_t& r) const
        bint operator<=(snapshot_t& r) const
        bint operator>=(snapshot_t& r) const
        void clear()
        snapshot_t()
    cdef cppclass getname_info_t:  # Additional information for get_ea_name() function
        size_t cb  # size of this struct
        int32 inhibitor  # codes to inhibit parts of demangled name (see Usua
        int32 demform  # demangle only if
        int32 demcode  # out: return value of demangler
        getname_info_t()
        getname_info_t(getname_info_t&)
        getname_info_t(getname_info_t&&)
    cdef cppclass ea_name_t:  # ea, name pair
        ea_t ea
        qstring name
        ea_name_t()
        ea_name_t(ea_t _ea, qstring& _name)
    cdef cppclass til_bucket_t
    cdef cppclass til_stream_t
    cdef cppclass tinfo_changes_t
    cdef cppclass type_attr_t:  #  @ { Extended type attributes.
        qstring key  # one symbol keys are reserved to be used by the ker
        bytevec_t value  # attribute bytes
        bint operator<(type_attr_t& r) const
        bint operator>=(type_attr_t& r) const
    cdef cppclass til_t:  # ------------------------------------------------------------
        char* name  # short file name (without path and extension)
        char* desc  # human readable til description
        int nbases  # number of base tils
        til_t** base  # tils that our til is based on
        uint32 flags
        compiler_info_t cc  # information about the target compiler
        til_bucket_t* syms  # symbols
        til_bucket_t* types  # types
        til_bucket_t* macros  # macros
        int nrefs  # number of references to the til
        int nstreams  # number of extra streams
        til_stream_t** streams  # symbol stream storage
        bint is_dirty() const  # @ } Has the til been modified? (#TIL_MOD)
        void set_dirty()  # Mark the til as modified (#TIL_MOD)
        til_t* find_base(char* n)  # Find the base til with the provided name 
    cdef cppclass rrel_t:  # Register-relative argument location
        sval_t off  # displacement from the address pointed by the regis
        int reg  # register index (into {ph,processor_t,reg_names})
    cdef cppclass custloc_desc_t:  # Description of a custom argloc. Custom arglocs can be added 
        size_t cbsize  # size of this structure
        char* name  # name of the custom argloc type. must be unique
    cdef cppclass argloc_t:  # Describes an argument location. A typical argument is stored
        argloc_t()
        argloc_t(argloc_t& r)
        argloc_t& operator=(argloc_t& r)
        void swap(argloc_t& r)  # Assign this == r and r == this
        char* dstr() const
        argloc_type_t atype() const
        bint is_reg1() const
        bint is_reg2() const
        bint is_reg() const
        bint is_rrel() const
        bint is_ea() const
        bint is_stkoff() const
        bint is_scattered() const
        bint has_reg() const
        bint has_stkoff() const
        bint is_mixed_scattered() const
        bint in_stack() const
        bint is_fragmented() const
        bint is_custom() const
        bint is_badloc() const
        int reg1() const  # Get the register info. Use when atype() == ::ALOC_
        int regoff() const  # Get offset from the beginning of the register in b
        int reg2() const  # Get info for the second register. Use when atype()
        uint32 get_reginfo() const  # Get all register info. Use when atype() == ::ALOC_
        sval_t stkoff() const  # Get the stack offset. Use if atype() == ::ALOC_STA
        ea_t get_ea() const  # Get the global address. Use when atype() == ::ALOC
        scattered_aloc_t& scattered()  # Get scattered argument info. Use when atype() == :
        scattered_aloc_t& scattered() const
        rrel_t& get_rrel()  # Get register-relative info. Use when atype() == ::
        rrel_t& get_rrel() const
        void* get_custom() const  # Get custom argloc info. Use if atype() == ::ALOC_C
        biggest_t get_biggest() const  # Get largest element in internal union
        void _set_badloc()  # be careful with these functions, they do not clean
        void _set_reg1(int reg, int off)
        void _set_reg2(int _reg1, int _reg2)
        void _set_stkoff(sval_t off)
        void _set_ea(ea_t _ea)
        bint _consume_rrel(rrel_t* p)  # Use consume_rrel()
        bint _consume_scattered(scattered_aloc_t* p)  # Use consume_scattered()
        void _set_custom(argloc_type_t ct, void* pdata)  # Set custom argument location (careful - this funct
        void _set_biggest(argloc_type_t ct, biggest_t data)  # Set biggest element in internal union (careful - t
        void set_reg1(int reg, int off)  # Set register location
        void set_reg2(int _reg1, int _reg2)  # Set secondary register location
        void set_stkoff(sval_t off)  # Set stack offset location
        void set_ea(ea_t _ea)  # Set static ea location
        void consume_rrel(rrel_t* p)  # Set register-relative location - can't be nullptr
        void consume_scattered(scattered_aloc_t* p)  # Set distributed argument location
        void set_badloc()  # Set to invalid location
        sval_t calc_offset() const  # Calculate offset that can be used to compare 2 sim
        bint advance(int delta)  # Move the location to point 'delta' bytes further
        void align_reg_high(size_t size, size_t _slotsize)  # Set register offset to align it to the upper part 
        void align_stkoff_high(size_t size, size_t _slotsize)  # Set stack offset to align to the upper part of _SL
        bint operator==(argloc_t& r) const
        bint operator!=(argloc_t& r) const
        bint operator<(argloc_t& r) const
        bint operator>(argloc_t& r) const
        bint operator<=(argloc_t& r) const
        bint operator>=(argloc_t& r) const
        int compare(argloc_t& r) const
    cdef cppclass argpart_t:  # Subsection of an argument location
        ushort off  # offset from the beginning of the argument
        ushort size  # the number of bytes
        argpart_t(argloc_t& a)
        argpart_t()
        argpart_t& copy_from(argloc_t& a)
        bint bad_offset() const  # Does this argpart have a valid offset?
        bint bad_size() const  # Does this argpart have a valid size?
        bint operator<(argpart_t& r) const  # Compare two argparts, based on their offset
        void swap(argpart_t& r)  # Assign this = r and r = this
        argpart_t(argpart_t&)
        argpart_t(argpart_t&&)
        argpart_t& operator=(argpart_t&)
        argpart_t& operator=(argpart_t&&)
    cdef cppclass scattered_aloc_t:  # Used to manage arguments that are described by multiple loca
        pass
    cdef cppclass aloc_visitor_t:  # Visit all argument locations. The callback will not receive 
        int visit_location(argloc_t& v, int off, int size)
        aloc_visitor_t& operator=(aloc_visitor_t&)
    cdef cppclass const_aloc_visitor_t:  # Same as ::aloc_visitor_t, but may not modify the argloc
        int visit_location(argloc_t& v, int off, int size)
        const_aloc_visitor_t& operator=(const_aloc_visitor_t&)
    cdef cppclass stkarg_area_info_t:
        size_t cb
        sval_t stkarg_offset  # Offset from the SP to the first stack argument (ca
        sval_t shadow_size  # Size of the shadow area. explanations at: https://
        sval_t linkage_area  # Size of the linkage area. explanations at: https:/
        stkarg_area_info_t()
        stkarg_area_info_t(callcnv_t cc)
        bint get_info(callcnv_t cc)
    cdef cppclass custom_callcnv_t:  # ------------------------------------------------------------
        int cbsize
        uint64 flags
        qstring name  # the name is used as a keyword in the function prot
        uint32 abibits  # abibits to be used for the calling convention
        bint is_vararg() const
        bint is_purging() const
        bint is_usercall() const
        bint validate_func(func_type_data_t& fti, qstring* reterr) const  # Validate a function prototype. This function is us
        bint calc_retloc(func_type_data_t* fti) const  # Calculate the location of the return value. This f
        bint calc_arglocs(func_type_data_t* fti) const  # Calculate the argument locations. This function mu
        ssize_t find_varargs(func_type_data_t* fti, ea_t call_ea, mblock_t* blk) const  # Discover variadic arguments. This function is call
        bint calc_varglocs(func_type_data_t* fti, regobjs_t* regs, relobj_t* stkargs, int nfixed) const  # Calculate the argument locations for a variadic fu
        bint get_cc_regs(callregs_t* out) const  # Retrieve generic information about call registers
        bint get_stkarg_area_info(stkarg_area_info_t* out) const  # Retrieve generic information about stack arguments
        int calc_purged_bytes(func_type_data_t& fti, ea_t call_ea) const  # Calculate the number of purged bytes 
        bint decorate_name(qstring* outbuf, char* name, bint should_decorate, callcnv_t cc, tinfo_t& type) const  # Decorate a function name. Some compilers decorate 
        int lower_func_type(func_type_data_t* fti) const  # Lower a function type. See lower_type() for more e
        custom_callcnv_t()
        custom_callcnv_t(char* _name, uint64 f, uint32 _abibits)
        custom_callcnv_t& operator=(custom_callcnv_t&)
    cdef cppclass callregs_t:  # Register allocation calling convention. (allocation policy, 
        argreg_policy_t policy  # argument policy
        int nregs  # max number of registers that can be used in a call
        intvec_t gpregs  # array of gp registers (general purpose)
        intvec_t fpregs  # array of fp registers (floating point)
        callregs_t()  # Constructor
        callregs_t(callcnv_t cc)  # Constructor - initialize with the given request (s
        void swap(callregs_t& r)  # swap two instances
        bint init_regs(callcnv_t cc)  # Init policy & registers for given CC.
        bint by_slots() const  # policy-specific options
        void set(argreg_policy_t _policy, int* gprs, int* fprs)  # Init policy & registers (arrays are -1-terminated)
        void append_registers(reg_kind_t kind, int first_reg, int last_reg)
        void set_registers(reg_kind_t kind, int first_reg, int last_reg)
        void reset()  # Set policy and registers to invalid values
        int regcount(callcnv_t cc)  # Get max number of registers may be used in a funct
        int findreg(intvec_t& regs, int r)  # return index of register, -1 else
        bint reginds(int* gp_ind, int* fp_ind, int r) const  # Get register indexes within GP/FP arrays. (-1 -> i
    cdef cppclass tinfo_t:  # Primary mechanism for managing type information
        tinfo_t()  # Constructor
        tinfo_t(type_t decl_type)  # Constructor - can only be used to initialize simpl
        tinfo_t(char* decl, til_t* til, int pt_flags)  # Constructor - will attempt to parse the provided C
        tinfo_t(tinfo_t& r)  # Constructor
        tinfo_t& operator=(tinfo_t& r)  # Copy contents of given tinfo into this one
        void clear()  # Clear contents of this tinfo, and remove from the 
        void swap(tinfo_t& r)  # Assign this = r and r = this
        bint get_named_type(til_t* til, char* name, type_t decl_type, bint resolve, bint try_ordinal)  # Create a tinfo_t object for an existing named type
        bint get_named_type(char* name, type_t decl_type, bint resolve, bint try_ordinal)
        bint get_numbered_type(til_t* til, uint32 ordinal, type_t decl_type, bint resolve)  # Create a tinfo_t object for an existing ordinal ty
        bint get_numbered_type(uint32 ordinal, type_t decl_type, bint resolve)
        bint detach()  # Detach tinfo_t from the underlying type. After cal
        bint serialize(qtype* type, qtype* fields, qtype* fldcmts, int sudt_flags) const  # Serialize tinfo_t object into a type string.
        bint deserialize(til_t* til, type_t** ptype, p_list** pfields, p_list** pfldcmts, char* cmt)  # Deserialize a type string into a tinfo_t object
        bint deserialize(til_t* til, qtype* ptype, qtype* pfields, qtype* pfldcmts, char* cmt)
        bint is_correct() const  # Is the type object correct?. It is possible to cre
        type_t get_realtype(bint full) const  # Get the resolved base type. Deserialization option
        type_t get_decltype() const  # Get declared type (without resolving type referenc
        bint empty() const  # Was tinfo_t initialized with some type info or not
        bint present() const  # Is the type really present? (not a reference to a 
        size_t get_size(uint32* p_effalign, int gts_code) const  # Get the type size in bytes. 
        size_t get_unpadded_size() const  # Get the type size in bytes without the final paddi
        uint32 get_alignment() const  # Get type alignment This function returns the effec
        type_sign_t get_sign() const  # Get type sign
        bint is_signed() const  # Is this a signed type?
        bint is_unsigned() const  # Is this an unsigned type?
        uchar get_declalign() const  # Get declared alignment of the type
        bint is_typeref() const  # Is this type a type reference?.
        bint has_details() const  # Does this type refer to a nontrivial type?
        bint get_type_name(qstring* out) const  # Does a type refer to a name?. If yes, fill the pro
        bint get_nice_type_name(qstring* out) const  # Get the beautified type name. Get the referenced n
        tinfo_code_t rename_type(char* name, int ntf_flags)  # Rename a type 
        bint get_final_type_name(qstring* out) const  # Use in the case of typedef chain (TYPE1 -> TYPE2 -
        bint get_next_type_name(qstring* out) const  # Use In the case of typedef chain (TYPE1 -> TYPE2 -
        tid_t get_tid() const  # Get the type tid Each type in the local type libra
        tid_t force_tid()  # Get the type tid. Create if it does not exist yet.
        uint32 get_ordinal() const  # Get type ordinal (only if the type was created as 
        uint32 get_final_ordinal() const  # Get final type ordinal (0 if none)
        til_t* get_til() const  # Get the type library for tinfo_t
        bint is_from_subtil() const  # Was the named type found in some base type library
        bint is_forward_decl() const  # Is this a forward declaration?. Forward declaratio
        type_t get_forward_type() const  # Get type of a forward declaration. For a forward d
        bint is_forward_struct() const
        bint is_forward_union() const
        bint is_forward_enum() const
        bint is_typedef() const  # Is this a typedef?. This function will return true
        int get_type_cmt(qstring* out) const  # Get type comment 
        bint get_type_rptcmt(qstring* out) const  # Get type comment only if it is repeatable
        bint is_decl_const() const
        bint is_decl_volatile() const
        bint is_decl_void() const
        bint is_decl_partial() const
        bint is_decl_unknown() const
        bint is_decl_last() const
        bint is_decl_ptr() const
        bint is_decl_array() const
        bint is_decl_func() const
        bint is_decl_complex() const
        bint is_decl_typedef() const
        bint is_decl_sue() const
        bint is_decl_struct() const
        bint is_decl_union() const
        bint is_decl_udt() const
        bint is_decl_enum() const
        bint is_decl_bitfield() const
        bint is_decl_int128() const
        bint is_decl_int64() const
        bint is_decl_int32() const
        bint is_decl_int16() const
        bint is_decl_int() const
        bint is_decl_char() const
        bint is_decl_uint() const
        bint is_decl_uchar() const
        bint is_decl_uint16() const
        bint is_decl_uint32() const
        bint is_decl_uint64() const
        bint is_decl_uint128() const
        bint is_decl_ldouble() const
        bint is_decl_double() const
        bint is_decl_float() const
        bint is_decl_tbyte() const
        bint is_decl_floating() const
        bint is_decl_bool() const
        bint is_decl_paf() const
        bint is_well_defined() const
        bint is_const() const  # Probe the resolved type for various attributes:
        bint is_volatile() const
        bint is_void() const
        bint is_partial() const
        bint is_unknown() const
        bint is_ptr() const
        bint is_array() const
        bint is_func() const
        bint is_complex() const
        bint is_struct() const
        bint is_union() const
        bint is_udt() const
        bint is_enum() const
        bint is_sue() const
        bint is_bitfield() const
        bint is_int128() const
        bint is_int64() const
        bint is_int32() const
        bint is_int16() const
        bint is_int() const
        bint is_char() const
        bint is_uint() const
        bint is_uchar() const
        bint is_uint16() const
        bint is_uint32() const
        bint is_uint64() const
        bint is_uint128() const
        bint is_ldouble() const
        bint is_double() const
        bint is_float() const
        bint is_tbyte() const
        bint is_bool() const
        bint is_paf() const
        bint is_ptr_or_array() const
        bint is_integral() const
        bint is_ext_integral() const
        bint is_floating() const
        bint is_arithmetic() const
        bint is_ext_arithmetic() const
        bint is_scalar() const  # Does the type represent a single number?
        bint get_ptr_details(ptr_type_data_t* pi) const  # Get the pointer info.
        bint get_array_details(array_type_data_t* ai) const  # Get the array specific info
        bint get_enum_details(enum_type_data_t* ei) const  # Get the enum specific info
        bint get_bitfield_details(bitfield_type_data_t* bi) const  # Get the bitfield specific info
        bint get_udt_details(udt_type_data_t* udt, gtd_udt_t gtd) const  # Get the udt specific info
        bint get_func_details(func_type_data_t* fi, gtd_func_t gtd) const  # Get only the function specific info for this tinfo
        bint is_funcptr() const  # Is this pointer to a function?
        bint is_shifted_ptr() const  # Is a shifted pointer?
        bint is_varstruct() const  # Is a variable-size structure?
        bint is_varmember() const  # Can the type be of a variable struct member? This 
        int get_ptrarr_objsize() const  # ::BT_PTR & ::BT_ARRAY: get size of pointed object 
        tinfo_t get_ptrarr_object() const  # ::BT_PTR & ::BT_ARRAY: get the pointed object or a
        tinfo_t get_pointed_object() const  # ::BT_PTR: get type of pointed object. If the curre
        bint is_pvoid() const  # Is "void *"?. This function does not check the poi
        bint is_punknown() const  # Is "_UNKNOWN *"?. This function does not check the
        tinfo_t get_array_element() const  # ::BT_ARRAY: get type of array element. See also ge
        tinfo_t get_final_element() const  # repeat recursively: if an array, return the type o
        int get_array_nelems() const  # ::BT_ARRAY: get number of elements (-1 means error
        tinfo_t get_nth_arg(int n) const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get type of n-th 
        tinfo_t get_rettype() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get the function'
        int get_nargs() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Calculate number 
        callcnv_t get_cc() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get calling conve
        bint is_user_cc() const
        bint is_vararg_cc() const
        bint is_purging_cc() const
        int calc_purged_bytes() const  # ::BT_FUNC: Calculate number of purged bytes
        bint is_high_func() const  # ::BT_FUNC: Is high level type?
        bint get_methods(udtmembervec_t* methods) const  # ::BT_COMPLEX: get a list of member functions decla
        bint get_bit_buckets(range64vec_t* buckets) const  # ::BT_STRUCT: get bit buckets Bit buckets are used 
        int find_udm(udm_t* udm, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find a udt member. - at 
        int find_udm(uint64 offset, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find an udt member at th
        int find_udm(char* name, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find an udt member by na
        int get_udm(udm_t* out, char* name) const  # Retrieve a structure/union member with the specifi
        int get_udm(udm_t* out, size_t index) const  # Retrieve a structure/union member with the specifi
        int get_udm_by_offset(udm_t* out, uint64 offset) const  # Retrieve a structure/union member with the specifi
        int get_udt_nmembers() const  # Get number of udt members. -1-error
        bint is_empty_udt() const  # Is an empty struct/union? (has no fields)
        bint is_small_udt() const  # Is a small udt? (can fit a register or a pair of r
        uint32 get_udt_taudt_bits() const  # Get udt_type_data_t::taudt_bits
        bint is_unaligned_struct() const  # Is an unaligned struct
        bint is_msstruct() const  # Is gcc msstruct attribute applied
        bint is_cpp_struct() const  # Is a c++ object, not simple pod type
        bint is_vftable() const  # Is a vftable type?
        bint is_fixed_struct() const  # Is a structure with fixed offsets?
        bint is_tuple() const  # Is a tuple?
        bint requires_qualifier(qstring* out, char* name, uint64 offset) const  # Requires full qualifier? (name is not unique) 
        bint append_covered(rangeset_t* out, uint64 offset) const  # Calculate set of covered bytes for the type 
        bint calc_gaps(rangeset_t* out) const  # Calculate set of padding bytes for the type 
        bint is_one_fpval() const  # Floating value or an object  consisting of one flo
        bint is_sse_type() const  # Is a SSE vector type?
        bint is_anonymous_udt() const  # Is an anonymous struct/union? We assume that types
        bint has_vftable() const  # Has a vftable?
        bint has_union() const  # Has a member of type "union"?
        size_t get_enum_nmembers() const  # Get number of enum members. 
        bint is_empty_enum() const  # Is an empty enum? (has no constants)
        type_t get_enum_base_type() const  # Get enum base type (convert enum to integer type) 
        bint is_bitmask_enum() const  # Is bitmask enum? 
        int get_enum_radix() const  # Get enum constant radix 
        tinfo_code_t get_enum_repr(value_repr_t* repr) const  # Set the representation of enum members. 
        int get_enum_width() const  # Get enum width 
        uint64 calc_enum_mask() const
        ssize_t get_edm(edm_t* out, char* name) const  # Get enum member by its name 
        tinfo_code_t get_edm(edm_t* edm, size_t idx) const  # Get enum member by its index 
        ssize_t get_edm_by_value(edm_t* out, uint64 value, bmask64_t bmask, uchar serial) const  # Get enum member by its value 
        tid_t get_edm_tid(size_t idx) const  # Get enum member TID 
        tinfo_t get_onemember_type() const  # For objects consisting of one member entirely: ret
        tinfo_t get_innermost_udm(uint64 bitoffset, size_t* out_index, uint64* out_bitoffset) const  # Get the innermost member at the given offset 
        tinfo_t get_innermost_member_type(uint64 bitoffset, uint64* out_bitoffset) const  # Get the innermost member type at the given offset 
        uint32 calc_score() const  # Calculate the type score (the higher - the nicer i
        bint print(qstring* out, char* name, int prtype_flags, int indent, int cmtindent, char* prefix, char* cmt) const  # Get a C-like string representation of the type. 
        char* dstr() const  # Function to facilitate debugging
        bint get_attrs(type_attrs_t* tav, bint all_attrs) const  # Get type attributes (all_attrs: include attributes
        bint get_attr(qstring& key, bytevec_t* bv, bint all_attrs) const  # Get a type attribute
        bint set_attrs(type_attrs_t* tav)  # Set type attributes. If necessary, a new typid wil
        bint set_attr(type_attr_t& ta, bint may_overwrite)  # Set a type attribute. If necessary, a new typid wi
        void del_attrs()  # Del all type attributes. typerefs cannot be modifi
        bint del_attr(qstring& key, bint make_copy)  # Del a type attribute. typerefs cannot be modified 
        bint create_simple_type(type_t decl_type)
        bint create_ptr(ptr_type_data_t& p, type_t decl_type)
        bint create_array(array_type_data_t& p, type_t decl_type)
        bint create_bitfield(bitfield_type_data_t& p, type_t decl_type)
        bint create_typedef(typedef_type_data_t& p, type_t decl_type, bint try_ordinal)
        bint create_ptr(tinfo_t& tif, uchar bps, type_t decl_type)  #  @ {
        bint create_array(tinfo_t& tif, uint32 nelems, uint32 base, type_t decl_type)
        void create_typedef(til_t* til, char* name, type_t decl_type, bint try_ordinal)
        void create_typedef(til_t* til, uint ord, type_t decl_type)
        bint create_bitfield(uchar nbytes, uchar width, bint is_unsigned, type_t decl_type)
        bint parse(char* decl, til_t* til, int pt_flags)  # Convenience function to parse a string with a type
        bint create_udt(bint is_union)  # Create an empty structure/union
        bint create_enum(bte_t bte)  # Create an empty enum
        bint create_udt(udt_type_data_t& p)  #  These functions consume 'p' (make it empty) @ {
        bint create_udt(udt_type_data_t& p, type_t decl_type)
        bint create_enum(enum_type_data_t& p, type_t decl_type)
        bint create_func(func_type_data_t& p, type_t decl_type)
        ssize_t get_udm_by_tid(udm_t* udm, tid_t tid)  # Retrive tinfo using type TID or struct/enum member
        ssize_t get_edm_by_tid(edm_t* edm, tid_t tid)
        bint get_type_by_tid(tid_t tid)
        ssize_t get_by_edm_name(char* mname, til_t* til)  # Retrieve enum tinfo using enum member name 
        tinfo_code_t set_named_type(til_t* til, char* name, int ntf_flags)  #  Store the type info in the type library as a name
        tinfo_code_t set_symbol_type(til_t* til, char* name, int ntf_flags)
        tinfo_code_t set_numbered_type(til_t* til, uint32 ord, int ntf_flags, char* name)
        tinfo_code_t save_type(int ntf_flags)
        tinfo_code_t copy_type(til_t* til, char* name, int ntf_flags)
        tinfo_code_t create_forward_decl(til_t* til, type_t decl_type, char* name, int ntf_flags)  # Create a forward declaration. decl_type: ::BTF_STR
        tinfo_t get_stock(stock_type_id_t id)  # Get stock type information. This function can be u
        bint convert_array_to_ptr()  # Convert an array into a pointer. type[] => type *
        bint remove_ptr_or_array()  # Replace the current type with the ptr obj or array
        uint64 read_bitfield_value(uint64 v, int bitoff) const  #  Helper functions to store/extract bitfield values
        uint64 write_bitfield_value(uint64 dst, uint64 v, int bitoff) const
        type_t get_modifiers() const  #  Work with type modifiers: const and volatile @ {
        void set_modifiers(type_t mod)
        void set_const()
        void set_volatile()
        void clr_decl_const_volatile()  # remove modifiers for trivial types, without resolv
        bint clr_const()  # remove modifiers from non-trivial types. for examp
        bint clr_volatile()
        bint clr_const_volatile()
        tinfo_code_t set_type_alignment(uchar declalign, uint etf_flags)  # Set type alignment
        bint set_declalign(uchar declalign)
        bint change_sign(type_sign_t sign)  # Change the type sign. Works only for the types tha
        bint calc_udt_aligns(int sudt_flags)  # Calculate the udt alignments using the field offse
        bint set_methods(udtmembervec_t& methods)  # ::BT_COMPLEX: set the list of member functions. Th
        tinfo_code_t set_type_cmt(char* cmt, bint is_regcmt, uint etf_flags)  # Set type comment This function works only for non-
        uint32 get_alias_target() const  # Get type alias If the type has no alias, return 0.
        bint is_aliased() const
        bint set_type_alias(uint32 dest_ord)  # Set type alias Redirects all references to source 
        tinfo_code_t set_udt_alignment(int sda, uint etf_flags)  # Set declared structure alignment (sda) This alignm
        tinfo_code_t set_udt_pack(int pack, uint etf_flags)  # Set structure packing. The value controls how litt
        tid_t get_udm_tid(size_t idx) const  # Get udt member TID 
        tinfo_code_t add_udm(udm_t& udm, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. 
        tinfo_code_t add_udm(char* name, tinfo_t& type, uint64 offset, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. The member's size wi
        tinfo_code_t add_udm(char* name, type_t type, uint64 offset, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. The member's type wi
        tinfo_code_t add_udm(char* name, char* type, uint64 offset, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. The member's type wi
        tinfo_code_t del_udm(size_t index, uint etf_flags)  # Delete a structure/union member.
        tinfo_code_t del_udms(size_t idx1, size_t idx2, uint etf_flags)  # Delete structure/union members in the range [idx1,
        tinfo_code_t rename_udm(size_t index, char* name, uint etf_flags)  # Rename a structure/union member. The new name must
        tinfo_code_t set_udm_type(size_t index, tinfo_t& tif, uint etf_flags, value_repr_t* repr)  # Set type of a structure/union member. 
        tinfo_code_t set_udm_cmt(size_t index, char* cmt, bint is_regcmt, uint etf_flags)  # Set a comment for a structure/union member. A memb
        tinfo_code_t set_udm_repr(size_t index, value_repr_t& repr, uint etf_flags)  # Set the representation of a structure/union member
        bint is_udm_by_til(size_t idx) const  # Was the member created due to the type system 
        tinfo_code_t set_udm_by_til(size_t idx, bint on, uint etf_flags)  # The member is created due to the type system 
        tinfo_code_t set_fixed_struct(bint on)  # Declare struct member offsets as fixed. For such s
        tinfo_code_t set_struct_size(size_t new_size)  # Explicitly specify the struct size. This function 
        tinfo_code_t expand_udt(size_t idx, adiff_t delta, uint etf_flags)  # Expand/shrink a structure by adding/removing a gap
        tinfo_code_t set_tuple(bint on)  # Declare struct as a tuple. Currently, tuples in ID
        bint get_func_frame(func_t* pfn)  # Create a tinfo_t object for the function frame 
        bint is_frame() const  # Is a function frame?
        ea_t get_frame_func() const  # Get function address for the frame
        ssize_t get_stkvar(sval_t* actval, insn_t& insn, op_t* x, sval_t v)  # Retrieve frame tinfo for a stack variable 
        tinfo_code_t set_enum_width(int nbytes, uint etf_flags)  # Set the width of enum base type 
        tinfo_code_t set_enum_sign(type_sign_t sign, uint etf_flags)  # Set enum sign 
        tinfo_code_t set_enum_is_bitmask(bitmask_cvt_stance_t stance, uint etf_flags)
        tinfo_code_t set_enum_repr(value_repr_t& repr, uint etf_flags)  # Set the representation of enum members. 
        tinfo_code_t set_enum_radix(int radix, bint sign, uint etf_flags)  # Set enum radix to display constants 
        tinfo_code_t add_edm(edm_t& edm, bmask64_t bmask, uint etf_flags, ssize_t idx)  # Add a new enum member (a new symbolic constant) 
        tinfo_code_t add_edm(char* name, uint64 value, bmask64_t bmask, uint etf_flags, ssize_t idx)  # Add a new enum member (a new symbolic constant) 
        tinfo_code_t del_edms(size_t idx1, size_t idx2, uint etf_flags)  # Delete enum members 
        tinfo_code_t del_edm(size_t idx, uint etf_flags)
        tinfo_code_t del_edm(char* name, uint etf_flags)  # Delete enum member by its name 
        tinfo_code_t del_edm_by_value(uint64 value, uint etf_flags, bmask64_t bmask, uchar serial)  # Delete enum member by its value 
        tinfo_code_t rename_edm(size_t idx, char* name, uint etf_flags)  # Rename a enum member 
        tinfo_code_t set_edm_cmt(size_t idx, char* cmt, uint etf_flags)  # Set a comment for an enum member. Such comments ar
        tinfo_code_t edit_edm(size_t idx, uint64 value, bmask64_t bmask, uint etf_flags)  # Change constant value and/or bitmask 
        tinfo_code_t rename_funcarg(size_t index, char* name, uint etf_flags)  # Rename a function argument. The new name must be u
        tinfo_code_t set_funcarg_type(size_t index, tinfo_t& tif, uint etf_flags)  # Set type of a function argument. 
        tinfo_code_t set_func_rettype(tinfo_t& tif, uint etf_flags)  # Set function return type . 
        tinfo_code_t del_funcargs(size_t idx1, size_t idx2, uint etf_flags)  # Delete function arguments 
        tinfo_code_t del_funcarg(size_t idx, uint etf_flags)
        tinfo_code_t add_funcarg(funcarg_t& farg, uint etf_flags, ssize_t idx)  # Add a function argument. 
        tinfo_code_t set_func_cc(callcnv_t cc, uint etf_flags)  # Set function calling convention
        tinfo_code_t set_funcarg_loc(size_t index, argloc_t& argloc, uint etf_flags)  # Set location of a function argument. 
        tinfo_code_t set_func_retloc(argloc_t& argloc, uint etf_flags)  # Set location of function return value. 
        bint operator==(tinfo_t& r) const
        bint operator!=(tinfo_t& r) const
        bint operator<(tinfo_t& r) const
        bint operator>(tinfo_t& r) const
        bint operator<=(tinfo_t& r) const
        bint operator>=(tinfo_t& r) const
        int compare(tinfo_t& r) const
        bint compare_with(tinfo_t& r, int tcflags) const  # @ } Compare two types, based on given flags (see
        bint equals_to(tinfo_t& r) const
        bint is_castable_to(tinfo_t& target) const
        bint is_manually_castable_to(tinfo_t& target) const
    cdef cppclass simd_info_t:  # ------------------------------------------------------------
        char* name  # name of SIMD type (nullptr-undefined)
        tinfo_t tif  # SIMD type (empty-undefined)
        uint16 size  # SIMD type size in bytes (0-undefined)
        type_t memtype  # member type BTF_INT8/16/32/64/128, BTF_UINT8/16/32
        simd_info_t(char* nm, uint16 sz, type_t memt)
        bint match_pattern(simd_info_t* pattern)
        simd_info_t(simd_info_t&)
        simd_info_t(simd_info_t&&)
        simd_info_t& operator=(simd_info_t&)
        simd_info_t& operator=(simd_info_t&&)
    cdef cppclass ptr_type_data_t:  # ------------------------------------------------------------
        tinfo_t obj_type  # pointed object type
        tinfo_t closure  # cannot have both closure and based_ptr_size
        tinfo_t parent  # Parent struct
        int32 delta  # Offset from the beginning of the parent struct
        uchar based_ptr_size
        uchar taptr_bits  # TAH bits
        ptr_type_data_t(tinfo_t c, uchar bps, tinfo_t p, int32 d)
        void swap(ptr_type_data_t& r)
        bint operator==(ptr_type_data_t& r) const
        bint operator!=(ptr_type_data_t& r) const
        bint is_code_ptr() const
        bint is_shifted() const
        ptr_type_data_t(ptr_type_data_t&)
        ptr_type_data_t(ptr_type_data_t&&)
        ptr_type_data_t& operator=(ptr_type_data_t&)
        ptr_type_data_t& operator=(ptr_type_data_t&&)
    cdef cppclass array_type_data_t:  # ------------------------------------------------------------
        tinfo_t elem_type  # element type
        uint32 base  # array base
        uint32 nelems  # number of elements
        array_type_data_t(size_t b, size_t n)
        void swap(array_type_data_t& r)
        array_type_data_t(array_type_data_t&)
        array_type_data_t(array_type_data_t&&)
        array_type_data_t& operator=(array_type_data_t&)
        array_type_data_t& operator=(array_type_data_t&&)
    cdef cppclass funcarg_t:  # ------------------------------------------------------------
        argloc_t argloc  # argument location
        qstring name  # argument name (may be empty)
        qstring cmt  # argument comment (may be empty)
        tinfo_t type  # argument type
        uint32 flags
        funcarg_t()  # @ }
        funcarg_t(char* _name, tinfo_t& _type, argloc_t& _argloc)  # Create a function argument, with the specified nam
        funcarg_t(char* _name, type_t _type, argloc_t& _argloc)  # Create a function argument, with the specified nam
        funcarg_t(char* _name, char* _type, argloc_t& _argloc)  # Create a function argument, with the specified nam
        bint operator==(funcarg_t& r) const
        bint operator!=(funcarg_t& r) const
        funcarg_t(funcarg_t&)
        funcarg_t(funcarg_t&&)
        funcarg_t& operator=(funcarg_t&)
        funcarg_t& operator=(funcarg_t&&)
    cdef cppclass func_type_data_t:  # Function type information (see tinfo_t::get_func_details())
        int flags
        callcnv_t _new_callcnv  # Do not access directly, use get_cc/set_cc
        tinfo_t rettype  # return type
        argloc_t retloc  # return location
        uval_t stkargs  # size of stack arguments (not used in build_func_ty
        reginfovec_t spoiled  # spoiled register information. if spoiled register 
        cm_t _old_cc  # calling convention, legacy codes. do not access
        callcnv_t get_explicit_cc() const
        callcnv_t get_cc() const
        void set_cc(callcnv_t cc)
        void swap(func_type_data_t& r)
        bint is_high() const
        bint is_noret() const
        bint is_pure() const
        bint is_static() const
        bint is_virtual() const
        bint is_const() const
        bint is_ctor() const
        bint is_dtor() const
        int get_call_method() const
        bint is_vararg_cc() const
        bint is_golang_cc() const
        bint is_swift_cc() const
        bint is_user_cc() const
        callcnv_t guess_cc(int purged, int cc_flags) const  # Guess function calling convention use the followin
        bint dump(qstring* out, int praloc_bits) const  # Dump information that is not always visible in the
        ssize_t find_argument(char* name, size_t from_, size_t to) const  # find argument by name
        func_type_data_t(func_type_data_t&)
        func_type_data_t(func_type_data_t&&)
        func_type_data_t& operator=(func_type_data_t&)
        func_type_data_t& operator=(func_type_data_t&&)
        func_type_data_t()
    cdef cppclass edm_t:  # ------------------------------------------------------------
        qstring name
        qstring cmt  # repeatable comment
        uint64 value
        edm_t()
        edm_t(char* _name, uint64 _value, char* _cmt)  # Create an enumeration value with the specified nam
        bint empty() const  # a enum constant must at least have a name
        bint operator==(edm_t& r) const
        bint operator!=(edm_t& r) const
        void swap(edm_t& r)
        tid_t get_tid() const
        edm_t(edm_t&)
        edm_t(edm_t&&)
    cdef cppclass enum_type_data_t:  # Enum type information (see tinfo_t::get_enum_details())
        intvec_t group_sizes  # if present, specifies bitmask group sizes each non
        uint32 taenum_bits
        bte_t bte  # enum member sizes (shift amount) and style. do not
        enum_type_data_t(bte_t _bte)
        int get_enum_radix() const  # How the enum members should be printed in the enum
        bint is_number_signed() const
        void set_enum_radix(int radix, bint sign)  # Set radix to display constants 
        bint is_char() const
        bint is_dec() const
        bint is_hex() const
        bint is_oct() const
        bint is_bin() const
        bint is_udec() const
        bint is_shex() const
        bint is_soct() const
        bint is_sbin() const
        bint has_lzero() const
        void set_lzero(bint on)
        uint64 calc_mask() const
        bint store_64bit_values() const
        bint is_bf() const  # is bitmask or ordinary enum?
        int calc_nbytes() const  # get the width of enum in bytes
        bint set_nbytes(int nbytes)  # set enum width (nbytes)
        bint get_constant_group(size_t* group_start_index, size_t* group_size, size_t idx) const  # get group parameters for the constant, valid for b
        bint is_group_mask_at(size_t idx) const  # is the enum member at IDX a non-trivial group mask
        bint is_valid_group_sizes() const  # is valid group sizes
        ssize_t find_member(char* name, size_t from_, size_t to) const  # find member (constant or bmask) by name
        ssize_t find_member(uint64 value, uchar serial, size_t from_, size_t to, uint64 vmask) const  # find member (constant or bmask) by value
        void swap(enum_type_data_t& r)  # swap two instances
        void add_constant(char* name, uint64 value, char* cmt)  # add constant for regular enum
        tinfo_code_t get_value_repr(value_repr_t* repr) const  # get enum radix and other representation info 
        tinfo_code_t set_value_repr(value_repr_t& repr)  # set enum radix and other representation info 
        uchar get_serial(size_t index) const  # returns serial for the constant
        uchar get_max_serial(uint64 value) const  # return the maximum serial for the value
        enum_type_data_t(enum_type_data_t&)
        enum_type_data_t(enum_type_data_t&&)
    cdef cppclass typedef_type_data_t:  # ------------------------------------------------------------
        til_t* til  # type library to use when resolving
        char* name  # is_ordref=false: target type name. we do not own t
        uint32 ordinal  # is_ordref=true: type ordinal number
        bint is_ordref  # is reference by ordinal?
        bint resolve  # should resolve immediately?
        typedef_type_data_t(til_t* _til, char* _name, bint _resolve)
        typedef_type_data_t(til_t* _til, uint32 ord, bint _resolve)
        void swap(typedef_type_data_t& r)
        typedef_type_data_t(typedef_type_data_t&)
        typedef_type_data_t(typedef_type_data_t&&)
    cdef cppclass custom_data_type_info_t:  # ------------------------------------------------------------
        int16 dtid  # data type id
        int16 fid  # data format ids
        custom_data_type_info_t& operator=(custom_data_type_info_t&)
        custom_data_type_info_t& operator=(custom_data_type_info_t&&)
    cdef cppclass value_repr_t:  # Visual representation of a member of a complex type (struct/
        uint64 bits
        refinfo_t ri  # FRB_OFFSET
        int32 strtype  # FRB_STRLIT
        custom_data_type_info_t cd  # FRB_CUSTOM
        array_parameters_t ap  # FRB_TABFORM, AP_SIGNED is ignored, use FRB_SIGNED 
        void swap(value_repr_t& r)
        void clear()
        bint empty() const
        bint is_enum() const
        bint is_offset() const
        bint is_strlit() const
        bint is_custom() const
        bint is_stroff() const
        bint is_typref() const
        bint is_signed() const
        bint has_tabform() const
        bint has_lzeroes() const
        uint64 get_vtype() const
        void set_vtype(uint64 vt)
        void set_signed(bint on)
        void set_tabform(bint on)
        void set_lzeroes(bint on)
        void set_ap(array_parameters_t& _ap)
        void init_ap(array_parameters_t* _ap) const
        bint from_opinfo(flags64_t flags, aflags_t afl, opinfo_t* opinfo, array_parameters_t* _ap)
        size_t print(qstring* result, bint colored) const
        bint parse_value_repr(qstring& attr, type_t target_type)
        value_repr_t& operator=(value_repr_t&)
        value_repr_t& operator=(value_repr_t&&)
    cdef cppclass udm_t:  # ------------------------------------------------------------
        uint64 offset  # member offset in bits
        uint64 size  # size in bits
        qstring name  # member name
        qstring cmt  # member comment
        tinfo_t type  # member type
        value_repr_t repr  # radix, refinfo, strpath, custom_id, strtype
        int effalign  # effective field alignment (in bytes)
        uint32 tafld_bits  # TAH bits
        uchar fda  # field alignment (shift amount)
        udm_t()
        udm_t(char* _name, tinfo_t& _type, uint64 _offset)  # Create a structure/union member, with the specifie
        udm_t(char* _name, type_t _type, uint64 _offset)  # Create a structure/union member, with the specifie
        udm_t(char* _name, char* _type, uint64 _offset)  # Create a structure/union member, with the specifie
        bint empty() const  # a udt member must at least have a type
        bint is_bitfield() const
        bint is_zero_bitfield() const
        bint is_unaligned() const
        bint is_baseclass() const
        bint is_virtbase() const
        bint is_vftable() const
        bint is_method() const
        bint is_gap() const
        bint is_regcmt() const
        bint is_retaddr() const
        bint is_savregs() const
        bint is_special_member() const
        bint is_by_til() const
        void set_unaligned(bint on)
        void set_baseclass(bint on)
        void set_virtbase(bint on)
        void set_vftable(bint on)
        void set_method(bint on)
        void set_regcmt(bint on)
        void set_retaddr(bint on)
        void set_savregs(bint on)
        void set_by_til(bint on)
        void clr_unaligned()
        void clr_baseclass()
        void clr_virtbase()
        void clr_vftable()
        void clr_method()
        uint64 begin() const
        uint64 end() const
        bint operator<(udm_t& r) const
        bint operator==(udm_t& r) const
        bint compare_with(udm_t& r, int tcflags) const
        bint operator!=(udm_t& r) const
        void swap(udm_t& r)
        bint is_anonymous_udm() const  # the user cannot enter anonymous fields in ida (the
        void set_value_repr(value_repr_t& r)
        bint can_be_dtor() const
        bint can_rename() const
        udm_t(udm_t&)
        udm_t(udm_t&&)
        udm_t& operator=(udm_t&)
        udm_t& operator=(udm_t&&)
    cdef cppclass udtmembervec_t:
        udtmembervec_t(udtmembervec_t&)
        udtmembervec_t(udtmembervec_t&&)
    cdef cppclass udt_type_data_t:
        size_t total_size  # total structure size in bytes
        size_t unpadded_size  # unpadded structure size in bytes
        uint32 effalign  # effective structure alignment (in bytes)
        uint32 taudt_bits  # TA... and TAUDT... bits
        uchar version  # version of udt_type_data_t
        uchar sda  # declared structure alignment (shift amount+1). 0 -
        uchar pack  # #pragma pack() alignment (shift amount)
        bint is_union  # is union or struct?
        void swap(udt_type_data_t& r)
        bint is_unaligned() const
        bint is_msstruct() const
        bint is_cppobj() const
        bint is_vftable() const
        bint is_fixed() const
        bint is_tuple() const
        void set_vftable(bint on)
        void set_fixed(bint on)
        void set_tuple(bint on)
        bint is_last_baseclass(size_t idx)
        udm_t& add_member(char* _name, tinfo_t& _type, uint64 _offset)  # Add a new member to a structure or union. This fun
        ssize_t find_member(udm_t* pattern_udm, int strmem_flags) const  #  
        ssize_t find_member(char* name) const
        ssize_t find_member(uint64 bit_offset) const
        ssize_t get_best_fit_member(asize_t disp) const  # Get the member that is most likely referenced by t
        ssize_t get_best_fit_member(udm_t* out, asize_t disp) const  # Get the member that is most likely referenced by t
        udt_type_data_t()
        udt_type_data_t(udt_type_data_t&)
        udt_type_data_t(udt_type_data_t&&)
    cdef cppclass udm_visitor_t:  # ------------------------------------------------------------
        int visit_udm(tid_t tid, tinfo_t* tif, udt_type_data_t* udt, ssize_t idx)
        udm_visitor_t& operator=(udm_visitor_t&)
    cdef cppclass bitfield_type_data_t:  # ------------------------------------------------------------
        uchar nbytes  # enclosing type size (1,2,4,8 bytes)
        uchar width  # number of bits
        bint is_unsigned  # is bitfield unsigned?
        bitfield_type_data_t(uchar _nbytes, uchar _width, bint _is_unsigned)
        bint serialize(qtype* type, type_t mods) const
        bint operator==(bitfield_type_data_t& r) const
        bint operator!=(bitfield_type_data_t& r) const
        bint operator<(bitfield_type_data_t& r) const
        bint operator>(bitfield_type_data_t& r) const
        bint operator<=(bitfield_type_data_t& r) const
        bint operator>=(bitfield_type_data_t& r) const
        int compare(bitfield_type_data_t& r) const
        void swap(bitfield_type_data_t& r)
        bint is_valid_bitfield() const
        bitfield_type_data_t(bitfield_type_data_t&)
        bitfield_type_data_t(bitfield_type_data_t&&)
    cdef cppclass type_mods_t:  # Information about how to modify the current type, used by ::
        tinfo_t type  # current type
        qstring name  # current type name
        qstring cmt  # comment for current type
        int flags
        void clear()  # @ }
        void set_new_type(tinfo_t& t)  # The visit_type() function may optionally save the 
        void set_new_name(qstring& n)
        void set_new_cmt(qstring& c, bint rptcmt)
        bint has_type() const
        bint has_name() const
        bint has_cmt() const
        bint is_rptcmt() const
        bint has_info() const
        type_mods_t(type_mods_t&)
        type_mods_t(type_mods_t&&)
        type_mods_t& operator=(type_mods_t&)
        type_mods_t& operator=(type_mods_t&&)
    cdef cppclass tinfo_visitor_t:  # Visit all subtypes of a type. Derive your visitor from this 
        int state
        int level  # recursion level (internal use)
        tinfo_visitor_t(int s)
        int visit_type(type_mods_t* out, tinfo_t& tif, char* name, char* cmt)  # Visit a subtype. this function must be implemented
        void prune_now()  # To refuse to visit children of the current type, u
        int apply_to(tinfo_t& tif, type_mods_t* out, char* name, char* cmt)  # Call this function to initiate the traversal
        tinfo_visitor_t& operator=(tinfo_visitor_t&)
    cdef cppclass regobj_t:  # Object that represents a register
        int regidx  # index into dbg->registers
        int relocate  # 0-plain num, 1-must relocate
        bytevec_t value
        size_t size() const
    cdef cppclass regobjs_t:
        pass
    cdef cppclass argtinfo_helper_t:  # ------------------------------------------------------------
        size_t reserved
        bint set_op_tinfo(insn_t& insn, op_t& x, tinfo_t& tif, char* name)  # Set the operand type as specified
        bint is_stkarg_load(insn_t& insn, int* src, int* dst)  # Is the current insn a stkarg load?. if yes: - src:
        bint has_delay_slot(ea_t)  # The call instruction with a delay slot?.
        void use_arg_tinfos(ea_t caller, func_type_data_t* fti, funcargvec_t* rargs)  # This function is to be called by the processor mod
        argtinfo_helper_t& operator=(argtinfo_helper_t&)
    cdef cppclass lowertype_helper_t:  # ------------------------------------------------------------
        bint func_has_stkframe_hole(tinfo_t& candidate, func_type_data_t& candidate_data)
        int get_func_purged_bytes(tinfo_t& candidate, func_type_data_t& candidate_data)
        lowertype_helper_t& operator=(lowertype_helper_t&)
        lowertype_helper_t(lowertype_helper_t&)
        lowertype_helper_t()
    cdef cppclass ida_lowertype_helper_t:  # ------------------------------------------------------------
        ida_lowertype_helper_t(tinfo_t& _tif, ea_t _ea, int _pb)
        bint func_has_stkframe_hole(tinfo_t& candidate, func_type_data_t& candidate_data)
        int get_func_purged_bytes(tinfo_t& candidate, func_type_data_t&)
        ida_lowertype_helper_t(ida_lowertype_helper_t&)
        ida_lowertype_helper_t(ida_lowertype_helper_t&&)
        ida_lowertype_helper_t& operator=(ida_lowertype_helper_t&)
        ida_lowertype_helper_t& operator=(ida_lowertype_helper_t&&)
    cdef cppclass format_data_info_t:  # ------------------------------------------------------------
        int ptvf
        int radix  # number representation (8,10,16)
        int max_length  # max length of the formatted text (0 means no limit
        int arrbase  # for arrays: the first element of array to print
        int arrnelems  # for arrays: number of elements to print
        int margin  # length of one line (0 means to print everything on
        int indent  # how many spaces to use to indent nested structures
        format_data_info_t()
    cdef cppclass valinfo_t:  # Additional information about the output lines
        argloc_t loc
        qstring label
        tinfo_t type
        valinfo_t(argloc_t l, char* name, tinfo_t& tif)
        void swap(valinfo_t& r)
        valinfo_t(valinfo_t&)
        valinfo_t(valinfo_t&&)
        valinfo_t& operator=(valinfo_t&)
        valinfo_t& operator=(valinfo_t&&)
    cdef cppclass valstr_t:  # Text representation of a data value (value string). This str
        qstring oneline  # result if printed on one line in UTF-8 encoding
        size_t length  # length if printed on one line
        valstrs_t* members  # strings for members, each member separately
        valinfo_t* info  # additional info
        int props  # temporary properties, used internally
        valstr_t()
    cdef cppclass flatten_args_t:
        valstr_t* may_not_collapse
        int ptvf
        int max_length
        int margin
        int indent
    cdef cppclass valstrs_t:
        pass
    cdef cppclass text_sink_t:  # Flush formatted text
        int print(char* str)
        text_sink_t& operator=(text_sink_t&)
    cdef cppclass til_symbol_t:  # A symbol in a type library
        char* name  # symbol name
        til_t* til  # pointer to til
        til_symbol_t(char* n, til_t* t)
    cdef cppclass predicate_t:  # Helper class for choose_named_type(). Controls which types a
        bint should_display(til_t* til, char* name, type_t* type, p_list* fields)
        predicate_t& operator=(predicate_t&)
    cdef cppclass til_type_ref_t:  # ------------------------------------------------------------
        size_t cb
        tinfo_t tif  # type info, !empty() during runtime
        tif_cursor_t cursor  # 'pointer' inside a type
        uint32 ordinal  # cached value of tif.get_ordinal()
        bint is_writable  # can we modify the type? (either in a RW til, or wr
        bint is_detached  # type is not backed by a backend that will cause vi
        bint is_forward  # is the type a forward declaration?
        type_t kind  # one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENU
        ssize_t memidx  # index of the current BTF_STRUCT, BTF_UNION, BTF_EN
        size_t nmembers  # number of members in the BTF_STRUCT, BTF_UNION, BT
        udm_t udm  # BTF_STRUCT or BTF_UNION: the current member
        size_t total_size
        size_t unpadded_size
        uint64 last_udm_offset
        uint64 bucket_start  # bucket offset (equal to 'offset' except for bitfie
        int bf_bitoff  # for bitfields, bit offset from bucket_start
        uint64 offset  # the current offset (regardless if we have a define
        edm_t edm  # BTF_ENUM: the current enum member
        funcarg_t* fa  # BT_FUNC: the current argument, nullptr - ellipsis
        void clear()
        bint on_member() const
        bint is_typedef() const
        bint is_struct() const
        bint is_union() const
        bint is_enum() const
        bint is_func() const
        bint is_udt() const
        til_type_ref_t(til_type_ref_t&)
        til_type_ref_t(til_type_ref_t&&)
        til_type_ref_t& operator=(til_type_ref_t&)
        til_type_ref_t& operator=(til_type_ref_t&&)
        til_type_ref_t()
    cdef cppclass control_graph_t
    cdef cppclass edge_mapper_t
    cdef cppclass mba_stats_t
    cdef cppclass valrng_t:  # ------------------------------------------------------------
        valrng_t(int size_)
        valrng_t(valrng_t& r)
        valrng_t& operator=(valrng_t& r)
        void swap(valrng_t& r)
        bint operator==(valrng_t& r) const
        bint operator!=(valrng_t& r) const
        bint operator<(valrng_t& r) const
        bint operator>(valrng_t& r) const
        bint operator<=(valrng_t& r) const
        bint operator>=(valrng_t& r) const
        int compare(valrng_t& r) const
        void set_none()
        void set_all()
        void set_unk()
        void set_eq(uvlr_t v)
        void set_cmp(cmpop_t cmp, uvlr_t _value)
        bint reduce_size(int new_size)  # reduce size it takes the low part of size NEW_SIZE
        bint intersect_with(valrng_t& r)  # Perform intersection or union or inversion. 
        bint unite_with(valrng_t& r)
        void inverse()
        bint empty() const
        bint all_values() const
        bint is_unknown() const
        bint has(uvlr_t v) const
        void print(qstring* vout) const
        char* dstr() const
        bint cvt_to_single_value(uvlr_t* v) const
        bint cvt_to_cmp(cmpop_t* cmp, uvlr_t* val) const
        int get_size() const
        uvlr_t max_value() const
        uvlr_t min_svalue() const
        uvlr_t max_svalue() const
    cdef cppclass operand_locator_t:  # ------------------------------------------------------------
        ea_t ea  # address of the original processor instruction
        int opnum  # operand number in the instruction
        operand_locator_t(ea_t _ea, int _opnum)
        bint operator==(operand_locator_t& r) const
        bint operator!=(operand_locator_t& r) const
        bint operator<(operand_locator_t& r) const
        bint operator>(operand_locator_t& r) const
        bint operator<=(operand_locator_t& r) const
        bint operator>=(operand_locator_t& r) const
        int compare(operand_locator_t& r) const
    cdef cppclass number_format_t:  # ------------------------------------------------------------
        flags_t flags32  # low 32bit of flags (for compatibility)
        char opnum  # operand number: 0..UA_MAXOP
        char props  # properties: combination of NF_ bits (
        uchar serial  # for enums: constant serial number
        char org_nbytes  # original number size in bytes
        qstring type_name  # for stroffs: structure for offsetof() for enums: e
        flags64_t flags  # ida flags, which describe number radix, enum, etc
        number_format_t(int _opnum)  # Contructor
        int get_radix() const  # Get number radix 
        bint is_fixed() const  # Is number representation fixed? Fixed representati
        bint is_hex() const  # Is a hexadecimal number?
        bint is_dec() const  # Is a decimal number?
        bint is_oct() const  # Is a octal number?
        bint is_enum() const  # Is a symbolic constant?
        bint is_char() const  # Is a character constant?
        bint is_stroff() const  # Is a structure field offset?
        bint is_numop() const  # Is a number?
        bint needs_to_be_inverted() const  # Does the number need to be negated or bitwise nega
        bint has_unmutable_type() const  # symbolic constants and struct offsets cannot easil
    cdef cppclass vd_printer_t:  # ------------------------------------------------------------
        qstring tmpbuf
        int hdrlines  # number of header lines (prototype+typedef+lvars) v
        int print(int indent, char* format)  # Print. This function is called to generate a porti
        vd_printer_t& operator=(vd_printer_t&)
        vd_printer_t& operator=(vd_printer_t&&)
        vd_printer_t()
        vd_printer_t(vd_printer_t&)
        vd_printer_t(vd_printer_t&&)
    cdef cppclass vc_printer_t:  # Helper class to convert cfunc_t into text.
        cfunc_t* func  # cfunc_t to generate text for
        char lastchar  # internal: last printed character
        vc_printer_t(cfunc_t* f)  # Constructor
        bint oneliner() const  # Are we generating one-line text representation? 
        vc_printer_t& operator=(vc_printer_t&)
        vc_printer_t& operator=(vc_printer_t&&)
        vc_printer_t(vc_printer_t&)
        vc_printer_t(vc_printer_t&&)
    cdef cppclass file_printer_t:  # Helper class to convert binary data structures into text and
        FILE* fp  # Output file pointer
        int print(int indent, char* format)  # Print. This function is called to generate a porti
        file_printer_t(FILE* _fp)  # Constructor
        file_printer_t& operator=(file_printer_t&)
        file_printer_t& operator=(file_printer_t&&)
    cdef cppclass qstring_printer_t:  # Helper class to convert cfunc_t into a text string
        bint with_tags  # Generate output with color tags
        qstring& s  # Reference to the output string
        qstring_printer_t(cfunc_t* f, qstring& _s, bint tags)  # Constructor
        int print(int indent, char* format)  # Print. This function is called to generate a porti
        qstring_printer_t& operator=(qstring_printer_t&)
        qstring_printer_t& operator=(qstring_printer_t&&)
    cdef cppclass vdloc_t:  # ------------------------------------------------------------
        int reg1() const  # Get the register number. This function works only 
        void _set_reg1(int r1)  # Set vdloc to point to the specified register witho
        void set_reg1(int r1)  # Set vdloc to point to the specified register.
        char* dstr(int width) const  # Return textual representation. Note: this and all 
        bint operator==(vdloc_t& r) const
        bint operator!=(vdloc_t& r) const
        bint operator<(vdloc_t& r) const
        bint operator>(vdloc_t& r) const
        bint operator<=(vdloc_t& r) const
        bint operator>=(vdloc_t& r) const
        int compare(vdloc_t& r) const
        bint is_aliasable(mba_t* mb, int size) const
        vdloc_t(vdloc_t&)
        vdloc_t(vdloc_t&&)
        vdloc_t& operator=(vdloc_t&)
        vdloc_t& operator=(vdloc_t&&)
        vdloc_t()
    cdef cppclass lvar_locator_t:  # Local variable locator. Local variables are located using de
        vdloc_t location  # Variable location.
        ea_t defea  # Definition address. Usually, this is the address o
        lvar_locator_t()
        lvar_locator_t(vdloc_t& loc, ea_t ea)
        sval_t get_stkoff() const  # Get offset of the varialbe in the stack frame. 
        bint is_reg1() const  # Is variable located on one register?
        bint is_reg2() const  # Is variable located on two registers?
        bint is_reg_var() const  # Is variable located on register(s)?
        bint is_stk_var() const  # Is variable located on the stack?
        bint is_scattered() const  # Is variable scattered?
        mreg_t get_reg1() const  # Get the register number of the variable
        mreg_t get_reg2() const  # Get the number of the second register (works only 
        scattered_aloc_t& get_scattered() const  # Get information about scattered variable
        scattered_aloc_t& get_scattered()
        bint operator==(lvar_locator_t& r) const
        bint operator!=(lvar_locator_t& r) const
        bint operator<(lvar_locator_t& r) const
        bint operator>(lvar_locator_t& r) const
        bint operator<=(lvar_locator_t& r) const
        bint operator>=(lvar_locator_t& r) const
        int compare(lvar_locator_t& r) const
        char* dstr() const  # Debugging: get textual representation of a lvar lo
        lvar_locator_t(lvar_locator_t&)
        lvar_locator_t(lvar_locator_t&&)
        lvar_locator_t& operator=(lvar_locator_t&)
        lvar_locator_t& operator=(lvar_locator_t&&)
    cdef cppclass lvar_t:  # Definition of a local variable (register or stack) #var #lva
        qstring name  # variable name. use mba_t::set_nice_lvar_name() and
        qstring cmt  # variable comment string
        tinfo_t tif  # variable type
        int width  # variable size in bytes
        int defblk  # first block defining the variable. 0 for args, -1 
        uint64 divisor  # max known divisor of the variable
        lvar_t()
        lvar_t(qstring& n, vdloc_t& l, ea_t e, tinfo_t& t, int w, int db)
        char* dstr() const  # Debugging: get textual representation of a local v
        bint used() const  # Is the variable used in the code?
        bint typed() const  # Has the variable a type?
        bint mreg_done() const  # Have corresponding microregs been replaced by refe
        bint has_nice_name() const  # Does the variable have a nice name?
        bint is_unknown_width() const  # Do we know the width of the variable?
        bint has_user_info() const  # Has any user-defined information?
        bint has_user_name() const  # Has user-defined name?
        bint has_user_type() const  # Has user-defined type?
        bint is_result_var() const  # Is the function result?
        bint is_arg_var() const  # Is the function argument?
        bint is_promoted_arg() const  # Is the promoted function argument?
        bint is_fake_var() const  # Is fake return variable?
        bint is_overlapped_var() const  # Is overlapped variable?
        bint is_floating_var() const  # Used by a fpu insn?
        bint is_spoiled_var() const  # Is spoiled var? (meaningful only during lvar alloc
        bint is_partialy_typed() const  # Variable type should be handled as a partial one
        bint is_noptr_var() const  # Variable type should not be a pointer
        bint is_mapdst_var() const  # Other variable(s) map to this var?
        bint is_thisarg() const  # Is 'this' argument of a C++ member function?
        bint is_split_var() const  # Is a split variable?
        bint has_regname() const  # Has a register name? (like _RAX)
        bint in_asm() const  # Is variable used in an instruction translated into
        bint is_dummy_arg() const  # Is a dummy argument (added to fill a hole in the a
        bint is_notarg() const  # Is a local variable? (local variable cannot be an 
        bint is_automapped() const  # Was the variable automatically mapped to another v
        bint is_used_byref() const  # Was the address of the variable taken?
        bint is_decl_unused() const  # Was declared as __unused by the user? See CVAR_UNU
        bint is_shared() const  # Is lvar mapped to several chains
        bint was_scattered_arg() const  # Was lvar transformed from a scattered argument?
        void set_used()
        void clear_used()
        void set_typed()
        void set_non_typed()
        void clr_user_info()
        void set_user_name()
        void set_user_type()
        void clr_user_type()
        void clr_user_name()
        void set_mreg_done()
        void clr_mreg_done()
        void set_unknown_width()
        void clr_unknown_width()
        void set_arg_var()
        void clr_arg_var()
        void set_fake_var()
        void clr_fake_var()
        void set_overlapped_var()
        void clr_overlapped_var()
        void set_floating_var()
        void clr_floating_var()
        void set_spoiled_var()
        void clr_spoiled_var()
        void set_mapdst_var()
        void clr_mapdst_var()
        void set_partialy_typed()
        void clr_partialy_typed()
        void set_noptr_var()
        void clr_noptr_var()
        void set_thisarg()
        void clr_thisarg()
        void set_split_var()
        void clr_split_var()
        void set_dummy_arg()
        void clr_dummy_arg()
        void set_notarg()
        void clr_notarg()
        void set_automapped()
        void clr_automapped()
        void set_used_byref()
        void clr_used_byref()
        void set_decl_unused()
        void clr_decl_unused()
        void set_shared()
        void clr_shared()
        void set_scattered_arg()
        void clr_scattered_arg()
        bint has_common(lvar_t& v) const  # Do variables overlap?
        bint has_common_bit(vdloc_t& loc, asize_t width2) const  # Does the variable overlap with the specified locat
        tinfo_t& type() const  # Get variable type
        tinfo_t& type()
        bint accepts_type(tinfo_t& t, bint may_change_thisarg)  # Check if the variable accept the specified type. S
        bint set_lvar_type(tinfo_t& t, bint may_fail)  # Set variable type Note: this function does not mod
        void set_final_lvar_type(tinfo_t& t)  # Set final variable type.
        bint set_width(int w, int svw_flags)  # Change the variable width. We call the variable si
        void append_list(mba_t* mba, mlist_t* lst, bint pad_if_scattered) const  # Append local variable to mlist. 
        bint is_aliasable(mba_t* mba) const  # Is the variable aliasable? 
        lvar_t(lvar_t&)
        lvar_t(lvar_t&&)
        lvar_t& operator=(lvar_t&)
        lvar_t& operator=(lvar_t&&)
    cdef cppclass lvars_t:  # Vector of local variables
        int find_input_lvar(vdloc_t& argloc, int _size)  # Find an input variable at the specified location. 
        int find_input_reg(int reg, int _size)  # Find an input register variable. 
        int find_stkvar(sval_t spoff, int width)  # Find a stack variable at the specified location. 
        lvar_t* find(lvar_locator_t& ll)  # Find a variable at the specified location. 
        int find_lvar(vdloc_t& location, int width, int defblk) const  # Find a variable at the specified location. 
    cdef cppclass lvar_saved_info_t:  # Saved user settings for local variables: name, type, comment
        lvar_locator_t ll  # Variable locator
        qstring name  # Name
        tinfo_t type  # Type
        qstring cmt  # Comment
        ssize_t size  # Type size (if not initialized then -1)
        int flags
        bint has_info() const  # @ }
        bint operator==(lvar_saved_info_t& r) const
        bint operator!=(lvar_saved_info_t& r) const
        bint is_kept() const
        void clear_keep()
        void set_keep()
        bint is_split_lvar() const
        void set_split_lvar()
        void clr_split_lvar()
        bint is_noptr_lvar() const
        void set_noptr_lvar()
        void clr_noptr_lvar()
        bint is_nomap_lvar() const
        void set_nomap_lvar()
        void clr_nomap_lvar()
        bint is_unused_lvar() const
        void set_unused_lvar()
        void clr_unused_lvar()
        lvar_saved_info_t(lvar_saved_info_t&)
        lvar_saved_info_t(lvar_saved_info_t&&)
        lvar_saved_info_t& operator=(lvar_saved_info_t&)
        lvar_saved_info_t& operator=(lvar_saved_info_t&&)
        lvar_saved_info_t()
    cdef cppclass lvar_uservec_t:  # All user-defined information about local variables
        lvar_saved_infos_t lvvec  # User-specified names, types, comments for lvars. V
        lvar_mapping_t lmaps  # Local variable mapping (used for merging variables
        uval_t stkoff_delta  # Delta to add to IDA stack offset to calculate Hex-
        int ulv_flags  # @ } Various flags. Possible values are from
        void swap(lvar_uservec_t& r)
        void clear()
        bint empty() const
        lvar_saved_info_t* find_info(lvar_locator_t& vloc)  # find saved user settings for given var
        void keep_info(lvar_t& v)  # Preserve user settings for given var
    cdef cppclass user_lvar_modifier_t:  # Helper class to modify saved local variable settings.
        bint modify_lvars(lvar_uservec_t* lvinf)  # Modify lvar settings. Returns: true-modified
        user_lvar_modifier_t& operator=(user_lvar_modifier_t&)
    cdef cppclass udcall_t:  # ------------------------------------------------------------
        qstring name  # name of the function
        tinfo_t tif  # function prototype
        bint operator==(udcall_t& r) const
        bint operator!=(udcall_t& r) const
        bint operator<(udcall_t& r) const
        bint operator>(udcall_t& r) const
        bint operator<=(udcall_t& r) const
        bint operator>=(udcall_t& r) const
        int compare(udcall_t& r) const
        bint empty() const
        udcall_t(udcall_t&)
        udcall_t(udcall_t&&)
        udcall_t& operator=(udcall_t&)
        udcall_t& operator=(udcall_t&&)
    cdef cppclass microcode_filter_t:  # ------------------------------------------------------------
        bint match(codegen_t& cdg)  # check if the filter object is to be applied 
        merror_t apply(codegen_t& cdg)  # generate microcode for an instruction 
        microcode_filter_t& operator=(microcode_filter_t&)
        microcode_filter_t(microcode_filter_t&)
    cdef cppclass udc_filter_t:  # ------------------------------------------------------------
        void cleanup()  # Cleanup the filter This function properly clears t
        bint match(codegen_t& cdg)  # return true if the filter object should be applied
        bint init(char* decl)
        merror_t apply(codegen_t& cdg)
        bint empty() const
        udc_filter_t(udc_filter_t&)
        udc_filter_t& operator=(udc_filter_t&)
    cdef cppclass bitset_t:  # Bit set class. See https://en.wikipedia.org/wiki/Bit_array
        bitset_t()
        bitset_t(bitset_t& m)
        void swap(bitset_t& r)
        bitset_t& operator=(bitset_t& m)
        bitset_t& copy(bitset_t& m)
        bint add(int bit)
        bint add(int bit, int width)
        bint add(bitset_t& ml)
        bint sub(int bit)
        bint sub(int bit, int width)
        bint sub(bitset_t& ml)
        bint cut_at(int maxbit)
        void shift_down(int shift)
        bint has(int bit) const
        bint has_all(int bit, int width) const
        bint has_any(int bit, int width) const
        char* dstr() const
        bint empty() const
        int count() const
        int count(int bit) const
        int last() const
        void clear()
        void fill_with_ones(int maxbit)
        bint fill_gaps(int total_nbits)
        bint has_common(bitset_t& ml) const
        bint intersect(bitset_t& ml)
        bint is_subset_of(bitset_t& ml) const
        bint includes(bitset_t& ml) const
        void extract(intvec_t& out) const
        bint operator==(bitset_t& r) const
        bint operator!=(bitset_t& r) const
        bint operator<(bitset_t& r) const
        bint operator>(bitset_t& r) const
        bint operator<=(bitset_t& r) const
        bint operator>=(bitset_t& r) const
        int compare(bitset_t& r) const
        iterator itat(int n) const
        iterator begin() const
        iterator end() const
        int front() const
        int back() const
        void inc(iterator& p, int n) const
    cdef cppclass iterator:
        iterator(int n)
        bint operator==(iterator& n) const
        bint operator!=(iterator& n) const
        int operator*() const
        iterator(iterator&)
        iterator(iterator&&)
    cdef cppclass node_bitset_t:  # ------------------------------------------------------------
        node_bitset_t()
        node_bitset_t(int node)
        node_bitset_t(node_bitset_t&)
        node_bitset_t(node_bitset_t&&)
        node_bitset_t& operator=(node_bitset_t&)
        node_bitset_t& operator=(node_bitset_t&&)
    cdef cppclass array_of_node_bitset_t:
        pass
    cdef cppclass ivl_t:
        ivl_t(uval_t _off, uval_t _size)
        bint empty() const
        void clear()
        void print(qstring* vout) const
        char* dstr() const
        bint extend_to_cover(ivl_t& r)
        void intersect(ivl_t& r)
        bint overlap(ivl_t& ivl) const  # do *this and ivl overlap?
        bint includes(ivl_t& ivl) const  # does *this include ivl?
        bint contains(uval_t off2) const  # does *this contain off2?
        bint operator==(ivl_t& r) const
        bint operator!=(ivl_t& r) const
        bint operator<(ivl_t& r) const
        bint operator>(ivl_t& r) const
        bint operator<=(ivl_t& r) const
        bint operator>=(ivl_t& r) const
        int compare(ivl_t& r) const
        ivl_t(ivl_t&)
        ivl_t(ivl_t&&)
    cdef cppclass ivl_with_name_t:  # ------------------------------------------------------------
        ivl_t ivl
        char* whole  # name of the whole interval
        char* part  # prefix to use for parts of the interval (e.g. sp+4
        ivl_with_name_t()
    cdef cppclass ivlset_t:
        ivlset_t()
        ivlset_t(ivl_t& ivl)
        bint add(ivl_t& ivl)
        bint add(ea_t ea, asize_t size)
        bint add(ivlset_t& ivs)
        bint addmasked(ivlset_t& ivs, ivl_t& mask)
        bint sub(ivl_t& ivl)
        bint sub(ea_t ea, asize_t size)
        bint sub(ivlset_t& ivs)
        bint has_common(ivl_t& ivl, bint strict) const
        void print(qstring* vout) const
        char* dstr() const
        asize_t count() const
        bint has_common(ivlset_t& ivs) const
        bint contains(uval_t off) const
        bint includes(ivlset_t& ivs) const
        bint intersect(ivlset_t& ivs)
        bint operator==(ivlset_t& r) const
        bint operator!=(ivlset_t& r) const
        bint operator<(ivlset_t& r) const
        bint operator>(ivlset_t& r) const
        bint operator<=(ivlset_t& r) const
        bint operator>=(ivlset_t& r) const
        int compare(ivlset_t& r) const
        ivlset_t(ivlset_t&)
        ivlset_t(ivlset_t&&)
    cdef cppclass rlist_t:  # ------------------------------------------------------------
        rlist_t()
        rlist_t(rlist_t& m)
        rlist_t(mreg_t reg, int width)
        rlist_t& operator=(rlist_t&)
        void print(qstring* vout) const
        char* dstr() const
    cdef cppclass mlist_t:  # ------------------------------------------------------------
        rlist_t reg  # registers
        ivlset_t mem  # memory locations
        mlist_t()
        mlist_t(ivl_t& ivl)
        mlist_t(mreg_t r, int size)
        void swap(mlist_t& r)
        bint addmem(ea_t ea, asize_t size)
        bint add(mreg_t r, int size)
        bint add(rlist_t& r)
        bint add(ivl_t& ivl)
        bint add(mlist_t& lst)
        bint sub(mreg_t r, int size)
        bint sub(ivl_t& ivl)
        bint sub(mlist_t& lst)
        asize_t count() const
        void print(qstring* vout) const
        char* dstr() const
        bint empty() const
        void clear()
        bint has(mreg_t r) const
        bint has_all(mreg_t r, int size) const
        bint has_any(mreg_t r, int size) const
        bint has_memory() const
        bint has_allmem() const
        bint has_common(mlist_t& lst) const
        bint includes(mlist_t& lst) const
        bint intersect(mlist_t& lst)
        bint is_subset_of(mlist_t& lst) const
        bint operator==(mlist_t& r) const
        bint operator!=(mlist_t& r) const
        bint operator<(mlist_t& r) const
        bint operator>(mlist_t& r) const
        bint operator<=(mlist_t& r) const
        bint operator>=(mlist_t& r) const
        int compare(mlist_t& r) const
        mlist_t(mlist_t&)
        mlist_t(mlist_t&&)
        mlist_t& operator=(mlist_t&)
        mlist_t& operator=(mlist_t&&)
    cdef cppclass optinsn_t:  # ------------------------------------------------------------
        int func(mblock_t* blk, minsn_t* ins, int optflags)  # Optimize an instruction. 
        optinsn_t& operator=(optinsn_t&)
    cdef cppclass optblock_t:  # User defined callback to optimize microcode blocks
        int func(mblock_t* blk)  # Optimize a block. This function usually performs t
        optblock_t& operator=(optblock_t&)
    cdef cppclass simple_graph_t:  # ------------------------------------------------------------
        qstring title
        bint colored_gdl_edges
        bint ignore_edge(int, int) const  # this call is used to exclude edges in worklist_ite
        void compute_dominators(array_of_node_bitset_t& domin, bint post) const
        void compute_immediate_dominators(array_of_node_bitset_t& domin, intvec_t& idomin, bint post) const
        int depth_first_preorder(node_ordering_t* pre) const
        int depth_first_postorder(node_ordering_t* post) const
        iterator begin() const
        iterator end() const
        int front() const
        void inc(iterator& p, int n) const
        int goup(int node) const
        simple_graph_t(simple_graph_t&)
        simple_graph_t(simple_graph_t&&)
        simple_graph_t& operator=(simple_graph_t&)
        simple_graph_t& operator=(simple_graph_t&&)
    cdef cppclass dominator_info_t
    cdef cppclass op_parent_info_t:  # The context info used by visitors
        mba_t* mba  # current microcode
        mblock_t* blk  # current block
        minsn_t* topins  # top level instruction (parent of curins or curins 
        minsn_t* curins  # currently visited instruction
        op_parent_info_t(mba_t* _mba, mblock_t* _blk, minsn_t* _topins)
        bint really_alloc() const
        op_parent_info_t& operator=(op_parent_info_t&)
        op_parent_info_t(op_parent_info_t&)
    cdef cppclass minsn_visitor_t:  # Micro instruction visitor. See mba_t::for_all_topinsns, mins
        minsn_visitor_t(mba_t* _mba, mblock_t* _blk, minsn_t* _topins)
        int visit_minsn()
        minsn_visitor_t(minsn_visitor_t&)
        minsn_visitor_t(minsn_visitor_t&&)
        minsn_visitor_t& operator=(minsn_visitor_t&)
        minsn_visitor_t& operator=(minsn_visitor_t&&)
    cdef cppclass mop_visitor_t:  # Micro operand visitor. See mop_t::for_all_ops, minsn_t::for_
        bint prune  # Should skip sub-operands of the current operand? v
        mop_visitor_t(mba_t* _mba, mblock_t* _blk, minsn_t* _topins)
        int visit_mop(mop_t* op, tinfo_t* type, bint is_target)
        mop_visitor_t(mop_visitor_t&)
        mop_visitor_t(mop_visitor_t&&)
        mop_visitor_t& operator=(mop_visitor_t&)
        mop_visitor_t& operator=(mop_visitor_t&&)
    cdef cppclass scif_visitor_t:  # Scattered mop: visit each of the scattered locations as a se
        int visit_scif_mop(mop_t& r, int off)
        scif_visitor_t& operator=(scif_visitor_t&)
    cdef cppclass mlist_mop_visitor_t:  # Used operand visitor. See mblock_t::for_all_uses
        minsn_t* topins
        minsn_t* curins
        bint changed
        mlist_t* list
        bint prune  # Should skip sub-operands of the current operand? v
        int visit_mop(mop_t* op)
        mlist_mop_visitor_t& operator=(mlist_mop_visitor_t&)
    cdef cppclass lvar_ref_t:  # ------------------------------------------------------------
        mba_t*const mba  # Pointer to the parent mba_t object. Since we need 
        sval_t off  # offset from the beginning of the variable
        int idx  # index into mba->vars
        lvar_ref_t(mba_t* m, int i, sval_t o)
        lvar_ref_t(lvar_ref_t& r)
        lvar_ref_t& operator=(lvar_ref_t& r)
        bint operator==(lvar_ref_t& r) const
        bint operator!=(lvar_ref_t& r) const
        bint operator<(lvar_ref_t& r) const
        bint operator>(lvar_ref_t& r) const
        bint operator<=(lvar_ref_t& r) const
        bint operator>=(lvar_ref_t& r) const
        int compare(lvar_ref_t& r) const
        void swap(lvar_ref_t& r)
        lvar_t& var() const
    cdef cppclass stkvar_ref_t:  # ------------------------------------------------------------
        mba_t*const mba  # Pointer to the parent mba_t object. We need it in 
        sval_t off  # Offset to the stack variable from the bottom of th
        stkvar_ref_t(mba_t* m, sval_t o)
        bint operator==(stkvar_ref_t& r) const
        bint operator!=(stkvar_ref_t& r) const
        bint operator<(stkvar_ref_t& r) const
        bint operator>(stkvar_ref_t& r) const
        bint operator<=(stkvar_ref_t& r) const
        bint operator>=(stkvar_ref_t& r) const
        int compare(stkvar_ref_t& r) const
        void swap(stkvar_ref_t& r)
        ssize_t get_stkvar(udm_t* udm, uval_t* p_idaoff) const  # Retrieve the referenced stack variable. 
        stkvar_ref_t(stkvar_ref_t&)
        stkvar_ref_t(stkvar_ref_t&&)
    cdef cppclass scif_t:  # ------------------------------------------------------------
        mba_t* mba  # Pointer to the parent mba_t object. Some operation
        qstring name  # Usually scattered operands are created from a func
        tinfo_t type  # Scattered operands always have type info assigned 
        scif_t(mba_t* _mba, tinfo_t* tif, qstring* n)
        scif_t& operator=(vdloc_t& loc)
        scif_t(scif_t&)
        scif_t(scif_t&&)
        scif_t& operator=(scif_t&)
        scif_t& operator=(scif_t&&)
    cdef cppclass mnumber_t:  # ------------------------------------------------------------
        uint64 value
        uint64 org_value  # original value before changing the operand size
        mnumber_t(uint64 v, ea_t _ea, int n)
        bint operator==(mnumber_t& r) const
        bint operator!=(mnumber_t& r) const
        bint operator<(mnumber_t& r) const
        bint operator>(mnumber_t& r) const
        bint operator<=(mnumber_t& r) const
        bint operator>=(mnumber_t& r) const
        int compare(mnumber_t& r) const
        void update_value(uint64 val64)  # always use this function instead of manually modif
    cdef cppclass fnumber_t:  # ------------------------------------------------------------
        fpvalue_t fnum  # Internal representation of the number
        int nbytes  # Original size of the constant in bytes
        void print(qstring* vout) const
        char* dstr() const
        bint operator==(fnumber_t& r) const
        bint operator!=(fnumber_t& r) const
        bint operator<(fnumber_t& r) const
        bint operator>(fnumber_t& r) const
        bint operator<=(fnumber_t& r) const
        bint operator>=(fnumber_t& r) const
        int compare(fnumber_t& r) const
        int calc_max_exp() const
        bint is_nan() const
    cdef cppclass mop_t:  # ------------------------------------------------------------
        mopt_t t  # Operand type.
        uint8 oprops  # Operand properties.
        uint16 valnum  # Value number. Zero means unknown. Operands with th
        int size  # Operand size. Usually it is 1,2,4,8 or NOSIZE but 
        mreg_t r  # mop_r   register number
        mnumber_t* nnn  # mop_n   immediate value
        minsn_t* d  # mop_d   result (destination) of another instructio
        stkvar_ref_t* s  # mop_S   stack variable
        ea_t g  # mop_v   global variable (its linear address)
        int b  # mop_b   block number (used in jmp,call instruction
        mcallinfo_t* f  # mop_f   function call information
        lvar_ref_t* l  # mop_l   local variable
        mop_addr_t* a  # mop_a   variable whose address is taken
        char* helper  # mop_h   helper function name
        char* cstr  # mop_str utf8 string constant, user representation
        mcases_t* c  # mop_c   cases
        fnumber_t* fpc  # mop_fn  floating point constant
        mop_pair_t* pair  # mop_p   operand pair
        scif_t* scif  # mop_sc  scattered operand info
        void set_impptr_done()  # -- End of data fields, member function declaration
        void set_udt()
        void set_undef_val()
        void set_lowaddr()
        void set_for_abi()
        bint is_impptr_done() const
        bint is_udt() const
        bint probably_floating() const
        bint is_undef_val() const
        bint is_lowaddr() const
        bint is_for_abi() const
        bint is_ccflags() const
        bint is_pcval() const
        bint is_glbaddr_from_fixup() const
        mop_t()
        mop_t(mop_t& rop)
        mop_t(mreg_t _r, int _s)
        mop_t& operator=(mop_t& rop)
        mop_t& assign(mop_t& rop)
        void zero()
        void swap(mop_t& rop)
        void erase()
        void erase_but_keep_size()
        void print(qstring* vout, int shins_flags) const
        char* dstr() const
        bint create_from_mlist(mba_t* mba, mlist_t& lst, sval_t fullsize)  # --------------------------------------------------
        bint create_from_ivlset(mba_t* mba, ivlset_t& ivs, sval_t fullsize)  # Create operand from ivlset_t. Example: if IVS cont
        void create_from_vdloc(mba_t* mba, vdloc_t& loc, int _size)  # Create operand from vdloc_t. Example: if LOC conta
        void create_from_scattered_vdloc(mba_t* mba, char* name, tinfo_t type, vdloc_t& loc)  # Create operand from scattered vdloc_t. Example: if
        void create_from_insn(minsn_t* m)  # Create operand from an instruction. This function 
        void make_number(uint64 _value, int _size, ea_t _ea, int opnum)  # Create an integer constant operand. 
        bint make_fpnum(void* bytes, size_t _size)  # Create a floating point constant operand. 
        void _make_reg(mreg_t reg)  # Create a register operand without erasing previous
        void _make_reg(mreg_t reg, int _size)
        void make_reg(mreg_t reg)  # Create a register operand.
        void make_reg(mreg_t reg, int _size)
        void _make_lvar(mba_t* mba, int idx, sval_t off)  # Create a local variable operand. 
        void _make_gvar(ea_t ea)  # Create a global variable operand without erasing p
        void make_gvar(ea_t ea)  # Create a global variable operand.
        void _make_stkvar(mba_t* mba, sval_t off)  # Create a stack variable operand. 
        void make_stkvar(mba_t* mba, sval_t off)
        void make_reg_pair(int loreg, int hireg, int halfsize)  # Create pair of registers. 
        void _make_insn(minsn_t* ins)  # Create a nested instruction without erasing previo
        void make_insn(minsn_t* ins)  # Create a nested instruction.
        void _make_blkref(int blknum)  # Create a block reference operand without erasing p
        void make_blkref(int blknum)  # Create a global variable operand.
        void make_helper(char* name)  # Create a helper operand. A helper operand usually 
        void _make_strlit(char* str)  # Create a constant string operand.
        void _make_strlit(qstring* str)
        void _make_callinfo(mcallinfo_t* fi)  # Create a call info operand without erasing previou
        void _make_cases(mcases_t* _cases)  # Create a 'switch cases' operand without erasing pr
        void _make_pair(mop_pair_t* _pair)  # Create a pair operand without erasing previous dat
        bint empty() const  # --------------------------------------------------
        bint is_glbvar() const  # Is a global variable?
        bint is_stkvar() const  # Is a stack variable?
        bint is_reg() const  # Is a register operand? See also get_mreg_name()
        bint is_reg(mreg_t _r) const  # Is the specified register?
        bint is_reg(mreg_t _r, int _size) const  # Is the specified register of the specified size?
        bint is_arglist() const  # Is a list of arguments?
        bint is_cc() const  # Is a condition code?
        bint is_bit_reg(mreg_t reg)  # Is a bit register? This includes condition codes a
        bint is_bit_reg() const
        bint is_kreg() const  # Is a kernel register?
        bint is_mblock() const  # Is a block reference?
        bint is_mblock(int serial) const  # Is a block reference to the specified block?
        bint is_scattered() const  # Is a scattered operand?
        bint is_glbaddr() const  # Is address of a global memory cell?
        bint is_glbaddr(ea_t ea) const  # Is address of the specified global memory cell?
        bint is_stkaddr() const  # Is address of a stack variable?
        bint is_insn() const  # Is a sub-instruction?
        bint is_insn(mcode_t code) const  # Is a sub-instruction with the specified opcode?
        bint has_side_effects(bint include_ldx_and_divs) const  # Has any side effects? 
        bint may_use_aliased_memory() const  # Is it possible for the operand to use aliased memo
        bint is01() const  # Are the possible values of the operand only 0 and 
        bint is_sign_extended_from(int nbytes) const  # Does the high part of the operand consist of the s
        bint is_zero_extended_from(int nbytes) const  # Does the high part of the operand consist of zero 
        bint is_extended_from(int nbytes, bint is_signed) const  # Does the high part of the operand consist of zero 
        bint equal_mops(mop_t& rop, int eqflags) const  # --------------------------------------------------
        bint operator==(mop_t& rop) const
        bint operator!=(mop_t& rop) const
        bint operator<(mop_t& rop) const  # Lexographical operand comparison. It can be used t
        int lexcompare(mop_t& rop) const
        int for_all_ops(mop_visitor_t& mv, tinfo_t* type, bint is_target)  # --------------------------------------------------
        int for_all_scattered_submops(scif_visitor_t& sv) const  # Visit all sub-operands of a scattered operand. Thi
        uint64 value(bint is_signed) const  # --------------------------------------------------
        int64 signed_value() const
        uint64 unsigned_value() const
        void update_numop_value(uint64 val)
        bint is_constant(uint64* out, bint is_signed) const  # Retrieve value of a constant integer operand. 
        bint is_equal_to(uint64 n, bint is_signed) const
        bint is_zero() const
        bint is_one() const
        bint is_positive_constant() const
        bint is_negative_constant() const
        ssize_t get_stkvar(udm_t* udm, uval_t* p_idaoff) const  # --------------------------------------------------
        bint get_stkoff(sval_t* p_vdoff) const  # Get the referenced stack offset. This function can
        minsn_t* get_insn(mcode_t code) const  # --------------------------------------------------
        minsn_t* get_insn(mcode_t code)
        bint make_low_half(int width)  # --------------------------------------------------
        bint make_high_half(int width)  # Make the high part of the operand. This function t
        bint make_first_half(int width)  # Make the first part of the operand. This function 
        bint make_second_half(int width)  # Make the second part of the operand. This function
        bint shift_mop(int offset)  # Shift the operand. This function shifts only the b
        bint change_size(int nsize, side_effect_t sideff)  # Change the operand size. Examples: change_size(AL.
        bint double_size(side_effect_t sideff)
        bint preserve_side_effects(mblock_t* blk, minsn_t* top, bint* moved_calls)  # Move subinstructions with side effects out of the 
        void apply_ld_mcode(mcode_t mcode, ea_t ea, int newsize)  # Apply a unary opcode to the operand. 
        void apply_xdu(ea_t ea, int newsize)
        void apply_xds(ea_t ea, int newsize)
    cdef cppclass mop_pair_t:  # Pair of operands
        mop_t lop  # low operand
        mop_t hop  # high operand
        mop_pair_t(mop_pair_t&)
        mop_pair_t(mop_pair_t&&)
        mop_pair_t& operator=(mop_pair_t&)
        mop_pair_t& operator=(mop_pair_t&&)
    cdef cppclass mop_addr_t:  # Address of an operand (mop_l, mop_v, mop_S, mop_r)
        int insize  # how many bytes of the pointed operand can be read
        int outsize  # how many bytes of the pointed operand can be writt
        mop_addr_t()
        mop_addr_t(mop_addr_t& ra)
        mop_addr_t(mop_t& ra, int isz, int osz)
        mop_addr_t& operator=(mop_addr_t& rop)
        int lexcompare(mop_addr_t& ra) const
    cdef cppclass mcallarg_t:  # A call argument
        ea_t ea  # address where the argument was initialized. BADADD
        tinfo_t type  # formal argument type
        qstring name  # formal argument name
        argloc_t argloc  # ida argloc
        uint32 flags  # FAI_...
        mcallarg_t()
        mcallarg_t(mop_t& rarg)
        void copy_mop(mop_t& op)
        void print(qstring* vout, int shins_flags) const
        char* dstr() const
        void set_regarg(mreg_t mr, int sz, tinfo_t& tif)
        void set_regarg(mreg_t mr, tinfo_t& tif)
        void set_regarg(mreg_t mr, char dt, type_sign_t sign)
        void make_int(int val, ea_t val_ea, int opno)
        void make_uint(int val, ea_t val_ea, int opno)
        mcallarg_t(mcallarg_t&)
        mcallarg_t(mcallarg_t&&)
        mcallarg_t& operator=(mcallarg_t&)
        mcallarg_t& operator=(mcallarg_t&&)
    cdef cppclass mcallinfo_t:  # Information about a call
        ea_t callee  # address of the called function, if known
        int solid_args  # number of solid args. there may be variadic args i
        int call_spd  # sp value at call insn
        int stkargs_top  # first offset past stack arguments
        callcnv_t cc  # calling convention
        mcallargs_t args  # call arguments
        mopvec_t retregs  # return register(s) (e.g., AX, AX:DX, etc.) this ve
        tinfo_t return_type  # type of the returned value
        argloc_t return_argloc  # location of the returned value
        mlist_t return_regs  # list of values returned by the function
        mlist_t spoiled  # list of spoiled locations (includes return_regs)
        mlist_t pass_regs  # passthrough registers: registers that depend on in
        ivlset_t visible_memory  # what memory is visible to the call?
        mlist_t dead_regs  # registers defined by the function but never used. 
        int flags  # combination of bits
        funcrole_t role  # function role
        type_attrs_t fti_attrs  # extended function attributes
        mcallinfo_t(ea_t _callee, int _sargs)
        int lexcompare(mcallinfo_t& f) const
        bint set_type(tinfo_t& type)
        tinfo_t get_type() const
        bint is_vararg() const
        void print(qstring* vout, int size, int shins_flags) const
        char* dstr() const
        mcallinfo_t(mcallinfo_t&)
        mcallinfo_t(mcallinfo_t&&)
        mcallinfo_t& operator=(mcallinfo_t&)
        mcallinfo_t& operator=(mcallinfo_t&&)
    cdef cppclass mcases_t:  # List of switch cases and targets
        casevec_t values  # expression values for each target
        intvec_t targets  # target block numbers
        void swap(mcases_t& r)
        bint operator==(mcases_t& r) const
        bint operator!=(mcases_t& r) const
        bint operator<(mcases_t& r) const
        bint operator>(mcases_t& r) const
        bint operator<=(mcases_t& r) const
        bint operator>=(mcases_t& r) const
        int compare(mcases_t& r) const
        bint empty() const
        size_t size() const
        void resize(int s)
        void print(qstring* vout) const
        char* dstr() const
    cdef cppclass voff_t:  # ------------------------------------------------------------
        sval_t off  # register number or stack offset
        mopt_t type  # mop_r - register, mop_S - stack, mop_z - undefined
        voff_t()
        voff_t(mopt_t _type, sval_t _off)
        voff_t(mop_t& op)
        void set(mopt_t _type, sval_t _off)
        void set_stkoff(sval_t stkoff)
        void set_reg(mreg_t mreg)
        void undef()
        bint defined() const
        bint is_reg() const
        bint is_stkoff() const
        mreg_t get_reg() const
        sval_t get_stkoff() const
        void inc(sval_t delta)
        voff_t add(int width) const
        sval_t diff(voff_t& r) const
        bint operator==(voff_t& r) const
        bint operator!=(voff_t& r) const
        bint operator<(voff_t& r) const
        bint operator>(voff_t& r) const
        bint operator<=(voff_t& r) const
        bint operator>=(voff_t& r) const
        int compare(voff_t& r) const
        voff_t(voff_t&)
        voff_t(voff_t&&)
    cdef cppclass vivl_t:  # ------------------------------------------------------------
        int size  # Interval size in bytes
        vivl_t(mopt_t _type, sval_t _off, int _size)
        vivl_t(chain_t& ch)
        vivl_t(mop_t& op)
        void set(mopt_t _type, sval_t _off, int _size)  # Make a value interval
        void set(voff_t& voff, int _size)
        void set_stkoff(sval_t stkoff, int sz)
        void set_reg(mreg_t mreg, int sz)
        bint extend_to_cover(vivl_t& r)  # Extend a value interval using another value interv
        uval_t intersect(vivl_t& r)  # Intersect value intervals the same type 
        bint overlap(vivl_t& r) const  # Do two value intervals overlap?
        bint includes(vivl_t& r) const  # Does our value interval include another?
        bint contains(voff_t& voff2) const  # Does our value interval contain the specified valu
        bint operator==(vivl_t& r) const  # Comparisons
        bint operator!=(vivl_t& r) const  # Comparisons
        bint operator<(vivl_t& r) const  # Comparisons
        bint operator>(vivl_t& r) const  # Comparisons
        bint operator<=(vivl_t& r) const  # Comparisons
        bint operator>=(vivl_t& r) const  # Comparisons
        int compare(vivl_t& r) const  # Comparisons
        bint operator==(mop_t& mop) const
        void print(qstring* vout) const
        char* dstr() const
        vivl_t(vivl_t&)
        vivl_t(vivl_t&&)
    cdef cppclass chain_t:  # ------------------------------------------------------------
        int width  # size of the value in bytes
        int varnum  # allocated variable index (-1 - not allocated yet)
        uchar flags  # combination bits
        chain_t()  # @ }
        chain_t(mopt_t t, sval_t off, int w, int v)
        chain_t(voff_t& _k, int w)
        void set_value(chain_t& r)
        voff_t& key() const
        bint is_inited() const
        bint is_reg() const
        bint is_stkoff() const
        bint is_replaced() const
        bint is_overlapped() const
        bint is_fake() const
        bint is_passreg() const
        bint is_term() const
        void set_inited(bint b)
        void set_replaced(bint b)
        void set_overlapped(bint b)
        void set_term(bint b)
        mreg_t get_reg() const
        sval_t get_stkoff() const
        bint overlap(chain_t& r) const
        bint includes(chain_t& r) const
        voff_t endoff() const
        bint operator<(chain_t& r) const
        void print(qstring* vout) const
        char* dstr() const
        void append_list(mba_t* mba, mlist_t* list) const  # Append the contents of the chain to the specified 
        void clear_varnum()
        chain_t(chain_t&)
        chain_t(chain_t&&)
    cdef cppclass block_chains_t:  # Chains of one block. Please note that this class is based on
        chain_t* get_reg_chain(mreg_t reg, int width) const  # Get chain for the specified register 
        chain_t* get_reg_chain(mreg_t reg, int width)
        chain_t* get_stk_chain(sval_t off, int width) const  # Get chain for the specified stack offset 
        chain_t* get_stk_chain(sval_t off, int width)
        chain_t* get_chain(voff_t& k, int width) const  # Get chain for the specified value offset. 
        chain_t* get_chain(voff_t& k, int width)
        chain_t* get_chain(chain_t& ch) const  # Get chain similar to the specified chain 
        chain_t* get_chain(chain_t& ch)
        void print(qstring* vout) const
        char* dstr() const
    cdef cppclass chain_visitor_t:  # ------------------------------------------------------------
        block_chains_t* parent  # parent of the current chain
        int visit_chain(int nblock, chain_t& ch)
        chain_visitor_t& operator=(chain_visitor_t&)
    cdef cppclass graph_chains_t:
        int for_all_chains(chain_visitor_t& cv, int gca_flags)  # Visit all chains 
        bint is_locked() const  # @ } Are the chains locked? It is a good idea to lo
        void acquire()  # Lock the chains
        void release()  # Unlock the chains
        void swap(graph_chains_t& r)
    cdef cppclass minsn_t:  # ------------------------------------------------------------
        mcode_t opcode  # instruction opcode
        int iprops  # combination of bits
        minsn_t* next  # next insn in doubly linked list. check also nexti(
        minsn_t* prev  # prev insn in doubly linked list. check also previ(
        ea_t ea  # instruction address
        mop_t l  # left operand
        mop_t r  # right operand
        mop_t d  # destination operand
        bint is_optional() const  # @ }
        bint is_combined() const
        bint is_farcall() const
        bint is_cleaning_pop() const
        bint is_extstx() const
        bint is_tailcall() const
        bint is_fpinsn() const
        bint is_assert() const
        bint is_persistent() const
        bint is_wild_match() const
        bint is_propagatable() const
        bint is_ignlowsrc() const
        bint is_inverted_jx() const
        bint was_noret_icall() const
        bint is_multimov() const
        bint is_combinable() const
        bint was_split() const
        bint is_mbarrier() const
        bint was_unmerged() const
        bint was_unpaired() const
        void set_optional()
        void set_combined()
        void clr_combined()
        void set_farcall()
        void set_cleaning_pop()
        void set_extstx()
        void set_tailcall()
        void clr_tailcall()
        void set_fpinsn()
        void clr_fpinsn()
        void set_assert()
        void clr_assert()
        void set_persistent()
        void set_wild_match()
        void clr_propagatable()
        void set_ignlowsrc()
        void clr_ignlowsrc()
        void set_inverted_jx()
        void set_noret_icall()
        void clr_noret_icall()
        void set_multimov()
        void clr_multimov()
        void set_combinable()
        void clr_combinable()
        void set_mbarrier()
        void set_unmerged()
        void set_split_size(int s)
        int get_split_size() const
        minsn_t(ea_t _ea)  # Constructor
        minsn_t(minsn_t& m)
        minsn_t& operator=(minsn_t& m)  # Assignment operator. It does not copy prev/next fi
        void swap(minsn_t& m)  # Swap two instructions. The prev/next fields are no
        void print(qstring* vout, int shins_flags) const  # Generate insn text into the buffer
        char* dstr() const  # Get displayable text without tags in a static buff
        void setaddr(ea_t new_ea)  # Change the instruction address. This function modi
        int optimize_solo(int optflags)  # Optimize one instruction without context. This fun
        int optimize_subtree(mblock_t* blk, minsn_t* top, minsn_t* parent, ea_t* converted_call, int optflags)  # Optimize instruction in its context. Do not use th
        int for_all_ops(mop_visitor_t& mv)  # Visit all instruction operands. This function visi
        int for_all_insns(minsn_visitor_t& mv)  # Visit all instructions. This function visits the i
        void _make_nop()  # Convert instruction to nop. This function erases a
        bint equal_insns(minsn_t& m, int eqflags) const  # Compare instructions. This is the main comparison 
        bint operator<(minsn_t& ri) const  # Lexographical comparison It can be used to store m
        int lexcompare(minsn_t& ri) const
        bint is_noret_call(int flags)  # --------------------------------------------------
        bint is_unknown_call() const  # Is an unknown call? Unknown calls are calls withou
        bint is_helper(char* name) const  # Is a helper call with the specified name? Helper c
        minsn_t* find_call(bint with_helpers) const  # Find a call instruction. Check for the current ins
        bint contains_call(bint with_helpers) const  # Does the instruction contain a call?
        bint has_side_effects(bint include_ldx_and_divs) const  # Does the instruction have a side effect? 
        funcrole_t get_role() const  # Get the function role of a call
        bint is_memcpy() const
        bint is_memset() const
        bint is_alloca() const
        bint is_bswap() const
        bint is_readflags() const
        bint contains_opcode(mcode_t mcode) const  # --------------------------------------------------
        minsn_t* find_opcode(mcode_t mcode) const  # Find a (sub)insruction with the specified opcode. 
        minsn_t* find_opcode(mcode_t mcode)
        minsn_t* find_ins_op(mop_t** other, mcode_t op) const  # Find an operand that is a subinsruction with the s
        minsn_t* find_ins_op(mop_t** other, mcode_t op)
        mop_t* find_num_op(mop_t** other) const  # Find a numeric operand of the current instruction.
        mop_t* find_num_op(mop_t** other)
        bint is_mov() const
        bint is_like_move() const
        bint modifies_d() const  # Does the instruction modify its 'd' operand? Some 
        bint modifies_pair_mop() const
        bint is_between(minsn_t* m1, minsn_t* m2) const  # Is the instruction in the specified range of instr
        bint is_after(minsn_t* m) const  # Is the instruction after the specified one? 
        bint may_use_aliased_memory() const  # Is it possible for the instruction to use aliased 
        int serialize(bytevec_t* b) const  # Serialize an instruction 
        bint deserialize(uchar* bytes, size_t nbytes, int format_version)  # Deserialize an instruction 
    cdef cppclass intval64_t:  # ------------------------------------------------------------
        uint64 val
        int size  # in bytes
        intval64_t(uint64 v, int _s)
        int64 sval() const
        uint64 uval() const
        void print(qstring* vout) const
        bint operator==(intval64_t& o) const  # --------------------------------------------------
        bint operator!=(intval64_t& o) const  # --------------------------------------------------
        bint operator<(intval64_t& o) const  # --------------------------------------------------
        intval64_t sext(int target_sz) const  # --------------------------------------------------
        intval64_t zext(int target_sz) const  # --------------------------------------------------
        intval64_t low(int target_sz) const  # --------------------------------------------------
        intval64_t high(int target_sz) const  # --------------------------------------------------
        intval64_t operator+(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator-(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator*(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator/(intval64_t& o) const  # --------------------------------------------------
        intval64_t sdiv(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator%(intval64_t& o) const  # --------------------------------------------------
        intval64_t smod(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator<<(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator>>(intval64_t& o) const  # --------------------------------------------------
        intval64_t sar(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator|(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator&(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator^(intval64_t& o) const  # --------------------------------------------------
        intval64_t operator-() const  # --------------------------------------------------
        intval64_t operator!() const  # --------------------------------------------------
        intval64_t operator~() const  # --------------------------------------------------
    cdef cppclass int64_emulator_t:  # ------------------------------------------------------------
        intval64_t get_mop_value(mop_t& mop)  # Retreive the value assigned to an operand. This fu
        intval64_t mop_value(mop_t& mop)  # Calculate the operand value. For register/stack/me
        intval64_t minsn_value(minsn_t& insn)  # Calculate the result of applying the instruction o
        int64_emulator_t& operator=(int64_emulator_t&)
    cdef cppclass mblock_t:  # ------------------------------------------------------------
        mblock_t* nextb  # next block in the doubly linked list
        mblock_t* prevb  # previous block in the doubly linked list
        uint32 flags  # combination of bits
        ea_t start  # start address
        ea_t end  # end address note: we cannot rely on start/end addr
        minsn_t* head  # pointer to the first instruction of the block
        minsn_t* tail  # pointer to the last instruction of the block
        mba_t* mba  # the parent micro block array
        int serial  # block number
        mblock_type_t type  # block type (BLT_NONE - not computed yet)
        mlist_t dead_at_start  # data that is dead at the block entry
        mlist_t mustbuse  # data that must be used by the block
        mlist_t maybuse  # data that may  be used by the block
        mlist_t mustbdef  # data that must be defined by the block
        mlist_t maybdef  # data that may  be defined by the block
        mlist_t dnu  # data that is defined but not used in the block
        sval_t maxbsp  # maximal sp value in the block (0...stacksize)
        sval_t minbstkref  # lowest stack location accessible with indirect add
        sval_t minbargref  # the same for arguments
        intvec_t predset  # control flow graph: list of our predecessors use n
        intvec_t succset  # control flow graph: list of our successors use nsu
        void mark_lists_dirty()
        void request_propagation()
        bint needs_propagation() const
        void request_demote64()
        bint lists_dirty() const
        bint lists_ready() const
        int make_lists_ready()
        int npred() const  # Get number of block predecessors
        int nsucc() const  # Get number of block successors
        int pred(int n) const  # Get predecessor number N
        int succ(int n) const  # Get successor number N
        mblock_t()
        bint empty() const
        void print(vd_printer_t& vp) const  # Print block contents. 
        void dump() const  # Dump block info. This function is useful for debug
        void dump_block(char* title) const
        minsn_t* insert_into_block(minsn_t* nm, minsn_t* om)  # --------------------------------------------------
        minsn_t* remove_from_block(minsn_t* m)  # Remove instruction from the doubly linked list 
        int for_all_insns(minsn_visitor_t& mv)  # --------------------------------------------------
        int for_all_ops(mop_visitor_t& mv)  # Visit all operands. This function visit subinstruc
        int for_all_uses(mlist_t* list, minsn_t* i1, minsn_t* i2, mlist_mop_visitor_t& mmv)  # Visit all operands that use LIST. 
        int optimize_insn(minsn_t* m, int optflags)  # --------------------------------------------------
        int optimize_block()  # Optimize a basic block. Usually there is no need t
        int build_lists(bint kill_deads)  # Build def-use lists and eliminate deads. 
        int optimize_useless_jump()  # Remove a jump at the end of the block if it is use
        void append_use_list(mlist_t* list, mop_t& op, maymust_t maymust, bitrange_t mask) const  # --------------------------------------------------
        void append_def_list(mlist_t* list, mop_t& op, maymust_t maymust) const  # Append def-list of an operand. This function calcu
        mlist_t build_use_list(minsn_t& ins, maymust_t maymust) const  # Build use-list of an instruction. This function ca
        mlist_t build_def_list(minsn_t& ins, maymust_t maymust) const  # Build def-list of an instruction. This function ca
        bint is_used(mlist_t* list, minsn_t* i1, minsn_t* i2, maymust_t maymust) const  # --------------------------------------------------
        minsn_t* find_first_use(mlist_t* list, minsn_t* i1, minsn_t* i2, maymust_t maymust) const  # Find the first insn that uses the specified list i
        minsn_t* find_first_use(mlist_t* list, minsn_t* i1, minsn_t* i2, maymust_t maymust) const
        bint is_redefined(mlist_t& list, minsn_t* i1, minsn_t* i2, maymust_t maymust) const  # Is the list redefined by the specified instruction
        minsn_t* find_redefinition(mlist_t& list, minsn_t* i1, minsn_t* i2, maymust_t maymust) const  # Find the first insn that redefines any part of the
        minsn_t* find_redefinition(mlist_t& list, minsn_t* i1, minsn_t* i2, maymust_t maymust) const
        bint is_rhs_redefined(minsn_t* ins, minsn_t* i1, minsn_t* i2) const  # Is the right hand side of the instruction redefine
        minsn_t* find_access(mop_t& op, minsn_t** parent, minsn_t* mend, int fdflags) const  # Find the instruction that accesses the specified o
        minsn_t* find_def(mop_t& op, minsn_t** p_i1, minsn_t* i2, int fdflags)  # Convenience functions:
        minsn_t* find_use(mop_t& op, minsn_t** p_i1, minsn_t* i2, int fdflags)
        bint get_valranges(valrng_t* res, vivl_t& vivl, int vrflags) const  # Find possible values for a block. 
        bint get_valranges(valrng_t* res, vivl_t& vivl, minsn_t* m, int vrflags) const  # Find possible values for an instruction. 
        void make_nop(minsn_t* m)  # Erase the instruction (convert it to nop) and mark
        size_t get_reginsn_qty() const  # Calculate number of regular instructions in the bl
        bint is_call_block() const
        bint is_unknown_call() const
        bint is_nway() const
        bint is_branch() const
        bint is_simple_goto_block() const
        bint is_simple_jcnd_block() const
    cdef cppclass hexwarn_t:  # Warning instances
        ea_t ea  # Address where the warning occurred
        warnid_t id  # Warning id
        qstring text  # Fully formatted text of the warning
        bint operator==(hexwarn_t& r) const
        bint operator!=(hexwarn_t& r) const
        bint operator<(hexwarn_t& r) const
        bint operator>(hexwarn_t& r) const
        bint operator<=(hexwarn_t& r) const
        bint operator>=(hexwarn_t& r) const
        int compare(hexwarn_t& r) const
    cdef cppclass mba_ranges_t:  # ------------------------------------------------------------
        func_t* pfn  # function to decompile. if not null, then function 
        rangevec_t ranges  # snippet mode: ranges to decompile. function mode: 
        mba_ranges_t(func_t* _pfn)
        mba_ranges_t(rangevec_t& r)
        ea_t start() const
        bint empty() const
        void clear()
        bint is_snippet() const
        bint range_contains(ea_t ea) const
        bint is_fragmented() const
        mba_ranges_t(mba_ranges_t&)
        mba_ranges_t(mba_ranges_t&&)
    cdef cppclass range_item_iterator_t:  # Item iterator of arbitrary rangevec items
        rangevec_t* ranges
        range_t* rptr  # pointer into ranges
        ea_t cur  # current address
        bint set(rangevec_t& r)
        bint next_code()
        ea_t current() const
    cdef cppclass mba_item_iterator_t:  # Item iterator for mba_ranges_t
        range_item_iterator_t rii
        func_item_iterator_t fii
        bint func_items_done
        bint set(mba_ranges_t& mbr)
        bint next_code()
        ea_t current() const
    cdef cppclass range_chunk_iterator_t:  # Chunk iterator of arbitrary rangevec items
        range_t* rptr  # pointer into ranges
        range_t* rend
        bint set(rangevec_t& r)
        bint next()
        range_t& chunk() const
        range_chunk_iterator_t(range_chunk_iterator_t&)
        range_chunk_iterator_t(range_chunk_iterator_t&&)
        range_chunk_iterator_t& operator=(range_chunk_iterator_t&)
        range_chunk_iterator_t& operator=(range_chunk_iterator_t&&)
    cdef cppclass mba_range_iterator_t:  # Chunk iterator for mba_ranges_t
        range_chunk_iterator_t rii
        func_tail_iterator_t fii  # this is used if rii.rptr==nullptr
        bint is_snippet() const
        bint set(mba_ranges_t& mbr)
        bint next()
        range_t& chunk() const
        mba_range_iterator_t(mba_range_iterator_t&)
        mba_range_iterator_t(mba_range_iterator_t&&)
        mba_range_iterator_t& operator=(mba_range_iterator_t&&)
    cdef cppclass mba_t:  # ------------------------------------------------------------
        mba_ranges_t mbr
        ea_t entry_ea
        ea_t last_prolog_ea
        ea_t first_epilog_ea
        int qty  # number of basic blocks
        int npurged  # -1 - unknown
        callcnv_t cc  # calling convention
        sval_t tmpstk_size  # size of the temporary stack part (which dynamicall
        sval_t frsize  # size of local stkvars range in the stack frame
        sval_t frregs  # size of saved registers range in the stack frame
        sval_t fpd  # frame pointer delta
        int pfn_flags  # copy of func_t::flags
        int retsize  # size of return address in the stack frame
        int shadow_args  # size of shadow argument area
        sval_t fullsize  # Full stack size including incoming args
        sval_t stacksize  # The maximal size of the function stack including b
        sval_t inargoff  # offset of the first stack argument; after fix_scat
        sval_t minstkref  # The lowest stack location whose address was taken
        ea_t minstkref_ea  # address with lowest minstkref (for debugging)
        sval_t minargref  # The lowest stack argument location whose address w
        sval_t spd_adjust  # If sp>0, the max positive sp value
        ivlset_t gotoff_stkvars  # stkvars that hold .got offsets. considered to be u
        ivlset_t restricted_memory
        ivlset_t aliased_memory  # aliased_memory+restricted_memory=ALLMEM
        mlist_t nodel_memory  # global dead elimination may not delete references 
        rlist_t consumed_argregs  # registers converted into stack arguments, should n
        mba_maturity_t maturity  # current maturity level
        mba_maturity_t reqmat  # required maturity level
        bint final_type  # is the function type final? (specified by the user
        tinfo_t idb_type  # function type as retrieved from the database
        reginfovec_t idb_spoiled  # MBA_SPLINFO & & final_type: info in ida format
        mlist_t spoiled_list  # MBA_SPLINFO & & !final_type: info in vd format
        int fti_flags  # FTI_... constants for the current function
        qstring label  # name of the function or pattern (colored)
        lvars_t vars  # local variables
        intvec_t argidx  # input arguments (indexes into 'vars')
        int retvaridx  # index of variable holding the return value -1 mean
        ea_t error_ea  # during microcode generation holds ins.ea
        qstring error_strarg
        mblock_t* blocks  # double linked list of blocks
        mblock_t** natural  # natural order of blocks
        hexwarns_t notes
        bint precise_defeas() const
        bint optimized() const
        bint short_display() const
        bint show_reduction() const
        bint graph_insns() const
        bint loaded_gdl() const
        bint should_beautify() const
        bint rtype_refined() const
        bint may_refine_rettype() const
        bint use_wingraph32() const
        bint display_numaddrs() const
        bint display_valnums() const
        bint is_pattern() const
        bint is_thunk() const
        bint saverest_done() const
        bint callinfo_built() const
        bint really_alloc() const
        bint lvars_allocated() const
        bint chain_varnums_ok() const
        bint returns_fpval() const
        bint has_passregs() const
        bint generated_asserts() const
        bint propagated_asserts() const
        bint deleted_pairs() const
        bint common_stkvars_stkargs() const
        bint lvar_names_ok() const
        bint lvars_renamed() const
        bint has_over_chains() const
        bint valranges_done() const
        bint argidx_ok() const
        bint argidx_sorted() const
        bint code16_bit_removed() const
        bint has_stack_retval() const
        bint has_outlines() const
        bint is_ctr() const
        bint is_dtr() const
        bint is_cdtr() const
        bint prop_complex() const
        int get_mba_flags() const
        int get_mba_flags2() const
        void set_mba_flags(int f)
        void clr_mba_flags(int f)
        void set_mba_flags2(int f)
        void clr_mba_flags2(int f)
        void clr_cdtr()
        int calc_shins_flags() const
        sval_t stkoff_vd2ida(sval_t off) const  # convert a stack offset used in vd to a stack offse
        sval_t stkoff_ida2vd(sval_t off) const  # convert a ida stack frame offset to a stack offset
        sval_t argbase() const
        vdloc_t idaloc2vd(argloc_t& loc, int width, sval_t spd)
        vdloc_t idaloc2vd(argloc_t& loc, int width) const
        argloc_t vd2idaloc(vdloc_t& loc, int width, sval_t spd)
        argloc_t vd2idaloc(vdloc_t& loc, int width) const
        bint is_stkarg(lvar_t& v) const
        ssize_t get_stkvar(udm_t* udm, sval_t vd_stkoff, uval_t* p_idaoff, tinfo_t* p_frame) const
        argloc_t get_ida_argloc(lvar_t& v) const  # get lvar location
        bint write_to_const_detected() const
        bint bad_call_sp_detected() const
        bint regargs_is_not_aligned() const
        bint has_bad_sp() const
        mba_t()
        void term()
        func_t* get_curfunc() const
        bint use_frame() const
        bint range_contains(ea_t ea) const
        bint is_snippet() const
        merror_t set_maturity(mba_maturity_t mat)  # Set maturity level. 
        int optimize_local(int locopt_bits)  # Optimize each basic block locally 
        merror_t build_graph()  # Build control flow graph. This function may be cal
        mbl_graph_t* get_graph()  # Get control graph. Call build_graph() if you need 
        int analyze_calls(int acflags)  # Analyze calls and determine calling conventions. 
        merror_t optimize_global()  # Optimize microcode globally. This function applies
        void alloc_lvars()  # Allocate local variables. Must be called only imme
        void dump() const  # Dump microcode to a file. The file will be created
        void dump_mba(bint _verify, char* title) const
        void print(vd_printer_t& vp) const  # Print microcode to any destination. 
        void verify(bint always) const  # Verify microcode consistency. 
        void mark_chains_dirty()  # Mark the microcode use-def chains dirty. Call this
        mblock_t* get_mblock(uint n) const  # Get basic block by its serial number.
        mblock_t* get_mblock(uint n)
        mblock_t* insert_block(int bblk)  # Insert a block in the middle of the mbl array. The
        mblock_t* split_block(mblock_t* blk, minsn_t* start_insn)  # Split a block: insert a new one after the block, m
        bint remove_block(mblock_t* blk)  # Delete a block. 
        bint remove_blocks(int start_blk, int end_blk)
        mblock_t* copy_block(mblock_t* blk, int new_serial, int cpblk_flags)  # Make a copy of a block. This function makes a simp
        bint remove_empty_and_unreachable_blocks()  # Delete all empty and unreachable blocks. Blocks ma
        bint merge_blocks()  # Merge blocks. This function merges blocks constitu
        int for_all_ops(mop_visitor_t& mv)  # Visit all operands of all instructions. 
        int for_all_insns(minsn_visitor_t& mv)  # Visit all instructions. This function visits all i
        int for_all_topinsns(minsn_visitor_t& mv)  # Visit all top level instructions. 
        mop_t* find_mop(op_parent_info_t* ctx, ea_t ea, bint is_dest, mlist_t& list)  # Find an operand in the microcode. This function tr
        minsn_t* create_helper_call(ea_t ea, char* helper, tinfo_t* rettype, mcallargs_t* callargs, mop_t* out)  # Create a call of a helper function. 
        void get_func_output_lists(mlist_t* return_regs, mlist_t* spoiled, tinfo_t& type, ea_t call_ea, bint tail_call)  # Prepare the lists of registers & memory that are d
        lvar_t& arg(int n)  # Get input argument of the decompiled function. 
        lvar_t& arg(int n) const
        ea_t alloc_fict_ea(ea_t real_ea)  # Allocate a fictional address. This function can be
        ea_t map_fict_ea(ea_t fict_ea) const  # Resolve a fictional address. This function provide
        ivl_t& get_std_region(memreg_index_t idx) const  # Get information about various memory regions. We m
        ivl_t& get_lvars_region() const
        ivl_t& get_shadow_region() const
        ivl_t& get_args_region() const
        ivl_t get_stack_region() const
        void serialize(bytevec_t& vout) const  # Serialize mbl array into a sequence of bytes.
        mba_t* deserialize(uchar* bytes, size_t nbytes)  # Deserialize a byte sequence into mbl array. 
        void save_snapshot(char* description)  # Create and save microcode snapshot
        mreg_t alloc_kreg(size_t size, bint check_size)  # Allocate a kernel register. 
        void free_kreg(mreg_t reg, size_t size)  # Free a kernel register. If wrong arguments are pas
        merror_t inline_func(codegen_t& cdg, int blknum, mba_ranges_t& ranges, int decomp_flags, int inline_flags)  # @ } Inline a range. This function may be called on
        stkpnt_t* locate_stkpnt(ea_t ea) const  # Find a sp change point. returns stkpnt p, where p-
        bint set_lvar_name(lvar_t& v, char* name, int flagbits)
        bint set_nice_lvar_name(lvar_t& v, char* name)
        bint set_user_lvar_name(lvar_t& v, char* name)
    cdef cppclass chain_keeper_t:  # ------------------------------------------------------------
        chain_keeper_t(graph_chains_t* _gc)
        block_chains_t& operator[](size_t idx)
        block_chains_t& front()
        block_chains_t& back()
        int for_all_chains(chain_visitor_t& cv, int gca)
    cdef cppclass mbl_graph_t:  # ------------------------------------------------------------
        bint is_ud_chain_dirty(gctype_t gctype)  # Is the use-def chain of the specified kind dirty?
        bint is_du_chain_dirty(gctype_t gctype)  # Is the def-use chain of the specified kind dirty?
        int get_chain_stamp() const
        graph_chains_t* get_ud(gctype_t gctype)  # Get use-def chains.
        graph_chains_t* get_du(gctype_t gctype)  # Get def-use chains.
        bint is_redefined_globally(mlist_t& list, int b1, int b2, minsn_t* m1, minsn_t* m2, maymust_t maymust) const  # Is LIST redefined in the graph?
        bint is_used_globally(mlist_t& list, int b1, int b2, minsn_t* m1, minsn_t* m2, maymust_t maymust) const  # Is LIST used in the graph?
        mblock_t* get_mblock(int n) const
        mbl_graph_t& operator=(mbl_graph_t&)
        mbl_graph_t& operator=(mbl_graph_t&&)
    cdef cppclass cdg_insn_iterator_t:  # ------------------------------------------------------------
        mba_t* mba  # to check range
        ea_t ea  # next insn to decode
        ea_t end  # end of the block
        ea_t dslot  # address of the insn in the delay slot
        insn_t dslot_insn  # instruction in the delay slot
        ea_t severed_branch  # address of the severed branch insn
        bint is_likely_dslot  # execute delay slot only when jumping
        cdg_insn_iterator_t(mba_t* mba_)
        cdg_insn_iterator_t(cdg_insn_iterator_t& r)
        cdg_insn_iterator_t& operator=(cdg_insn_iterator_t& r)
        bint ok() const
        bint has_dslot() const
        bint dslot_with_xrefs() const
        bint is_severed_dslot() const  # the current insn is the severed delayed insn (when
        void start(range_t& rng)
        merror_t next(insn_t* ins)
    cdef cppclass codegen_t:  # ------------------------------------------------------------
        mba_t* mba  # ptr to mbl array
        mblock_t* mb  # current basic block
        insn_t insn  # instruction to generate microcode for
        char ignore_micro  # value of get_ignore_micro() for the insn
        cdg_insn_iterator_t ii  # instruction iterator
        codegen_t()
        void clear()
        merror_t analyze_prolog(qflow_chart_t& fc, bitset_t& reachable)  # Analyze prolog/epilog of the function to decompile
        merror_t gen_micro()  # Generate microcode for one instruction. The instru
        mreg_t load_operand(int opnum, int flags)  # Generate microcode to load one operand. 
        void microgen_completed()  # This method is called when the microcode generatio
        merror_t prepare_gen_micro()  # Setup internal data to handle new instruction. Thi
        mreg_t load_effective_address(int n, int flags)  # Generate microcode to calculate the address of a m
        bint store_operand(int n, mop_t& mop, int flags, minsn_t** outins)  # Generate microcode to store an operand. In case of
        minsn_t* emit(mcode_t code, int width, uval_t l, uval_t r, uval_t d, int offsize)  # Emit one microinstruction. The L, R, D arguments u
        minsn_t* emit_micro_mvm(mcode_t code, op_dtype_t dtype, uval_t l, uval_t r, uval_t d, int offsize)  # Emit one microinstruction. This variant takes a da
        minsn_t* emit(mcode_t code, mop_t* l, mop_t* r, mop_t* d)  # Emit one microinstruction. This variant accepts po
        codegen_t(codegen_t&)
        codegen_t& operator=(codegen_t&)
    cdef cppclass hexrays_failure_t:  # Exception object: decompiler failure information
        merror_t code
        ea_t errea  # associated address
        qstring str  # string information
        hexrays_failure_t()
        hexrays_failure_t(merror_t c, ea_t ea, char* buf)
        hexrays_failure_t(merror_t c, ea_t ea, qstring& buf)
        qstring desc() const
    cdef cppclass vd_failure_t:  # Exception object: decompiler exception
        hexrays_failure_t hf
        vd_failure_t()
        vd_failure_t(merror_t code, ea_t ea, char* buf)
        vd_failure_t(merror_t code, ea_t ea, qstring& buf)
        vd_failure_t(hexrays_failure_t& _hf)
        qstring desc() const
        vd_failure_t(vd_failure_t&)
        vd_failure_t& operator=(vd_failure_t&)
    cdef cppclass vd_interr_t:  # Exception object: decompiler internal error
        vd_interr_t(ea_t ea, qstring& buf)
        vd_interr_t(ea_t ea, char* buf)
        vd_interr_t(vd_interr_t&)
        vd_interr_t(vd_interr_t&&)
        vd_interr_t& operator=(vd_interr_t&)
        vd_interr_t& operator=(vd_interr_t&&)
    cdef cppclass gco_info_t:  # Result of get_current_operand()
        qstring name  # register or stkvar name
        sval_t stkoff  # if stkvar, stack offset
        int regnum  # if register, the register id
        int size  # operand size
        int flags
        bint is_reg() const
        bint is_use() const
        bint is_def() const
        bint append_to_list(mlist_t* list, mba_t* mba) const  # Append operand info to LIST. This function convert
        vivl_t cvt_to_ivl() const  # Convert operand info to VIVL. The returned VIVL ca
    cdef cppclass cnumber_t:  # An immediate number
        uint64 _value  # its value
        number_format_t nf  # how to represent it
        cnumber_t(int _opnum)
        void print(qstring* vout, tinfo_t& type, citem_t* parent, bint* nice_stroff) const  # Get text representation 
        uint64 value(tinfo_t& type) const  # Get value. This function will properly extend the 
        void assign(uint64 v, int nbytes, type_sign_t sign)  # Assign new value 
        bint operator==(cnumber_t& r) const
        bint operator!=(cnumber_t& r) const
        bint operator<(cnumber_t& r) const
        bint operator>(cnumber_t& r) const
        bint operator<=(cnumber_t& r) const
        bint operator>=(cnumber_t& r) const
        int compare(cnumber_t& r) const
    cdef cppclass var_ref_t:  # Reference to a local variable
        mba_t* mba  # pointer to the underlying micro array
        int idx  # index into lvars_t
        lvar_t& getv() const
        bint operator==(var_ref_t& r) const
        bint operator!=(var_ref_t& r) const
        bint operator<(var_ref_t& r) const
        bint operator>(var_ref_t& r) const
        bint operator<=(var_ref_t& r) const
        bint operator>=(var_ref_t& r) const
        int compare(var_ref_t& r) const
    cdef cppclass treeloc_t:  # Ctree location. Used to denote comment locations.
        ea_t ea
        item_preciser_t itp
        bint operator<(treeloc_t& r) const
        bint operator==(treeloc_t& r) const
    cdef cppclass citem_cmt_t:  # Ctree item comment. For each comment we remember its body an
        bint used  # the comment has been retrieved?
        citem_cmt_t()
        citem_cmt_t(char* s)
    cdef cppclass citem_locator_t:  # Generic ctree item locator. It can be used for instructions 
        ea_t ea  # citem address
        ctype_t op  # citem operation
        citem_locator_t()
        citem_locator_t(ea_t _ea, ctype_t _op)
        citem_locator_t(citem_t* i)
        bint operator==(citem_locator_t& r) const
        bint operator!=(citem_locator_t& r) const
        bint operator<(citem_locator_t& r) const
        bint operator>(citem_locator_t& r) const
        bint operator<=(citem_locator_t& r) const
        bint operator>=(citem_locator_t& r) const
        int compare(citem_locator_t& r) const
        citem_locator_t(citem_locator_t&)
        citem_locator_t(citem_locator_t&&)
    cdef cppclass bit_bound_t:  # ------------------------------------------------------------
        int16 nbits  # total number of non-zero bits. we cannot guarantee
        int16 sbits  # number of sign bits (they can be either 0 or 1, al
        bit_bound_t(int n, int s)
        bit_bound_t(bit_bound_t&)
        bit_bound_t(bit_bound_t&&)
    cdef cppclass citem_t:  # ------------------------------------------------------------
        ea_t ea  # address that corresponds to the item. may be BADAD
        ctype_t op  # item type
        int label_num  # label number. -1 means no label. items of the expr
        int index  # an index in cfunc_t::treeitems. meaningful only af
        citem_t(ctype_t o)
        void swap(citem_t& r)  # Swap two citem_t
        bint is_expr() const  # Is an expression?
        bint contains_expr(cexpr_t* e) const  # Does the item contain an expression?
        bint contains_label() const  # Does the item contain a label?
        citem_t* find_parent_of(citem_t* item) const  # Find parent of the specified item. 
        citem_t* find_parent_of(citem_t* item)
        citem_t* find_closest_addr(ea_t _ea)
        void print1(qstring* vout, cfunc_t* func) const
        citem_t(citem_t&)
    cdef cppclass cexpr_t:  # Ctree item: expression. Depending on the exact expression it
        cnumber_t* n  # used for
        fnumber_t* fpc  # used for
        cinsn_t* insn  # an embedded statement, they are prohibited at the 
        char* helper  # helper name (used for
        char* string  # utf8 string constant, user representation (used fo
        tinfo_t type  # expression type. must be carefully maintained
        uint32 exflags
        bint cpadone() const  # @ } Pointer arithmetic correction done for this ex
        bint is_odd_lvalue() const
        bint is_fpop() const
        bint is_cstr() const
        bint is_type_partial() const
        bint is_undef_val() const
        bint is_jumpout() const
        bint is_vftable() const
        void set_cpadone()
        void set_vftable()
        void set_type_partial(bint val)
        cexpr_t()
        cexpr_t(ctype_t cexpr_op, cexpr_t* _x, cexpr_t* _y, cexpr_t* _z)
        cexpr_t(mba_t* mba, lvar_t& v)
        cexpr_t(cexpr_t& r)
        void swap(cexpr_t& r)
        cexpr_t& operator=(cexpr_t& r)
        cexpr_t& assign(cexpr_t& r)
        bint operator==(cexpr_t& r) const
        bint operator!=(cexpr_t& r) const
        bint operator<(cexpr_t& r) const
        bint operator>(cexpr_t& r) const
        bint operator<=(cexpr_t& r) const
        bint operator>=(cexpr_t& r) const
        int compare(cexpr_t& r) const
        void replace_by(cexpr_t* r)  # Replace the expression. The children of the expres
        void cleanup()  # Cleanup the expression. This function properly del
        void put_number(cfunc_t* func, uint64 value, int nbytes, type_sign_t sign)  # Assign a number to the expression. 
        void print1(qstring* vout, cfunc_t* func) const  # Print expression into one line. 
        void calc_type(bint recursive)  # Calculate the type of the expression. Use this fun
        bint equal_effect(cexpr_t& r) const  # Compare two expressions. This function tries to co
        bint is_child_of(citem_t* parent) const  # Verify if the specified item is our parent. 
        bint contains_operator(ctype_t needed_op, int times) const  # Check if the expression contains the specified ope
        bint contains_comma(int times) const  # Does the expression contain a comma operator?
        bint contains_insn(int times) const  # Does the expression contain an embedded statement 
        bint contains_insn_or_label() const  # Does the expression contain an embedded statement 
        bint contains_comma_or_insn_or_label(int maxcommas) const  # Does the expression contain a comma operator or an
        bint is_nice_expr() const  # Is nice expression? Nice expressions do not contai
        bint is_nice_cond() const  # Is nice condition?. Nice condition is a nice expre
        bint is_call_object_of(citem_t* parent) const  # Is call object? 
        bint is_call_arg_of(citem_t* parent) const  # Is call argument? 
        type_sign_t get_type_sign() const  # Get expression sign
        bint is_type_unsigned() const  # Is expression unsigned?
        bint is_type_signed() const  # Is expression signed?
        bit_bound_t get_high_nbit_bound() const  # Get max number of bits that can really be used by 
        int get_low_nbit_bound() const  # Get min number of bits that are certainly required
        bint requires_lvalue(cexpr_t* child) const  # Check if the expression requires an lvalue. 
        bint has_side_effects() const  # Check if the expression has side effects. Calls, p
        bint like_boolean() const  # Does the expression look like a boolean expression
        bint is_aliasable() const  # Check if the expression if aliasable. Simple regis
        uint64 numval() const  # Get numeric value of the expression. This function
        bint is_const_value(uint64 _v) const  # Check if the expression is a number with the speci
        bint is_negative_const() const  # Check if the expression is a negative number.
        bint is_non_negative_const() const  # Check if the expression is a non-negative number.
        bint is_non_zero_const() const  # Check if the expression is a non-zero number.
        bint is_zero_const() const  # Check if the expression is a zero.
        bint is_value_used(citem_t* parent) const  # Does the PARENT need the expression value
        bint get_const_value(uint64* out) const  # Get expression value. 
        bint maybe_ptr() const  # May the expression be a pointer?
        cexpr_t* get_ptr_or_array()  # Find pointer or array child.
        cexpr_t* find_op(ctype_t _op) const  # Find the child with the specified operator.
        cexpr_t* find_op(ctype_t _op)
        cexpr_t* find_num_op() const  # Find the operand with a numeric value
        cexpr_t* find_num_op()
        cexpr_t* find_ptr_or_array(bint remove_eqsize_casts) const  # Find the pointer operand. This function returns th
        cexpr_t* theother(cexpr_t* what) const  # Get the other operand. This function returns the o
        cexpr_t* theother(cexpr_t* what)
        bint get_1num_op(cexpr_t** o1, cexpr_t** o2)  # these are inline functions, see below
        bint get_1num_op(cexpr_t** o1, cexpr_t** o2) const
        char* dstr() const
    cdef cppclass ceinsn_t:  # Statement with an expression. This is a base class for vario
        cexpr_t expr  # Expression of the statement
        ceinsn_t(ceinsn_t&)
        ceinsn_t(ceinsn_t&&)
        ceinsn_t& operator=(ceinsn_t&)
        ceinsn_t& operator=(ceinsn_t&&)
        ceinsn_t()
    cdef cppclass cif_t:  # If statement
        cinsn_t* ithen  # Then-branch of the if-statement
        cinsn_t* ielse  # Else-branch of the if-statement. May be nullptr.
        cif_t()
        cif_t(cif_t& r)
        cif_t& operator=(cif_t& r)
        cif_t& assign(cif_t& r)
        bint operator==(cif_t& r) const
        bint operator!=(cif_t& r) const
        bint operator<(cif_t& r) const
        bint operator>(cif_t& r) const
        bint operator<=(cif_t& r) const
        bint operator>=(cif_t& r) const
        int compare(cif_t& r) const
        void cleanup()
    cdef cppclass cloop_t:  # Base class for loop statements
        cinsn_t* body
        cloop_t(cinsn_t* b)
        cloop_t(cloop_t& r)
        cloop_t& operator=(cloop_t& r)
        cloop_t& assign(cloop_t& r)
        void cleanup()
    cdef cppclass cfor_t:  # For-loop
        cexpr_t init  # Initialization expression
        cexpr_t step  # Step expression
        bint operator==(cfor_t& r) const
        bint operator!=(cfor_t& r) const
        bint operator<(cfor_t& r) const
        bint operator>(cfor_t& r) const
        bint operator<=(cfor_t& r) const
        bint operator>=(cfor_t& r) const
        int compare(cfor_t& r) const
        cfor_t(cfor_t&)
        cfor_t(cfor_t&&)
        cfor_t& operator=(cfor_t&)
        cfor_t& operator=(cfor_t&&)
    cdef cppclass cwhile_t:  # While-loop
        bint operator==(cwhile_t& r) const
        bint operator!=(cwhile_t& r) const
        bint operator<(cwhile_t& r) const
        bint operator>(cwhile_t& r) const
        bint operator<=(cwhile_t& r) const
        bint operator>=(cwhile_t& r) const
        int compare(cwhile_t& r) const
        cwhile_t(cwhile_t&)
        cwhile_t(cwhile_t&&)
        cwhile_t& operator=(cwhile_t&)
        cwhile_t& operator=(cwhile_t&&)
    cdef cppclass cdo_t:  # Do-loop
        bint operator==(cdo_t& r) const
        bint operator!=(cdo_t& r) const
        bint operator<(cdo_t& r) const
        bint operator>(cdo_t& r) const
        bint operator<=(cdo_t& r) const
        bint operator>=(cdo_t& r) const
        int compare(cdo_t& r) const
        cdo_t(cdo_t&)
        cdo_t(cdo_t&&)
        cdo_t& operator=(cdo_t&)
        cdo_t& operator=(cdo_t&&)
    cdef cppclass creturn_t:  # Return statement
        bint operator==(creturn_t& r) const
        bint operator!=(creturn_t& r) const
        bint operator<(creturn_t& r) const
        bint operator>(creturn_t& r) const
        bint operator<=(creturn_t& r) const
        bint operator>=(creturn_t& r) const
        int compare(creturn_t& r) const
    cdef cppclass cgoto_t:  # Goto statement
        int label_num  # Target label number
        void print(citem_t* parent, int indent, vc_printer_t& vp) const
        bint operator==(cgoto_t& r) const
        bint operator!=(cgoto_t& r) const
        bint operator<(cgoto_t& r) const
        bint operator>(cgoto_t& r) const
        bint operator<=(cgoto_t& r) const
        bint operator>=(cgoto_t& r) const
        int compare(cgoto_t& r) const
    cdef cppclass casm_t:  # asm statement
        casm_t(ea_t ea)
        casm_t(casm_t& r)
        bint operator==(casm_t& r) const
        bint operator!=(casm_t& r) const
        bint operator<(casm_t& r) const
        bint operator>(casm_t& r) const
        bint operator<=(casm_t& r) const
        bint operator>=(casm_t& r) const
        int compare(casm_t& r) const
        void print(citem_t* parent, int indent, vc_printer_t& vp) const
        bint one_insn() const
        void genasm(qstring* buf, ea_t ea) const
    cdef cppclass cinsn_t:  # Ctree item: statement. Depending on the exact statement type
        cblock_t* cblock  # details of block-statement
        cexpr_t* cexpr  # details of expression-statement
        cif_t* cif  # details of if-statement
        cfor_t* cfor  # details of for-statement
        cwhile_t* cwhile  # details of while-statement
        cdo_t* cdo  # details of do-statement
        cswitch_t* cswitch  # details of switch-statement
        creturn_t* creturn  # details of return-statement
        cgoto_t* cgoto  # details of goto-statement
        casm_t* casm  # details of asm-statement
        ctry_t* ctry  # details of try-statement
        cthrow_t* cthrow  # details of throw-statement
        cinsn_t()
        cinsn_t(cinsn_t& r)
        void swap(cinsn_t& r)
        cinsn_t& operator=(cinsn_t& r)
        cinsn_t& assign(cinsn_t& r)
        bint operator==(cinsn_t& r) const
        bint operator!=(cinsn_t& r) const
        bint operator<(cinsn_t& r) const
        bint operator>(cinsn_t& r) const
        bint operator<=(cinsn_t& r) const
        bint operator>=(cinsn_t& r) const
        int compare(cinsn_t& r) const
        void replace_by(cinsn_t* r)  # Replace the statement. The children of the stateme
        void cleanup()  # Cleanup the statement. This function properly dele
        void zero()  # Overwrite with zeroes without cleaning memory or d
        cinsn_t& new_insn(ea_t insn_ea)  # Create a new statement. The current statement must
        cif_t& create_if(cexpr_t* cnd)  # Create a new if-statement. The current statement m
        void print(int indent, vc_printer_t& vp, use_curly_t use_curly) const  # Print the statement into many lines. 
        void print1(qstring* vout, cfunc_t* func) const  # Print the statement into one line. Currently this 
        bint is_ordinary_flow() const  # Check if the statement passes execution to the nex
        bint contains_insn(ctype_t type, int times) const  # Check if the statement contains a statement of the
        bint collect_free_breaks(cinsnptrvec_t* breaks)  # Collect free statements. This function finds all f
        bint collect_free_continues(cinsnptrvec_t* continues)  # Collect free statements. This function finds all f
        bint contains_free_break() const  # Check if the statement has free statements.
        bint contains_free_continue() const  # Check if the statement has free statements.
        char* dstr() const
    cdef cppclass cblock_t:  # Compound statement (curly braces)
        bint operator==(cblock_t& r) const
        bint operator!=(cblock_t& r) const
        bint operator<(cblock_t& r) const
        bint operator>(cblock_t& r) const
        bint operator<=(cblock_t& r) const
        bint operator>=(cblock_t& r) const
        int compare(cblock_t& r) const
    cdef cppclass carg_t:  # Function argument
        bint is_vararg  # is a vararg (matches ...)
        tinfo_t formal_type  # formal parameter type (if known)
        void consume_cexpr(cexpr_t* e)
        bint operator==(carg_t& r) const
        bint operator!=(carg_t& r) const
        bint operator<(carg_t& r) const
        bint operator>(carg_t& r) const
        bint operator<=(carg_t& r) const
        bint operator>=(carg_t& r) const
        int compare(carg_t& r) const
        carg_t(carg_t&)
        carg_t(carg_t&&)
        carg_t& operator=(carg_t&)
        carg_t& operator=(carg_t&&)
    cdef cppclass carglist_t:  # Function argument list
        tinfo_t functype  # function object type
        int flags  # call flags
        carglist_t()
        carglist_t(tinfo_t& ftype, int fl)
        bint operator==(carglist_t& r) const
        bint operator!=(carglist_t& r) const
        bint operator<(carglist_t& r) const
        bint operator>(carglist_t& r) const
        bint operator<=(carglist_t& r) const
        bint operator>=(carglist_t& r) const
        int compare(carglist_t& r) const
        void print(qstring* vout, cfunc_t* func) const
        int print(int curpos, vc_printer_t& vp) const
        carglist_t(carglist_t&)
        carglist_t(carglist_t&&)
        carglist_t& operator=(carglist_t&)
        carglist_t& operator=(carglist_t&&)
    cdef cppclass ccase_t:  # Switch case. Usually cinsn_t is a block
        uint64vec_t values  # List of case values. if empty, then 'default' case
        bint operator==(ccase_t& r) const
        bint operator!=(ccase_t& r) const
        bint operator<(ccase_t& r) const
        bint operator>(ccase_t& r) const
        bint operator<=(ccase_t& r) const
        bint operator>=(ccase_t& r) const
        int compare(ccase_t& r) const
        void set_insn(cinsn_t* i)
        size_t size() const
        uint64& value(int i) const
        ccase_t(ccase_t&)
        ccase_t(ccase_t&&)
        ccase_t& operator=(ccase_t&)
        ccase_t& operator=(ccase_t&&)
    cdef cppclass ccases_t:  # Vector of switch cases
        bint operator==(ccases_t& r) const
        bint operator!=(ccases_t& r) const
        bint operator<(ccases_t& r) const
        bint operator>(ccases_t& r) const
        bint operator<=(ccases_t& r) const
        bint operator>=(ccases_t& r) const
        int compare(ccases_t& r) const
        int find_value(uint64 v) const
    cdef cppclass cswitch_t:  # Switch statement
        cnumber_t mvnf  # Maximal switch value and number format
        ccases_t cases  # Switch cases: values and instructions
        bint operator==(cswitch_t& r) const
        bint operator!=(cswitch_t& r) const
        bint operator<(cswitch_t& r) const
        bint operator>(cswitch_t& r) const
        bint operator<=(cswitch_t& r) const
        bint operator>=(cswitch_t& r) const
        int compare(cswitch_t& r) const
    cdef cppclass catchexpr_t:  # Catch expression
        cexpr_t obj  # the caught object. if obj.op==cot_empty, no object
        qstring fake_type  # if not empty, type of the caught object. ideally, 
        bint operator==(catchexpr_t& r) const
        bint operator!=(catchexpr_t& r) const
        bint operator<(catchexpr_t& r) const
        bint operator>(catchexpr_t& r) const
        bint operator<=(catchexpr_t& r) const
        bint operator>=(catchexpr_t& r) const
        int compare(catchexpr_t& r) const
        void swap(catchexpr_t& r)
        bint is_catch_all() const
        catchexpr_t(catchexpr_t&)
        catchexpr_t(catchexpr_t&&)
        catchexpr_t& operator=(catchexpr_t&)
        catchexpr_t& operator=(catchexpr_t&&)
    cdef cppclass ccatch_t:  # Catch clause: "catch ( type obj )"
        catchexprs_t exprs
        bint operator==(ccatch_t& r) const
        bint operator!=(ccatch_t& r) const
        bint operator<(ccatch_t& r) const
        bint operator>(ccatch_t& r) const
        bint operator<=(ccatch_t& r) const
        bint operator>=(ccatch_t& r) const
        int compare(ccatch_t& r) const
        bint is_catch_all() const
        void swap(ccatch_t& r)
    cdef cppclass ctry_t:  # C++ Try statement. This structure is also used to represent 
        ccatchvec_t catchs  # "catch all", if present, must be the last element.
        size_t old_state  # old state number (internal, MSVC related)
        size_t new_state  # new state number (internal, MSVC related)
        bint is_wind  # if false, then try/catch
        bint operator==(ctry_t& r) const
        bint operator!=(ctry_t& r) const
        bint operator<(ctry_t& r) const
        bint operator>(ctry_t& r) const
        bint operator<=(ctry_t& r) const
        bint operator>=(ctry_t& r) const
        int compare(ctry_t& r) const
        void print(citem_t* parent, int indent, vc_printer_t& vp) const
    cdef cppclass cthrow_t:  # Throw statement
        bint operator==(cthrow_t& r) const
        bint operator!=(cthrow_t& r) const
        bint operator<(cthrow_t& r) const
        bint operator>(cthrow_t& r) const
        bint operator<=(cthrow_t& r) const
        bint operator>=(cthrow_t& r) const
        int compare(cthrow_t& r) const
    cdef cppclass cblock_pos_t:  # ------------------------------------------------------------
        cblock_t* blk  # cinsn_t::cblock or cinsn_t::ctry or cinsn_t::ctry-
        int p  # iterator pointing to the current item
        bint is_first_insn() const
        cinsn_t* insn() const
        cinsn_t* prev_insn()
    cdef cppclass ctree_visitor_t:  # A generic helper class that is used for ctree traversal. Whe
        int cv_flags
        cblock_posvec_t bposvec  # Vector of block positions. Only cit_block and cit_
        bint maintain_parents() const  # @ } Should the parent information by maintained?
        bint must_prune() const  # Should the traversal skip the children of the curr
        bint must_restart() const  # Should the traversal restart?
        bint is_postorder() const  # Should the leave...() functions be called?
        bint only_insns() const  # Should all expressions be automatically pruned?
        void prune_now()  # Prune children. This function may be called by a v
        void clr_prune()  # Do not prune children. This is an internal functio
        void set_restart()  # Restart the travesal. Meaningful only in apply_to_
        void clr_restart()  # Do not restart. This is an internal function, no n
        ctree_visitor_t(int _flags)  # Constructor. This constructor can be used with CV_
        int apply_to(citem_t* item, citem_t* parent)  # Traverse ctree. The traversal will start at the sp
        int apply_to_exprs(citem_t* item, citem_t* parent)  # Traverse only expressions. The traversal will star
        citem_t* parent_item()  # Get parent of the current item as an item (stateme
        cexpr_t* parent_expr()  # Get parent of the current item as an expression
        cinsn_t* parent_insn()  # Get parent of the current item as a statement
        int visit_insn(cinsn_t*)  # Visit a statement. This is a visitor function whic
        int visit_expr(cexpr_t*)  # Visit an expression. This is a visitor function wh
        int leave_insn(cinsn_t*)  # Visit a statement after having visited its childre
        int leave_expr(cexpr_t*)  # Visit an expression after having visited its child
        ctree_visitor_t& operator=(ctree_visitor_t&)
        ctree_visitor_t(ctree_visitor_t&)
    cdef cppclass ctree_parentee_t:  # A helper ctree traversal class that maintains parent informa
        ctree_parentee_t(bint post)
        bint recalc_parent_types()  # Recalculate type of parent nodes. If a node type h
        ctree_parentee_t(ctree_parentee_t&)
        ctree_parentee_t(ctree_parentee_t&&)
        ctree_parentee_t& operator=(ctree_parentee_t&)
        ctree_parentee_t& operator=(ctree_parentee_t&&)
    cdef cppclass cfunc_parentee_t:  # Class to traverse the whole function.
        cfunc_t* func  # Pointer to current function
        cfunc_parentee_t(cfunc_t* f, bint post)
        bint calc_rvalue_type(tinfo_t* target, cexpr_t* e)  # Calculate rvalue type. This function tries to dete
        cfunc_parentee_t& operator=(cfunc_parentee_t&)
        cfunc_parentee_t& operator=(cfunc_parentee_t&&)
    cdef cppclass ctree_anchor_t:  # ------------------------------------------------------------
        uval_t value
        int get_index() const
        item_preciser_t get_itp() const
        bint is_valid_anchor() const
        bint is_citem_anchor() const
        bint is_lvar_anchor() const
        bint is_itp_anchor() const
        bint is_blkcmt_anchor() const
    cdef cppclass ctree_item_t:  # Cursor item. Information about the item under the cursor
        cursor_item_type_t citype  # Item type
        citem_t* it
        cexpr_t* e  # VDI_EXPR: Expression
        cinsn_t* i  # VDI_EXPR: Statement
        lvar_t* l  # VDI_LVAR: Local variable
        cfunc_t* f  # VDI_FUNC: Function
        treeloc_t loc  # VDI_TAIL: Line tail
        void verify(mba_t* mba) const
        int get_udm(udm_t* udm, tinfo_t* parent, uint64* p_offset) const  # Get type of a structure field. If the current item
        int get_edm(tinfo_t* parent) const  # Get type of an enum member. If the current item is
        lvar_t* get_lvar() const  # Get pointer to local variable. If the current item
        ea_t get_ea() const  # Get address of the current item. Each ctree item h
        int get_label_num(int gln_flags) const  # Get label number of the current item. 
        bint is_citem() const  # Is the current item is a ctree item?
        void print(qstring* vout) const
        char* dstr() const
    cdef cppclass cfunc_t:  # Tags to find this location quickly: #cfunc_t #func_t -------
        ea_t entry_ea  # function entry address
        mba_t* mba  # underlying microcode
        cinsn_t body  # function body, must be a block
        intvec_t& argidx  # list of arguments (indexes into vars)
        ctree_maturity_t maturity  # maturity level
        user_labels_t* user_labels  # user-defined labels.
        user_cmts_t* user_cmts  # user-defined comments.
        user_numforms_t* numforms  # user-defined number formats.
        user_iflags_t* user_iflags  # user-defined item flags
        user_unions_t* user_unions  # user-defined union field selections.
        int refcnt  # reference count to this object. use cfuncptr_t
        int statebits  # current cfunc_t state. see
        eamap_t* eamap  # ea->insn map. use
        boundaries_t* boundaries  # map of instruction boundaries. use
        strvec_t sv  # decompilation output: function text. use
        int hdrlines  # number of lines in the declaration area
        citem_pointers_t treeitems  # vector of pointers to citem_t objects (nodes const
        cfunc_t(mba_t* mba)
        void release()
        void build_c_tree()  # Generate the function body. This function (re)gene
        void verify(allow_unused_labels_t aul, bint even_without_debugger) const  # Verify the ctree. This function verifies the ctree
        void print_dcl(qstring* vout) const  # Print function prototype. 
        void print_func(vc_printer_t& vp) const  # Print function text. 
        bint get_func_type(tinfo_t* type) const  # Get the function type. 
        lvars_t* get_lvars()  # Get vector of local variables. 
        sval_t get_stkoff_delta()  # Get stack offset delta. The local variable stack o
        citem_t* find_label(int label)  # Find the label. 
        void remove_unused_labels()  # Remove unused labels. This function checks what la
        char* get_user_cmt(treeloc_t& loc, cmt_retrieval_type_t rt) const  # Retrieve a user defined comment. 
        void set_user_cmt(treeloc_t& loc, char* cmt)  # Set a user defined comment. This function stores t
        int32 get_user_iflags(citem_locator_t& loc) const  # Retrieve citem iflags. 
        void set_user_iflags(citem_locator_t& loc, int32 iflags)  # Set citem iflags. 
        bint has_orphan_cmts() const  # Check if there are orphan comments.
        int del_orphan_cmts()  # Delete all orphan comments. The save_user_cmts() f
        bint get_user_union_selection(ea_t ea, intvec_t* path)  # Retrieve a user defined union field selection. 
        void set_user_union_selection(ea_t ea, intvec_t& path)  # Set a union field selection. The save_user_unions(
        void save_user_labels() const  # Save user-defined labels into the database
        void save_user_cmts() const  # Save user-defined comments into the database
        void save_user_numforms() const  # Save user-defined number formats into the database
        void save_user_iflags() const  # Save user-defined iflags into the database
        void save_user_unions() const  # Save user-defined union field selections into the 
        bint get_line_item(char* line, int x, bint is_ctree_line, ctree_item_t* phead, ctree_item_t* pitem, ctree_item_t* ptail)  # Get ctree item for the specified cursor position. 
        hexwarns_t& get_warnings()  # Get information about decompilation warnings. 
        eamap_t& get_eamap()  # Get pointer to ea->insn map. This function initial
        boundaries_t& get_boundaries()  # Get pointer to map of instruction boundaries. This
        strvec_t& get_pseudocode()  # Get pointer to decompilation output: the pseudocod
        void refresh_func_ctext()  # Refresh ctext after a ctree modification. This fun
        void recalc_item_addresses()  # Recalculate item adresses. This function may be re
        bint gather_derefs(ctree_item_t& ci, udt_type_data_t* udm) const
        bint find_item_coords(citem_t* item, int* px, int* py)
        bint locked() const
    cdef cppclass ctext_position_t:  # ------------------------------------------------------------
        int lnnum  # Line number
        int x  # x coordinate of the cursor within the window
        int y  # y coordinate of the cursor within the window
        bint in_ctree(int hdrlines) const  # Is the cursor in the variable/type declaration are
        bint operator==(ctext_position_t& r) const  # Comparison operators
        bint operator!=(ctext_position_t& r) const  # Comparison operators
        bint operator<(ctext_position_t& r) const  # Comparison operators
        bint operator>(ctext_position_t& r) const  # Comparison operators
        bint operator<=(ctext_position_t& r) const  # Comparison operators
        bint operator>=(ctext_position_t& r) const  # Comparison operators
        int compare(ctext_position_t& r) const  # Comparison operators
        ctext_position_t(int _lnnum, int _x, int _y)
        ctext_position_t(ctext_position_t&)
        ctext_position_t(ctext_position_t&&)
    cdef cppclass history_item_t:  # Navigation history item. Holds information about interactive
        ea_t func_ea  # The entry address of the decompiled function
        ea_t curr_ea  # Current address
        ea_t end  # BADADDR-decompile a function; otherwise end of the
        history_item_t(ea_t fea, ea_t cea, int _lnnum, int _x, int _y)
        history_item_t(ea_t fea, ea_t cea, ctext_position_t& p)
    cdef cppclass vdui_t:  # ------------------------------------------------------------
        int flags
        int view_idx  # pseudocode window index (0..)
        TWidget* ct  # pseudocode view
        TWidget* toplevel
        mba_t* mba  # pointer to underlying microcode
        cfuncptr_t cfunc  # pointer to function object
        merror_t last_code  # result of the last user action. See
        ctext_position_t cpos  # Current ctext position
        ctree_item_t head  # First ctree item on the current line (for block co
        ctree_item_t item  # Current ctree item
        ctree_item_t tail  # Tail ctree item on the current line (for indented 
        bint visible() const  # Is the pseudocode window visible? if not, it might
        bint valid() const  # Does the pseudocode window contain valid code? It 
        bint locked() const  # Does the pseudocode window contain valid code? We 
        void set_visible(bint v)
        void set_valid(bint v)
        bint set_locked(bint v)
        vdui_t()
        void refresh_view(bint redo_mba)  # Refresh pseudocode window. This is the highest lev
        void refresh_ctext(bint activate)  # Refresh pseudocode window. This function refreshes
        void switch_to(cfuncptr_t f, bint activate)  # Display the specified pseudocode. This function re
        bint in_ctree() const  # Is the current item a statement? /
        cnumber_t* get_number()  # Get current number. If the current item is a numbe
        int get_current_label()  # Get current label. If there is a label under the c
        void clear()  # Clear the pseudocode window. It deletes the curren
        bint refresh_cpos(input_device_t idv)  # Refresh the current position. This function refres
        bint get_current_item(input_device_t idv)  # Get current item. This function refreshes the   fi
        bint ui_rename_lvar(lvar_t* v)  # Rename local variable. This function displays a di
        bint rename_lvar(lvar_t* v, char* name, bint is_user_name)  # Rename local variable. This function permanently r
        bint ui_set_call_type(cexpr_t* e)  # Set type of a function call This function displays
        bint ui_set_lvar_type(lvar_t* v)  # Set local variable type. This function displays a 
        bint set_lvar_type(lvar_t* v, tinfo_t& type)  # Set local variable type. This function permanently
        bint set_noptr_lvar(lvar_t* v)  # Inform that local variable should have a non-point
        bint ui_edit_lvar_cmt(lvar_t* v)  # Set local variable comment. This function displays
        bint set_lvar_cmt(lvar_t* v, char* cmt)  # Set local variable comment. This function permanen
        bint ui_map_lvar(lvar_t* v)  # Map a local variable to another. This function dis
        bint ui_unmap_lvar(lvar_t* v)  # Unmap a local variable. This function displays lis
        bint map_lvar(lvar_t* from_, lvar_t* to)  # Map a local variable to another. This function per
        bint set_udm_type(tinfo_t& udt_type, int udm_idx)  # Set structure field type. This function displays a
        bint rename_udm(tinfo_t& udt_type, int udm_idx)  # Rename structure field. This function displays a d
        bint set_global_type(ea_t ea)  # Set global item type. This function displays a dia
        bint rename_global(ea_t ea)  # Rename global item. This function displays a dialo
        bint rename_label(int label)  # Rename a label. This function displays a dialog bo
        bint jump_enter(input_device_t idv, int omflags)  # Process the Enter key. This function jumps to the 
        bint ctree_to_disasm()  # Jump to disassembly. This function jumps to the ad
        cmt_type_t calc_cmt_type(size_t lnnum, cmt_type_t cmttype) const  # Check if the specified line can have a comment. Du
        bint edit_cmt(treeloc_t& loc)  # Edit an indented comment. This function displays a
        bint edit_func_cmt()  # Edit a function comment. This function displays a 
        bint del_orphan_cmts()  # Delete all orphan comments. Delete all orphan comm
        bint set_num_radix(int base)  # Change number base. This function changes the curr
        bint set_num_enum()  # Convert number to symbolic constant. This function
        bint set_num_stroff()  # Convert number to structure field offset. Currentl
        bint invert_sign()  # Negate a number. This function negates the current
        bint invert_bits()  # Bitwise negate a number. This function inverts all
        bint collapse_item(bint hide)  # Collapse/uncollapse item. This function collapses 
        bint collapse_lvars(bint hide)  # Collapse/uncollapse local variable declarations. 
        bint split_item(bint split)  # Split/unsplit item. This function splits the curre
    cdef cppclass ui_stroff_op_t:  # Operand represention
        qstring text  # any text for the column "Operand" of widget
        uval_t offset  # operand offset, will be used when calculating the 
        bint operator==(ui_stroff_op_t& r) const
        bint operator!=(ui_stroff_op_t& r) const
    cdef cppclass ui_stroff_applicator_t:  # Callback to apply the selection 
        bint apply(size_t opnum, intvec_t& path, tinfo_t& top_tif, char* spath)
        ui_stroff_applicator_t& operator=(ui_stroff_applicator_t&)
    cdef cppclass user_numforms_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(user_numforms_iterator_t& p) const
        bint operator!=(user_numforms_iterator_t& p) const
        user_numforms_iterator_t()
        user_numforms_iterator_t(user_numforms_iterator_t&)
        user_numforms_iterator_t(user_numforms_iterator_t&&)
    cdef cppclass lvar_mapping_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(lvar_mapping_iterator_t& p) const
        bint operator!=(lvar_mapping_iterator_t& p) const
        lvar_mapping_iterator_t()
        lvar_mapping_iterator_t(lvar_mapping_iterator_t&)
        lvar_mapping_iterator_t(lvar_mapping_iterator_t&&)
    cdef cppclass udcall_map_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(udcall_map_iterator_t& p) const
        bint operator!=(udcall_map_iterator_t& p) const
        udcall_map_iterator_t()
        udcall_map_iterator_t(udcall_map_iterator_t&)
        udcall_map_iterator_t(udcall_map_iterator_t&&)
    cdef cppclass user_cmts_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(user_cmts_iterator_t& p) const
        bint operator!=(user_cmts_iterator_t& p) const
        user_cmts_iterator_t()
        user_cmts_iterator_t(user_cmts_iterator_t&)
        user_cmts_iterator_t(user_cmts_iterator_t&&)
    cdef cppclass user_iflags_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(user_iflags_iterator_t& p) const
        bint operator!=(user_iflags_iterator_t& p) const
        user_iflags_iterator_t()
        user_iflags_iterator_t(user_iflags_iterator_t&)
        user_iflags_iterator_t(user_iflags_iterator_t&&)
    cdef cppclass user_unions_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(user_unions_iterator_t& p) const
        bint operator!=(user_unions_iterator_t& p) const
        user_unions_iterator_t()
        user_unions_iterator_t(user_unions_iterator_t&)
        user_unions_iterator_t(user_unions_iterator_t&&)
    cdef cppclass user_labels_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(user_labels_iterator_t& p) const
        bint operator!=(user_labels_iterator_t& p) const
        user_labels_iterator_t()
        user_labels_iterator_t(user_labels_iterator_t&)
        user_labels_iterator_t(user_labels_iterator_t&&)
    cdef cppclass eamap_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(eamap_iterator_t& p) const
        bint operator!=(eamap_iterator_t& p) const
        eamap_iterator_t()
        eamap_iterator_t(eamap_iterator_t&)
        eamap_iterator_t(eamap_iterator_t&&)
    cdef cppclass boundaries_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(boundaries_iterator_t& p) const
        bint operator!=(boundaries_iterator_t& p) const
        boundaries_iterator_t()
        boundaries_iterator_t(boundaries_iterator_t&)
        boundaries_iterator_t(boundaries_iterator_t&&)
    cdef cppclass block_chains_iterator_t:  # ------------------------------------------------------------
        iterator_word x
        bint operator==(block_chains_iterator_t& p) const
        bint operator!=(block_chains_iterator_t& p) const
        block_chains_iterator_t()
        block_chains_iterator_t(block_chains_iterator_t&)
        block_chains_iterator_t(block_chains_iterator_t&&)

    # =========================================================================
    # Functions
    # =========================================================================
    int64 make_int64(uint32 ll, int32 hh)
    uint64 make_uint64(uint32 ll, int32 hh)
    uint32 low(uint64& x)
    uint32 high(uint64& x)
    int64 llong_scan(char* buf, int radix, char** end)
    uint64 swap64(uint64)
    int64 qatoll(char* nptr)
    void qexit(int code)  # Call qatexit functions, shut down UI and kernel, and exit. 
    bint test_bit(uchar* bitmap, asize_t bit)  # ---------------------------------------------------------...
    void set_bit(uchar* bitmap, asize_t bit)  # Set 'bit' in 'bitmap'
    void clear_bit(uchar* bitmap, asize_t bit)  # Clear 'bit' in 'bitmap'
    void set_bits(uchar* bitmap, asize_t low, asize_t high)  # Set bits between [low, high) in 'bitmap'
    void clear_bits(uchar* bitmap, asize_t low, asize_t high)  # Clear bits between [low, high) in 'bitmap'
    void set_all_bits(uchar* bitmap, asize_t nbits)  # Set first 'nbits' of 'bitmap'
    void clear_all_bits(uchar* bitmap, asize_t nbits)  # Clear first 'nbits' of 'bitmap'
    int log2ceil(uint64 d64)  # calculate ceil(log2(d64)) or floor(log2(d64)), it...
    int log2floor(uint64 d64)
    int bitcount(uint64 x)  # count the number of non-zero bits (the population count)
    int bitcountr_zero(uint64 x)  # count the number of consecutive trailing zero bits (line...
    uint32 round_up_power2(uint32 x)  # round up or down to a power of 2
    uint32 round_down_power2(uint32 x)
    uval_t last(uval_t off, asize_t s)  # max offset of the interval (assume s != 0)
    bint overlap(uval_t off1, asize_t s1, uval_t off2, asize_t s2)  # Do (off1,s1) and (off2,s2) overlap?
    bint includes(uval_t off1, asize_t s1, uval_t off2, asize_t s2)  # Does (off1,s1) include (off2,s2)?
    bint contains(uval_t off1, asize_t s1, uval_t off)  # Does (off1,s1) contain off?
    uint64 extend_sign(uint64 v, int nbytes, bint sign_extend)  # ---------------------------------------------------------...
    int readbytes(int h, uint32* res, int size, bint mf)  # ---------------------------------------------------------...
    int writebytes(int h, uint32 l, int size, bint mf)  # Write at most 4 bytes to file. 
    int read2bytes(int h, uint16* res, bint mf)  # Read a 2 byte entity from a file. 
    uint32 swap32(uint32 x)
    ushort swap16(ushort x)
    void swap_value(void* dst, void* src, int size)  # Swap endianness of a given value in memory. 
    void reloc_value(void* value, int size, adiff_t delta, bint mf)
    uval_t rotate_left(uval_t x, int count, asize_t bits, int offset)  # Rotate left - can be used to rotate a value to the right...
    void* qalloc_or_throw(int size)  # qalloc() 'size' bytes, and throw a "not enough memory"...
    void* qrealloc_or_throw(void* ptr, int size)  # qrealloc() 'ptr' by 'size', and throw a "not enough...
    void* qvector_reserve(void* vec, void* old, int cnt, int elsize)  # Change capacity of given qvector. 
    int qstrlen(char* s)  # ---------------------------------------------------------...
    int qstrcmp(char* s1, char* s2)  #  Lexical comparison of strings. 
    int qstrncmp(char* s1, char* s2, int len)  #  Lexical comparison of string prefixes. 
    char* qstrstr(char* s1, char* s2)  #  Find a string within another string. 
    char* qstrchr(char* s1, char c)  #  Find a character within a string. 
    char* qstrrchr(char* s1, char c)  #  Find a last occurrence of a character within a string. 
    uint32 calc_crc32(uint32 crc, void* buf, int len)  # Calculate CRC32 (polynom 0xEDB88320, zlib compatible). 
    bint base64_encode(qstring* output, void* input, int size)  # Encode base64
    bint base64_decode(bytevec_t* output, char* input, int size)  # Decode base64
    bint replace_tabs(qstring* out, char* str, int tabsize)  # Convert tabulations to spaces 
    char* str2user(char* dst, char* src, int dstsize)  #  String C-style conversions (convert \ n to a newline...
    char* user2str(char* dst, char* src, int dstsize)
    char back_char(char** p)
    void qstr2user(qstring* dst, char* src, int nsyms)
    void user2qstr(qstring* dst, qstring& src)
    bint is_utf8_head(char in_)  # Does this byte correspond to the head of a UTF-8 byte...
    bint is_utf8_tail(char in_)  # Does this byte correspond to the tail of a UTF-8 byte sequence? 
    bint is_valid_utf8(char* in_)  # Does byte sequence consist of valid UTF-8-encoded codepoints? 
    bint utf8_utf16(qwstring* out, char* in_, int nsyms)  # UTF-8 -> UTF-16 
    bint utf16_utf8(qstring* out, wchar16_t* in_, int nsyms)  # UTF-16 -> UTF-8 
    bint is_lead_surrogate(wchar32_t wch)
    bint is_tail_surrogate(wchar32_t wch)
    wchar32_t utf16_surrogates_to_cp(wchar16_t lead_surrogate, wchar16_t tail_surrogate)
    bint idb_utf8(qstring* out, char* in_, int nsyms, int flags)  # IDB default C string encoding -> UTF-8 
    bint change_codepage(qstring*, char*, int, int)
    wchar16_t utf8_wchar16(uchar b0, uchar b1)  # ---------------------------------------------------------...
    wchar32_t utf8_wchar32(uchar b0, uchar b1, uchar b2, uchar b3)  # ---------------------------------------------------------...
    wchar32_t get_utf8_char(char** pptr)  # Read one UTF-8 character from string. if error, return BADCP
    bint prev_utf8_char(wchar32_t* out_cp, char** p, char* begin)  # Get the UTF-8 character from string, before 'p'. 
    int skip_utf8(char** putf8, int n)  # Advance by n codepoints into the UTF-8 buffer. Each bad...
    int put_utf8_char(char* out, wchar32_t cp)  # Encode the codepoint into a UTF-8 byte sequence, and add...
    bint is_cp_graphical(wchar32_t cp)  # Is the provided codepoint graphical?
    int qustrlen(char* utf8)  # Get number of codepoints in UTF-8 string. Any 'bad' byte...
    bint qustrncpy(char* dst, char* utf8, int dstsize)  # A safer strncpy - makes sure that there is a terminating...
    bint is_cvt64()  # ---------------------------------------------------------...
    int convert_encoding(bytevec_t* out, char* fromcode, char* tocode, uchar* indata, int insize, int flags)  # Convert data from encoding fromcode into tocode. 
    int parse_command_line(qstrvec_t* args, channel_redirs_t* redirs, char* cmdline, int flags)  # Parse a space separated string (escaping with backslash...
    char** expand_argv(int* p_argc, int argc, char** argv)  # Copy and expand command line arguments. For ' '...
    void free_argv(int argc, char** argv)  # Free 'argc' elements of 'argv'
    bint quote_cmdline_arg(qstring* arg)  # Quote a command line argument if it contains escape...
    bint parse_plugin_options(plugin_options_t* opts, char* optstring)  # Parse plugin options from IDA command line specified by...
    void build_plugin_options(qstring* out, plugin_options_t& opts, char* optname)  # Build the plugin options, suitable for IDA command line...
    bint parse_dbgopts(instant_dbgopts_t* ido, char* r_switch)  # Parse the -r command line switch (for instant...
    void* launch_process(launch_process_params_t& lpp, qstring* errbuf)
    int term_process(void* handle)  # Forcibly terminate a running process. 
    int qwait_timed(int* status, int child, int flags, int timeout_ms)  # Wait for state changes in a child process (UNIX only)....
    int qwait(int* status, int child, int flags)
    int check_process_exit(void* handle, int* exit_code, int msecs)  # Check whether process has terminated or not. 
    tty_control_t is_control_tty(int fd)  # Check if the current process is the owner of the TTY...
    void qdetach_tty()  # If the current terminal is the controlling terminal of...
    void qcontrol_tty()  # Make the current terminal the controlling terminal of...
    bint is_main_thread()  # Are we running in the main thread?
    bint qsetenv(char* varname, char* value)  # Thread safe function to work with the environment
    bint qgetenv(char* varname, qstring* buf)
    int qpipe_create(qhandle_t* handles)  # Create a pipe. 
    int qpipe_read(qhandle_t handle, void* buf, int size)  # Read from a pipe.
    bint qpipe_read_n(qhandle_t handle, bytevec_t* out_bytes, int n)  # Read a specific amount of bytes from a pipe. 
    int qpipe_write(qhandle_t handle, void* buf, int size)  # Write to a pipe.
    int qpipe_close(qhandle_t handle)  # Close a pipe.
    void* pipe_process(qhandle_t* read_handle, qhandle_t* write_handle, launch_process_params_t* lpp, qstring* errbuf)  # Launch a process and establish 2-way comminucation with...
    int qwait_for_handles(int* idx, qhandle_t* handles, int n, uint32 write_bitmask, int timeout_ms)  # Wait for file/socket/pipe handles. 
    bint get_login_name(qstring* out)  # Get the user name for the current desktop session 
    int get_physical_core_count()  # Get the total CPU physical core count 
    int get_logical_core_count()  # Get the total CPU logical core count 
    int get_available_core_count()  # Get the number of logical CPU cores available to the...
    int __sputc(int _c, FILE* _p)
    FILE* qfopen(char* file, char* mode)  #  The following functions work just like their...
    ssize_t qfread(FILE* fp, void* buf, size_t n)
    ssize_t qfwrite(FILE* fp, void* buf, size_t n)
    int qftell(FILE* fp)
    int qfseek(FILE* fp, int offset, int whence)
    int qfclose(FILE* fp)
    int qflush(FILE* fp)
    int qfputc(int chr, FILE* fp)
    int qfgetc(FILE* fp)
    char* qfgets(char* s, size_t len, FILE* fp)
    int qfputs(char* s, FILE* fp)
    FILE* qtmpfile()
    int qunlink(char* fname)
    int qaccess(char* fname, int mode)
    char* qgets(char* line, size_t linesize)
    uint64 qfsize(FILE* fp)
    int qfprintf(FILE* fp, char* format)
    int qprintf(char* format)
    int qeprintf(char* format)
    int qfscanf(FILE* fp, char* format)
    ssize_t qgetline(qstring* buf, FILE* fp)  # Read line from file (the newline is removed from the...
    int qrename(char* oldfname, char* newfname)  # Rename a file: 'newname' may exist, and will be deleted
    int qmove(char* oldfname, char* newfname, uint32 flags)  # Move a file - more powerful version of qrename 
    char* qtmpdir(char* buf, size_t bufsize)  # Get temporary directory name Returns absolute path
    char* qtmpnam(char* buf, size_t bufsize)  # Get temporary file name. Returns absolute path (includes...
    int freadbytes(FILE* fp, void* res, int size, int mostfirst)  #  Add-ins for 2..32 byte read/writes. 
    int fwritebytes(FILE* fp, void* l, int size, int mostfirst)
    bint is_filetype_like_binary(filetype_t ft)  # Is unstructured input file?
    size_t getinf(inftag_t tag)  # Get program specific information (a scalar value) 
    ssize_t getinf_buf(inftag_t tag, void* buf, size_t bufsize)  # Get program specific information (a non-scalar value) 
    ssize_t getinf_str(qstring* buf, inftag_t tag)  # Get program specific information (a non-scalar value) 
    bint getinf_flag(inftag_t tag, uint32 flag)  # Get a flag value 
    bint setinf(inftag_t tag, ssize_t value)  # Set program specific information 
    bint setinf_buf(inftag_t tag, void* buf, size_t bufsize)  # Set program specific information 
    bint setinf_flag(inftag_t tag, uint32 flag, bint value)  # Set a flag value 
    bint delinf(inftag_t tag)  # Undefine a program specific information 
    ushort inf_get_version()  #  <INF _ACCESSORS>
    bint inf_set_version(ushort _v)
    ushort inf_get_genflags()
    bint inf_set_genflags(ushort _v)
    bint inf_is_auto_enabled()
    bint inf_set_auto_enabled(bint _v)
    bint inf_use_allasm()
    bint inf_set_use_allasm(bint _v)
    bint inf_loading_idc()
    bint inf_set_loading_idc(bint _v)
    bint inf_no_store_user_info()
    bint inf_set_no_store_user_info(bint _v)
    bint inf_readonly_idb()
    bint inf_set_readonly_idb(bint _v)
    bint inf_check_manual_ops()
    bint inf_set_check_manual_ops(bint _v)
    bint inf_allow_non_matched_ops()
    bint inf_set_allow_non_matched_ops(bint _v)
    bint inf_is_graph_view()
    bint inf_set_graph_view(bint _v)
    uint32 inf_get_lflags()
    bint inf_set_lflags(uint32 _v)
    bint inf_decode_fpp()
    bint inf_set_decode_fpp(bint _v)
    bint inf_is_32bit_or_higher()  # unfortunately the name inf_is_32bit was used in the past...
    bint inf_is_32bit_exactly()
    bint inf_set_32bit(bint _v)
    bint inf_is_16bit()
    bint inf_is_64bit()
    bint inf_set_64bit(bint _v)
    bint inf_is_ilp32()
    bint inf_set_ilp32(bint _v)
    bint inf_is_dll()
    bint inf_set_dll(bint _v)
    bint inf_is_flat_off32()
    bint inf_set_flat_off32(bint _v)
    bint inf_is_be()
    bint inf_set_be(bint _v)
    bint inf_is_wide_high_byte_first()
    bint inf_set_wide_high_byte_first(bint _v)
    bint inf_dbg_no_store_path()
    bint inf_set_dbg_no_store_path(bint _v)
    bint inf_is_snapshot()
    bint inf_set_snapshot(bint _v)
    bint inf_pack_idb()
    bint inf_set_pack_idb(bint _v)
    bint inf_compress_idb()
    bint inf_set_compress_idb(bint _v)
    bint inf_is_kernel_mode()
    bint inf_set_kernel_mode(bint _v)
    uint inf_get_app_bitness()
    void inf_set_app_bitness(uint bitness)
    uint32 inf_get_database_change_count()
    bint inf_set_database_change_count(uint32 _v)
    filetype_t inf_get_filetype()
    bint inf_set_filetype(filetype_t _v)
    ushort inf_get_ostype()
    bint inf_set_ostype(ushort _v)
    ushort inf_get_apptype()
    bint inf_set_apptype(ushort _v)
    uchar inf_get_asmtype()
    bint inf_set_asmtype(uchar _v)
    uchar inf_get_specsegs()
    bint inf_set_specsegs(uchar _v)
    uint32 inf_get_af()
    bint inf_set_af(uint32 _v)
    bint inf_trace_flow()
    bint inf_set_trace_flow(bint _v)
    bint inf_mark_code()
    bint inf_set_mark_code(bint _v)
    bint inf_create_jump_tables()
    bint inf_set_create_jump_tables(bint _v)
    bint inf_noflow_to_data()
    bint inf_set_noflow_to_data(bint _v)
    bint inf_create_all_xrefs()
    bint inf_set_create_all_xrefs(bint _v)
    bint inf_del_no_xref_insns()
    bint inf_set_del_no_xref_insns(bint _v)
    bint inf_create_func_from_ptr()
    bint inf_set_create_func_from_ptr(bint _v)
    bint inf_create_func_from_call()
    bint inf_set_create_func_from_call(bint _v)
    bint inf_create_func_tails()
    bint inf_set_create_func_tails(bint _v)
    bint inf_should_create_stkvars()
    bint inf_set_should_create_stkvars(bint _v)
    bint inf_propagate_stkargs()
    bint inf_set_propagate_stkargs(bint _v)
    bint inf_propagate_regargs()
    bint inf_set_propagate_regargs(bint _v)
    bint inf_should_trace_sp()
    bint inf_set_should_trace_sp(bint _v)
    bint inf_full_sp_ana()
    bint inf_set_full_sp_ana(bint _v)
    bint inf_noret_ana()
    bint inf_set_noret_ana(bint _v)
    bint inf_guess_func_type()
    bint inf_set_guess_func_type(bint _v)
    bint inf_truncate_on_del()
    bint inf_set_truncate_on_del(bint _v)
    bint inf_create_strlit_on_xref()
    bint inf_set_create_strlit_on_xref(bint _v)
    bint inf_check_unicode_strlits()
    bint inf_set_check_unicode_strlits(bint _v)
    bint inf_create_off_using_fixup()
    bint inf_set_create_off_using_fixup(bint _v)
    bint inf_create_off_on_dref()
    bint inf_set_create_off_on_dref(bint _v)
    bint inf_op_offset()
    bint inf_set_op_offset(bint _v)
    bint inf_data_offset()
    bint inf_set_data_offset(bint _v)
    bint inf_use_flirt()
    bint inf_set_use_flirt(bint _v)
    bint inf_append_sigcmt()
    bint inf_set_append_sigcmt(bint _v)
    bint inf_allow_sigmulti()
    bint inf_set_allow_sigmulti(bint _v)
    bint inf_hide_libfuncs()
    bint inf_set_hide_libfuncs(bint _v)
    bint inf_rename_jumpfunc()
    bint inf_set_rename_jumpfunc(bint _v)
    bint inf_rename_nullsub()
    bint inf_set_rename_nullsub(bint _v)
    bint inf_coagulate_data()
    bint inf_set_coagulate_data(bint _v)
    bint inf_coagulate_code()
    bint inf_set_coagulate_code(bint _v)
    bint inf_final_pass()
    bint inf_set_final_pass(bint _v)
    uint32 inf_get_af2()
    bint inf_set_af2(uint32 _v)
    bint inf_handle_eh()
    bint inf_set_handle_eh(bint _v)
    bint inf_handle_rtti()
    bint inf_set_handle_rtti(bint _v)
    bint inf_macros_enabled()
    bint inf_set_macros_enabled(bint _v)
    bint inf_merge_strlits()
    bint inf_set_merge_strlits(bint _v)
    uval_t inf_get_baseaddr()
    bint inf_set_baseaddr(uval_t _v)
    sel_t inf_get_start_ss()
    bint inf_set_start_ss(sel_t _v)
    sel_t inf_get_start_cs()
    bint inf_set_start_cs(sel_t _v)
    ea_t inf_get_start_ip()
    bint inf_set_start_ip(ea_t _v)
    ea_t inf_get_start_ea()
    bint inf_set_start_ea(ea_t _v)
    ea_t inf_get_start_sp()
    bint inf_set_start_sp(ea_t _v)
    ea_t inf_get_main()
    bint inf_set_main(ea_t _v)
    ea_t inf_get_min_ea()
    bint inf_set_min_ea(ea_t _v)
    ea_t inf_get_max_ea()
    bint inf_set_max_ea(ea_t _v)
    ea_t inf_get_omin_ea()
    bint inf_set_omin_ea(ea_t _v)
    ea_t inf_get_omax_ea()
    bint inf_set_omax_ea(ea_t _v)
    ea_t inf_get_lowoff()
    bint inf_set_lowoff(ea_t _v)
    ea_t inf_get_highoff()
    bint inf_set_highoff(ea_t _v)
    uval_t inf_get_maxref()
    bint inf_set_maxref(uval_t _v)
    sval_t inf_get_netdelta()
    bint inf_set_netdelta(sval_t _v)
    uchar inf_get_xrefnum()
    bint inf_set_xrefnum(uchar _v)
    uchar inf_get_type_xrefnum()
    bint inf_set_type_xrefnum(uchar _v)
    uchar inf_get_refcmtnum()
    bint inf_set_refcmtnum(uchar _v)
    uchar inf_get_xrefflag()
    bint inf_set_xrefflag(uchar _v)
    bint inf_show_xref_seg()
    bint inf_set_show_xref_seg(bint _v)
    bint inf_show_xref_tmarks()
    bint inf_set_show_xref_tmarks(bint _v)
    bint inf_show_xref_fncoff()
    bint inf_set_show_xref_fncoff(bint _v)
    bint inf_show_xref_val()
    bint inf_set_show_xref_val(bint _v)
    ushort inf_get_max_autoname_len()
    bint inf_set_max_autoname_len(ushort _v)
    char inf_get_nametype()
    bint inf_set_nametype(char _v)
    uint32 inf_get_short_demnames()
    bint inf_set_short_demnames(uint32 _v)
    uint32 inf_get_long_demnames()
    bint inf_set_long_demnames(uint32 _v)
    uchar inf_get_demnames()
    bint inf_set_demnames(uchar _v)
    uchar inf_get_listnames()
    bint inf_set_listnames(uchar _v)
    uchar inf_get_indent()
    bint inf_set_indent(uchar _v)
    uchar inf_get_cmt_indent()
    bint inf_set_cmt_indent(uchar _v)
    ushort inf_get_margin()
    bint inf_set_margin(ushort _v)
    ushort inf_get_lenxref()
    bint inf_set_lenxref(ushort _v)
    uint32 inf_get_outflags()
    bint inf_set_outflags(uint32 _v)
    bint inf_show_void()
    bint inf_set_show_void(bint _v)
    bint inf_show_auto()
    bint inf_set_show_auto(bint _v)
    bint inf_gen_null()
    bint inf_set_gen_null(bint _v)
    bint inf_show_line_pref()
    bint inf_set_show_line_pref(bint _v)
    bint inf_line_pref_with_seg()
    bint inf_set_line_pref_with_seg(bint _v)
    bint inf_gen_lzero()
    bint inf_set_gen_lzero(bint _v)
    bint inf_gen_org()
    bint inf_set_gen_org(bint _v)
    bint inf_gen_assume()
    bint inf_set_gen_assume(bint _v)
    bint inf_gen_tryblks()
    bint inf_set_gen_tryblks(bint _v)
    uchar inf_get_cmtflg()
    bint inf_set_cmtflg(uchar _v)
    bint inf_show_repeatables()
    bint inf_set_show_repeatables(bint _v)
    bint inf_show_all_comments()
    bint inf_set_show_all_comments(bint _v)
    bint inf_hide_comments()
    bint inf_set_hide_comments(bint _v)
    bint inf_show_src_linnum()
    bint inf_set_show_src_linnum(bint _v)
    bint inf_test_mode()
    bint inf_show_hidden_insns()
    bint inf_set_show_hidden_insns(bint _v)
    bint inf_show_hidden_funcs()
    bint inf_set_show_hidden_funcs(bint _v)
    bint inf_show_hidden_segms()
    bint inf_set_show_hidden_segms(bint _v)
    uchar inf_get_limiter()
    bint inf_set_limiter(uchar _v)
    bint inf_is_limiter_thin()
    bint inf_set_limiter_thin(bint _v)
    bint inf_is_limiter_thick()
    bint inf_set_limiter_thick(bint _v)
    bint inf_is_limiter_empty()
    bint inf_set_limiter_empty(bint _v)
    short inf_get_bin_prefix_size()
    bint inf_set_bin_prefix_size(short _v)
    uchar inf_get_prefflag()
    bint inf_set_prefflag(uchar _v)
    bint inf_prefix_show_segaddr()
    bint inf_set_prefix_show_segaddr(bint _v)
    bint inf_prefix_show_funcoff()
    bint inf_set_prefix_show_funcoff(bint _v)
    bint inf_prefix_show_stack()
    bint inf_set_prefix_show_stack(bint _v)
    bint inf_prefix_truncate_opcode_bytes()
    bint inf_set_prefix_truncate_opcode_bytes(bint _v)
    uchar inf_get_strlit_flags()
    bint inf_set_strlit_flags(uchar _v)
    bint inf_strlit_names()
    bint inf_set_strlit_names(bint _v)
    bint inf_strlit_name_bit()
    bint inf_set_strlit_name_bit(bint _v)
    bint inf_strlit_serial_names()
    bint inf_set_strlit_serial_names(bint _v)
    bint inf_unicode_strlits()
    bint inf_set_unicode_strlits(bint _v)
    bint inf_strlit_autocmt()
    bint inf_set_strlit_autocmt(bint _v)
    bint inf_strlit_savecase()
    bint inf_set_strlit_savecase(bint _v)
    uchar inf_get_strlit_break()
    bint inf_set_strlit_break(uchar _v)
    char inf_get_strlit_zeroes()
    bint inf_set_strlit_zeroes(char _v)
    int32 inf_get_strtype()
    bint inf_set_strtype(int32 _v)
    uval_t inf_get_strlit_sernum()
    bint inf_set_strlit_sernum(uval_t _v)
    uval_t inf_get_datatypes()
    bint inf_set_datatypes(uval_t _v)
    uint32 inf_get_abibits()
    bint inf_set_abibits(uint32 _v)
    bint inf_is_mem_aligned4()
    bint inf_set_mem_aligned4(bint _v)
    bint inf_pack_stkargs()
    bint inf_set_pack_stkargs(bint _v)
    bint inf_big_arg_align()
    bint inf_set_big_arg_align(bint _v)
    bint inf_stack_ldbl()
    bint inf_set_stack_ldbl(bint _v)
    bint inf_stack_varargs()
    bint inf_set_stack_varargs(bint _v)
    bint inf_is_hard_float()
    bint inf_set_hard_float(bint _v)
    bint inf_abi_set_by_user()
    bint inf_set_abi_set_by_user(bint _v)
    bint inf_use_gcc_layout()
    bint inf_set_use_gcc_layout(bint _v)
    bint inf_map_stkargs()
    bint inf_set_map_stkargs(bint _v)
    bint inf_huge_arg_align()
    bint inf_set_huge_arg_align(bint _v)
    uint32 inf_get_appcall_options()
    bint inf_set_appcall_options(uint32 _v)
    ea_t inf_get_privrange_start_ea()
    bint inf_set_privrange_start_ea(ea_t _v)
    ea_t inf_get_privrange_end_ea()
    bint inf_set_privrange_end_ea(ea_t _v)
    comp_t inf_get_cc_id()
    bint inf_set_cc_id(comp_t _v)
    cm_t inf_get_cc_cm()
    bint inf_set_cc_cm(cm_t _v)
    callcnv_t inf_get_callcnv()
    bint inf_set_callcnv(callcnv_t _v)
    uchar inf_get_cc_size_i()
    bint inf_set_cc_size_i(uchar _v)
    uchar inf_get_cc_size_b()
    bint inf_set_cc_size_b(uchar _v)
    uchar inf_get_cc_size_e()
    bint inf_set_cc_size_e(uchar _v)
    uchar inf_get_cc_defalign()
    bint inf_set_cc_defalign(uchar _v)
    uchar inf_get_cc_size_s()
    bint inf_set_cc_size_s(uchar _v)
    uchar inf_get_cc_size_l()
    bint inf_set_cc_size_l(uchar _v)
    uchar inf_get_cc_size_ll()
    bint inf_set_cc_size_ll(uchar _v)
    uchar inf_get_cc_size_ldbl()
    bint inf_set_cc_size_ldbl(uchar _v)
    bint inf_get_procname(char* buf, size_t bufsize)
    bint inf_set_procname(char* _v, size_t len)
    bint inf_get_strlit_pref(char* buf, size_t bufsize)
    bint inf_set_strlit_pref(char* _v, size_t len)
    bint inf_get_cc(compiler_info_t* out)
    bint inf_set_cc(compiler_info_t& _v)
    bint inf_get_privrange(range_t* out)
    bint inf_set_privrange(range_t& _v)
    ushort inf_get_af_low()  # Get/set low/high 16bit halves of inf.af
    void inf_set_af_low(ushort saf)
    ushort inf_get_af_high()
    void inf_set_af_high(ushort saf2)
    ushort inf_get_af2_low()  # Get/set low 16bit half of inf.af2
    void inf_set_af2_low(ushort saf)
    int inf_get_pack_mode()
    int inf_set_pack_mode(int pack_mode)
    void inf_inc_database_change_count(int cnt)
    uchar inf_get_demname_form()  # Get #DEMNAM_MASK bits of #demnames
    uval_t inf_postinc_strlit_sernum(uval_t cnt)
    bint inf_like_binary()
    int calc_default_idaplace_flags()  # Get default disassembly line options
    ea_t to_ea(sel_t reg_cs, uval_t reg_ip)  # ---------------------------------------------------------...
    bint register_post_event_visitor(hook_type_t hook_type, post_event_visitor_t* visitor, plugmod_t* owner)  # Register the post-event visitor. The kernel will not...
    bint unregister_post_event_visitor(hook_type_t hook_type, post_event_visitor_t* visitor)  # Unregister the post-event visitor. 
    ssize_t get_dbctx_id()  # Get the current database context ID 
    size_t get_dbctx_qty()  # Get number of database contexts 
    bint is_database_busy()  # Check if the database is busy (e.g. performing some...
    size_t validate_idb(uint32 vld_flags)  # Validate the database 
    bint move_privrange(ea_t new_privrange_start)  # Move privrange to the specified address 
    fpvalue_error_t ieee_realcvt(void* m, fpvalue_t* out, uint16 swt)  # Standard IEEE 754 floating point conversion function 
    void realtoasc(char* buf, size_t bufsize, fpvalue_t& x, uint mode)  # Helper functions. Better use members of fpvalue_t, they...
    fpvalue_error_t asctoreal(char** sss, fpvalue_t* out)
    void eltoe(sval_t l, fpvalue_t* vout)
    void eltoe64(int64 l, fpvalue_t* vout)
    void eltoe64u(uint64 l, fpvalue_t* vout)
    fpvalue_error_t eetol(sval_t* out, fpvalue_t& a, bint roundflg)
    fpvalue_error_t eetol64(int64* out, fpvalue_t& a, bint roundflg)
    fpvalue_error_t eetol64u(uint64* out, fpvalue_t& a, bint roundflg)
    fpvalue_error_t eldexp(fpvalue_t& a, int32 pwr2, fpvalue_t* zout)
    fpvalue_error_t eadd(fpvalue_t& a, fpvalue_t& b, fpvalue_t* zout, bint subflg)
    fpvalue_error_t emul(fpvalue_t& a, fpvalue_t& b, fpvalue_t* zout)
    fpvalue_error_t ediv(fpvalue_t& a, fpvalue_t& b, fpvalue_t* zout)
    int ecmp(fpvalue_t& a, fpvalue_t& b)
    fpvalue_kind_t get_fpvalue_kind(fpvalue_t& a, uint16 reserved)
    void ecleaz(uint16* x)
    void emovo(uint16* a, fpvalue_t* vout)
    void emovi(fpvalue_t& a, uint16* vout)  # Move eNI => eNE
    int eshift(uint16* x, int sc)  # Move eNE => eNI
    bint emdnorm(uint16* s, bint lost, bint subflg, int32 exp, int rndbase)  # Shift NI format up (+) or down Normalize and round off. 
    int isascii(int _c)
    int isalnum(int _c)
    int isalpha(int _c)
    int isblank(int _c)
    int iscntrl(int _c)
    int isdigit(int _c)
    int isgraph(int _c)
    int islower(int _c)
    int isprint(int _c)
    int ispunct(int _c)
    int isspace(int _c)
    int isupper(int _c)
    int isxdigit(int _c)
    int toascii(int _c)
    int tolower(int _c)
    int toupper(int _c)
    int digittoint(int _c)
    int ishexnumber(int _c)
    int isideogram(int _c)
    int isnumber(int _c)
    int isphonogram(int _c)
    int isrune(int _c)
    int isspecial(int _c)
    int __darwin_check_fd_set(int _a, void* _b)
    void __darwin_fd_set(int _fd, fd_set*const _p)
    void __darwin_fd_clr(int _fd, fd_set*const _p)
    bint netnode_check(netnode*, char* name, size_t namlen, bint create)
    void netnode_kill(netnode*)
    bint netnode_start(netnode*)
    bint netnode_end(netnode*)
    bint netnode_next(netnode*)
    bint netnode_prev(netnode*)
    ssize_t netnode_get_name(nodeidx_t num, qstring* out)
    bint netnode_rename(nodeidx_t num, char* newname, size_t namlen)
    ssize_t netnode_valobj(nodeidx_t num, void* buf, size_t bufsize)
    ssize_t netnode_valstr(nodeidx_t num, char* buf, size_t bufsize)
    ssize_t netnode_qvalstr(nodeidx_t num, qstring* buf)
    bint netnode_set(nodeidx_t num, void* value, size_t length)
    bint netnode_delvalue(nodeidx_t num)
    nodeidx_t netnode_altval(nodeidx_t num, nodeidx_t alt, int tag)
    uchar netnode_charval(nodeidx_t num, nodeidx_t alt, int tag)
    nodeidx_t netnode_altval_idx8(nodeidx_t num, uchar alt, int tag)
    uchar netnode_charval_idx8(nodeidx_t num, uchar alt, int tag)
    ssize_t netnode_supval(nodeidx_t num, nodeidx_t alt, void* buf, size_t bufsize, int tag)
    ssize_t netnode_supstr(nodeidx_t num, nodeidx_t alt, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qsupstr(nodeidx_t num, qstring* buf, nodeidx_t alt, int tag)
    bint netnode_supset(nodeidx_t num, nodeidx_t alt, void* value, size_t length, int tag)
    bint netnode_supdel(nodeidx_t num, nodeidx_t alt, int tag)
    nodeidx_t netnode_lower_bound(nodeidx_t num, nodeidx_t cur, int tag)
    nodeidx_t netnode_supfirst(nodeidx_t num, int tag)
    nodeidx_t netnode_supnext(nodeidx_t num, nodeidx_t cur, int tag)
    nodeidx_t netnode_suplast(nodeidx_t num, int tag)
    nodeidx_t netnode_supprev(nodeidx_t num, nodeidx_t cur, int tag)
    ssize_t netnode_supval_idx8(nodeidx_t num, uchar alt, void* buf, size_t bufsize, int tag)
    ssize_t netnode_supstr_idx8(nodeidx_t num, uchar alt, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qsupstr_idx8(nodeidx_t num, qstring* buf, uchar alt, int tag)
    bint netnode_supset_idx8(nodeidx_t num, uchar alt, void* value, size_t length, int tag)
    bint netnode_supdel_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_lower_bound_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_supfirst_idx8(nodeidx_t num, int tag)
    nodeidx_t netnode_supnext_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_suplast_idx8(nodeidx_t num, int tag)
    nodeidx_t netnode_supprev_idx8(nodeidx_t num, uchar alt, int tag)
    bint netnode_supdel_all(nodeidx_t num, int tag)
    int netnode_supdel_range(nodeidx_t num, nodeidx_t idx1, nodeidx_t idx2, int tag)
    int netnode_supdel_range_idx8(nodeidx_t num, nodeidx_t idx1, nodeidx_t idx2, int tag)
    ssize_t netnode_hashval(nodeidx_t num, char* idx, void* buf, size_t bufsize, int tag)
    ssize_t netnode_hashstr(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashstr(nodeidx_t num, qstring* buf, char* idx, int tag)
    nodeidx_t netnode_hashval_long(nodeidx_t num, char* idx, int tag)
    bint netnode_hashset(nodeidx_t num, char* idx, void* value, size_t length, int tag)
    bint netnode_hashdel(nodeidx_t num, char* idx, int tag)
    ssize_t netnode_hashfirst(nodeidx_t num, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashfirst(nodeidx_t num, qstring* buf, int tag)
    ssize_t netnode_hashnext(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashnext(nodeidx_t num, qstring* buf, char* idx, int tag)
    ssize_t netnode_hashlast(nodeidx_t num, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashlast(nodeidx_t num, qstring* buf, int tag)
    ssize_t netnode_hashprev(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashprev(nodeidx_t num, qstring* buf, char* idx, int tag)
    size_t netnode_blobsize(nodeidx_t num, nodeidx_t start, int tag)
    void* netnode_getblob(nodeidx_t num, void* buf, size_t* bufsize, nodeidx_t start, int tag)
    ssize_t netnode_qgetblob(nodeidx_t num, bytevec_t* buf, size_t elsize, nodeidx_t start, int tag)
    bint netnode_setblob(nodeidx_t num, void* buf, size_t size, nodeidx_t start, int tag)
    int netnode_delblob(nodeidx_t num, nodeidx_t start, int tag)
    bint netnode_inited()
    bint netnode_is_available()
    size_t netnode_copy(nodeidx_t num, nodeidx_t count, nodeidx_t target, bint move)
    size_t netnode_altshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_charshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_supshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_blobshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    void netnode_altadjust2(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, altadjust_visitor_t& av)
    bint netnode_exist(netnode& n)
    nodeidx_t ea2node(ea_t ea)  # Get netnode for the specified address.
    ea_t node2ea(nodeidx_t ndx)
    nodeidx_t end_ea2node(ea_t ea)
    netnode getnode(ea_t ea)
    tid_t get_strid(ea_t ea)  #  Returns the struct id of the struct type at the...
    ssize_t get_xrefpos(xrefpos_t* out, ea_t ea)
    void set_xrefpos(ea_t ea, xrefpos_t* in_)
    void del_xrefpos(ea_t ea)
    void set_aflags(ea_t ea, aflags_t flags)
    void upd_abits(ea_t ea, aflags_t clr_bits, aflags_t set_bits)
    void set_abits(ea_t ea, aflags_t bits)
    void clr_abits(ea_t ea, aflags_t bits)
    aflags_t get_aflags(ea_t ea)
    void del_aflags(ea_t ea)
    bint has_aflag_linnum(aflags_t flags)
    bint is_aflag_usersp(aflags_t flags)
    bint is_aflag_public_name(aflags_t flags)
    bint is_aflag_weak_name(aflags_t flags)
    bint is_aflag_hidden_item(aflags_t flags)
    bint is_aflag_manual_insn(aflags_t flags)
    bint is_aflag_hidden_border(aflags_t flags)
    bint is_aflag_zstroff(aflags_t flags)
    bint is_aflag__bnot0(aflags_t flags)
    bint is_aflag__bnot1(aflags_t flags)
    bint is_aflag_libitem(aflags_t flags)
    bint has_aflag_ti(aflags_t flags)
    bint has_aflag_ti0(aflags_t flags)
    bint has_aflag_ti1(aflags_t flags)
    bint has_aflag_lname(aflags_t flags)
    bint is_aflag_tilcmt(aflags_t flags)
    bint is_aflag_lzero0(aflags_t flags)
    bint is_aflag_lzero1(aflags_t flags)
    bint is_aflag_colored_item(aflags_t flags)
    bint is_aflag_terse_struc(aflags_t flags)
    bint is_aflag__invsign0(aflags_t flags)
    bint is_aflag__invsign1(aflags_t flags)
    bint is_aflag_noret(aflags_t flags)
    bint is_aflag_fixed_spd(aflags_t flags)
    bint is_aflag_align_flow(aflags_t flags)
    bint is_aflag_userti(aflags_t flags)
    bint is_aflag_retfp(aflags_t flags)
    bint uses_aflag_modsp(aflags_t flags)
    bint is_aflag_notcode(aflags_t flags)
    bint is_aflag_notproc(aflags_t flags)
    bint is_aflag_type_guessed_by_ida(aflags_t flags)
    bint is_aflag_func_guessed_by_hexrays(aflags_t flags)
    bint is_aflag_data_guessed_by_hexrays(aflags_t flags)
    bint is_aflag_type_determined_by_hexrays(aflags_t flags)
    bint is_aflag_type_guessed_by_hexrays(aflags_t flags)
    bint is_hidden_item(ea_t ea)
    void hide_item(ea_t ea)
    void unhide_item(ea_t ea)
    bint is_hidden_border(ea_t ea)
    void hide_border(ea_t ea)
    void unhide_border(ea_t ea)
    bint uses_modsp(ea_t ea)
    void set_usemodsp(ea_t ea)
    void clr_usemodsp(ea_t ea)
    bint is_zstroff(ea_t ea)
    void set_zstroff(ea_t ea)
    void clr_zstroff(ea_t ea)
    bint is__bnot0(ea_t ea)
    void set__bnot0(ea_t ea)
    void clr__bnot0(ea_t ea)
    bint is__bnot1(ea_t ea)
    void set__bnot1(ea_t ea)
    void clr__bnot1(ea_t ea)
    bint is_libitem(ea_t ea)
    void set_libitem(ea_t ea)
    void clr_libitem(ea_t ea)
    bint has_ti(ea_t ea)
    void set_has_ti(ea_t ea)
    void clr_has_ti(ea_t ea)
    bint has_ti0(ea_t ea)
    void set_has_ti0(ea_t ea)
    void clr_has_ti0(ea_t ea)
    bint has_ti1(ea_t ea)
    void set_has_ti1(ea_t ea)
    void clr_has_ti1(ea_t ea)
    bint has_lname(ea_t ea)
    void set_has_lname(ea_t ea)
    void clr_has_lname(ea_t ea)
    bint is_tilcmt(ea_t ea)
    void set_tilcmt(ea_t ea)
    void clr_tilcmt(ea_t ea)
    bint is_usersp(ea_t ea)
    void set_usersp(ea_t ea)
    void clr_usersp(ea_t ea)
    bint is_lzero0(ea_t ea)
    void set_lzero0(ea_t ea)
    void clr_lzero0(ea_t ea)
    bint is_lzero1(ea_t ea)
    void set_lzero1(ea_t ea)
    void clr_lzero1(ea_t ea)
    bint is_colored_item(ea_t ea)
    void set_colored_item(ea_t ea)
    void clr_colored_item(ea_t ea)
    bint is_terse_struc(ea_t ea)
    void set_terse_struc(ea_t ea)
    void clr_terse_struc(ea_t ea)
    bint is__invsign0(ea_t ea)
    void set__invsign0(ea_t ea)
    void clr__invsign0(ea_t ea)
    bint is__invsign1(ea_t ea)
    void set__invsign1(ea_t ea)
    void clr__invsign1(ea_t ea)
    bint is_noret(ea_t ea)
    void set_noret(ea_t ea)
    void clr_noret(ea_t ea)
    bint is_fixed_spd(ea_t ea)
    void set_fixed_spd(ea_t ea)
    void clr_fixed_spd(ea_t ea)
    bint is_align_flow(ea_t ea)
    void set_align_flow(ea_t ea)
    void clr_align_flow(ea_t ea)
    bint is_userti(ea_t ea)
    void set_userti(ea_t ea)
    void clr_userti(ea_t ea)
    bint is_retfp(ea_t ea)
    void set_retfp(ea_t ea)
    void clr_retfp(ea_t ea)
    bint is_notproc(ea_t ea)
    void set_notproc(ea_t ea)
    void clr_notproc(ea_t ea)
    bint is_type_guessed_by_ida(ea_t ea)
    bint is_func_guessed_by_hexrays(ea_t ea)
    bint is_data_guessed_by_hexrays(ea_t ea)
    bint is_type_determined_by_hexrays(ea_t ea)
    bint is_type_guessed_by_hexrays(ea_t ea)
    void set_type_guessed_by_ida(ea_t ea)
    void set_func_guessed_by_hexrays(ea_t ea)
    void set_data_guessed_by_hexrays(ea_t ea)
    void set_type_determined_by_hexrays(ea_t ea)
    void set_notcode(ea_t ea)  # Mark address so that it cannot be converted to instruction
    void clr_notcode(ea_t ea)  # Clear not-code mark
    bint is_notcode(ea_t ea)  # Is the address marked as not-code?
    void set_visible_item(ea_t ea, bint visible)  # Change visibility of item at given ea
    bint is_visible_item(ea_t ea)  # Test visibility of item at given ea
    bint is_finally_visible_item(ea_t ea)  # Is instruction visible?
    void set_source_linnum(ea_t ea, uval_t lnnum)  #  They are sometimes present in object files. @ {
    uval_t get_source_linnum(ea_t ea)
    void del_source_linnum(ea_t ea)
    ea_t get_absbase(ea_t ea)  #  These functions may be used if necessary (despite of...
    void set_absbase(ea_t ea, ea_t x)
    void del_absbase(ea_t ea)
    ea_t get_ind_purged(ea_t ea)  #  Number of bytes purged from the stack when a function...
    void set_ind_purged(ea_t ea, ea_t x)
    void del_ind_purged(ea_t ea)
    uint32 get_str_type(ea_t ea)  #  Use higher level function get_opinfo(). @ {
    void set_str_type(ea_t ea, uint32 x)
    void del_str_type(ea_t ea)
    uchar get_str_type_code(int32 strtype)  #  See
    char get_str_term1(int32 strtype)
    char get_str_term2(int32 strtype)
    uchar get_str_encoding_idx(int32 strtype)  # if the second termination character is ' \ 0', then it...
    int32 set_str_encoding_idx(int32 strtype, int encoding_idx)  # Set index of the string encoding in the string type
    int32 make_str_type(uchar type_code, int encoding_idx, uchar term1, uchar term2)  # Get string type for a string in the given encoding
    bint is_pascal(int32 strtype)
    size_t get_str_type_prefix_length(int32 strtype)
    uint32 get_alignment(ea_t ea)  #  (should be power of 2) These functions may be used if...
    void set_alignment(ea_t ea, uint32 x)
    void del_alignment(ea_t ea)
    void set_item_color(ea_t ea, bgcolor_t color)  #  @ {
    bgcolor_t get_item_color(ea_t ea)
    bint del_item_color(ea_t ea)
    ssize_t get_array_parameters(array_parameters_t* out, ea_t ea)
    void set_array_parameters(ea_t ea, array_parameters_t* in_)
    void del_array_parameters(ea_t ea)
    ssize_t get_switch_info(switch_info_t* out, ea_t ea)  #  See ::switch_info_t, xref.hpp for related functions @ {
    void set_switch_info(ea_t ea, switch_info_t& in_)
    void del_switch_info(ea_t ea)
    ea_t get_switch_parent(ea_t ea)  #  Address which holds the switch info (::switch_info_t)....
    void set_switch_parent(ea_t ea, ea_t x)
    void del_switch_parent(ea_t ea)
    int get_custom_data_type_ids(custom_data_type_ids_t* cdis, ea_t ea)
    void set_custom_data_type_ids(ea_t ea, custom_data_type_ids_t* cdis)
    void del_custom_data_type_ids(ea_t ea)
    bint is_reftype_target_optional(reftype_t type)  # Can the target be calculated using operand value?
    reftype_t get_reftype_by_size(size_t size)  # Get REF_... constant from size Supported sizes:...
    int register_custom_refinfo(custom_refinfo_handler_t* crh)  # Register a new custom refinfo type.
    bint unregister_custom_refinfo(int crid)  # Unregister a new custom refinfo type.
    int find_custom_refinfo(char* name)  # Get id of a custom refinfo type.
    custom_refinfo_handler_t* get_custom_refinfo(int crid)  # Get definition of a registered custom refinfo type.
    custom_refinfo_handler_t* get_custom_refinfo_handler(refinfo_t& ri)  # Get refinfo handler
    void get_refinfo_descs(refinfo_desc_vec_t* descs)
    bint set_refinfo_ex(ea_t ea, int n, refinfo_t* ri)  #  n may be 0, 1, 2, #OPND_MASK. #OPND_OUTER may be used...
    bint set_refinfo(ea_t ea, int n, reftype_t type, ea_t target, ea_t base, adiff_t tdelta)
    bint get_refinfo(refinfo_t* ri, ea_t ea, int n)
    bint del_refinfo(ea_t ea, int n)
    void write_struc_path(ea_t ea, int idx, tid_t* path, int plen, adiff_t delta)  # ---------------------------------------------------------...
    int read_struc_path(tid_t* path, adiff_t* delta, ea_t ea, int idx)
    bint get_tinfo(tinfo_t* tif, ea_t ea)  #  Work with function/data types These functions may be...
    bint set_tinfo(ea_t ea, tinfo_t* tif)
    void del_tinfo(ea_t ea)
    bint get_op_tinfo(tinfo_t* tif, ea_t ea, int n)  #  These functions may be used if necessary (despite of...
    bint set_op_tinfo(ea_t ea, int n, tinfo_t* tif)
    void del_op_tinfo(ea_t ea, int n)
    ssize_t get_root_filename(char* buf, size_t bufsize)  # ---------------------------------------------------------...
    ssize_t dbg_get_input_path(char* buf, size_t bufsize)  # Get debugger input file name/path (see #LFLG_DBG_NOPATH)
    ssize_t get_input_file_path(char* buf, size_t bufsize)  # Get full path of the input file
    void set_root_filename(char* file)  # Set full path of the input file
    size_t retrieve_input_file_size()  # Get size of input file in bytes
    uint32 retrieve_input_file_crc32()  # Get input file crc32 stored in the database. it can be...
    bint retrieve_input_file_md5(uchar* hash)  # Get input file md5
    bint retrieve_input_file_sha256(uchar* hash)  # Get input file sha256
    ssize_t get_asm_inc_file(qstring* buf)  # Get name of the include file
    bint set_asm_inc_file(char* file)  # Set name of the include file
    ea_t get_imagebase()  # Get image base address
    void set_imagebase(ea_t base)  # Set image base address
    netnode get_ids_modnode()  # Get ids modnode
    void set_ids_modnode(netnode id)  # Set ids modnode
    ssize_t get_archive_path(qstring* out)  # Get archive file path from which input file was extracted
    bint set_archive_path(char* file)  # Set archive file path from which input file was extracted
    ssize_t get_loader_format_name(qstring* out)  # Get file format name for loader modules
    void set_loader_format_name(char* name)  # Set file format name for loader modules
    ssize_t get_initial_ida_version(qstring* out)  # Get version of ida which created the database (string...
    ssize_t get_ida_notepad_text(qstring* out)  # Get notepad text
    void set_ida_notepad_text(char* text, size_t size)  # Set notepad text
    ssize_t get_srcdbg_paths(qstring* out)  # Get source debug paths
    void set_srcdbg_paths(char* paths)  # Set source debug paths
    ssize_t get_srcdbg_undesired_paths(qstring* out)  # Get user-closed source files
    void set_srcdbg_undesired_paths(char* paths)  # Set user-closed source files
    ushort get_initial_idb_version()  # Get initial version of the database (numeric format like 700)
    size_t get_elapsed_secs()  # Get seconds database stayed open
    size_t get_idb_nopens()  # Get number of times the database is opened
    int get_encoding_qty()  # Get total number of encodings (counted from 0)
    char* get_encoding_name(int idx)  # Get encoding name for specific index (1-based). 
    int add_encoding(char* encname)  # Add a new encoding (e.g. "UTF-8"). If it's already in...
    bint del_encoding(int idx)  # Delete an encoding The encoding is not actually removed...
    bint rename_encoding(int idx, char* encname)  # Change name for an encoding The number of bytes per unit...
    int get_encoding_bpu(int idx)  # Get the amount of bytes per unit (e.g., 2 for UTF-16, 4...
    int get_encoding_bpu_by_name(char* encname)  # Get the amount of bytes per unit for the given encoding 
    int get_strtype_bpu(int32 strtype)  # ---------------------------------------------------------...
    int get_default_encoding_idx(int bpu)  # Get default encoding index for a specific string type. 
    bint set_default_encoding_idx(int bpu, int idx)  # Set default encoding for a string type 
    char* encoding_from_strtype(int32 strtype)  # Get encoding name for this strtype 
    int get_outfile_encoding_idx()  # Get the index of the encoding used when producing files 
    bint set_outfile_encoding_idx(int idx)  # set encoding to be used when producing files 
    uint get_import_module_qty()  # Get number of import modules
    bint get_import_module_name(qstring* buf, int mod_index)  # Get import module name. 
    void delete_imports()  # Delete all imported modules information
    int validate_idb_names(bint do_repair)  # Check consistency of name records, return number of bad ones
    void set_gotea(ea_t gotea)  # ---------------------------------------------------------...
    ea_t get_gotea()  # ---------------------------------------------------------...
    bint is_visible_segm(segment_t* s)  # See #SFL_HIDDEN
    bint is_finally_visible_segm(segment_t* s)  # See #SFL_HIDDEN, #SCF_SHHID_SEGM
    void set_visible_segm(segment_t* s, bint visible)  # See #SFL_HIDDEN
    bint is_spec_segm(uchar seg_type)  # Has segment a special type?. (#SEG_XTRN, #SEG_GRP,...
    bint is_spec_ea(ea_t ea)  # Does the address belong to a segment with a special...
    void lock_segm(segment_t* segm, bint lock)  # Lock segment pointer Locked pointers are guaranteed to...
    bint is_segm_locked(segment_t* segm)  # Is a segment pointer locked?
    bint getn_selector(sel_t* sel, ea_t* base, int n)  # Get description of selector (0..get_selector_qty()-1)
    size_t get_selector_qty()  # Get number of defined selectors
    sel_t setup_selector(ea_t segbase)  # Allocate a selector for a segment if necessary. You must...
    sel_t allocate_selector(ea_t segbase)  # Allocate a selector for a segment unconditionally. You...
    sel_t find_free_selector()  # Find first unused selector. 
    int set_selector(sel_t selector, ea_t paragraph)  # Set mapping of selector to a paragraph. You should call...
    void del_selector(sel_t selector)  # Delete mapping of a selector. Be wary of deleting...
    ea_t sel2para(sel_t selector)  # Get mapping of a selector. 
    ea_t sel2ea(sel_t selector)  # Get mapping of a selector as a linear address. 
    sel_t find_selector(ea_t base)  # Find a selector that has mapping to the specified paragraph. 
    segment_t* get_segm_by_sel(sel_t selector)  # Get pointer to segment structure. This function finds a...
    bint add_segm_ex(segment_t* s, char* name, char* sclass, int flags)  # Add a new segment. If a segment already exists at the...
    bint add_segm(ea_t para, ea_t start, ea_t end, char* name, char* sclass, int flags)  # Add a new segment, second form. Segment alignment is set...
    bint del_segm(ea_t ea, int flags)  # Delete a segment. 
    int get_segm_qty()  # Get number of segments
    segment_t* getseg(ea_t ea)  # Get pointer to segment by linear address. 
    segment_t* getnseg(int n)  # Get pointer to segment by its number. 
    int get_segm_num(ea_t ea)  # Get number of segment by address. 
    segment_t* get_next_seg(ea_t ea)  # Get pointer to the next segment
    segment_t* get_prev_seg(ea_t ea)  # Get pointer to the previous segment
    segment_t* get_first_seg()  # Get pointer to the first segment
    segment_t* get_last_seg()  # Get pointer to the last segment
    segment_t* get_segm_by_name(char* name)  # Get pointer to segment by its name. If there are several...
    bint set_segm_end(ea_t ea, ea_t newend, int flags)  # Set segment end address. The next segment is shrinked to...
    bint set_segm_start(ea_t ea, ea_t newstart, int flags)  # Set segment start address. The previous segment is...
    bint move_segm_start(ea_t ea, ea_t newstart, int mode)  # Move segment start. The main difference between this...
    char* move_segm_strerror(move_segm_code_t code)  # Return string describing error MOVE_SEGM_... code
    move_segm_code_t move_segm(segment_t* s, ea_t to, int flags)  # This function moves all information to the new address....
    move_segm_code_t rebase_program(adiff_t delta, int flags)  # Rebase the whole program by 'delta' bytes. 
    int change_segment_status(segment_t* s, bint is_deb_segm)  # Convert a debugger segment to a regular segment and vice...
    bint take_memory_snapshot(int type)  # Take a memory snapshot of the running process. 
    bint is_miniidb()  # Is the database a miniidb created by the debugger?. 
    bint set_segm_base(segment_t* s, ea_t newbase)  # Internal function
    int set_group_selector(sel_t grp, sel_t sel)  # Create a new group of segments (used OMF files). 
    sel_t get_group_selector(sel_t grpsel)  # Get common selector for a group of segments. 
    bint add_segment_translation(ea_t segstart, ea_t mappedseg)  # Add segment translation. 
    bint set_segment_translations(ea_t segstart, eavec_t& transmap)  # Set new translation list. 
    void del_segment_translations(ea_t segstart)  # Delete the translation list 
    ssize_t get_segment_translations(eavec_t* transmap, ea_t segstart)  # Get segment translation list. 
    ssize_t get_segment_cmt(qstring* buf, segment_t* s, bint repeatable)  # Get segment comment. 
    void set_segment_cmt(segment_t* s, char* cmt, bint repeatable)  # Set segment comment. 
    int set_segm_name(segment_t* s, char* name, int flags)  # Rename segment. The new name is validated (see...
    ssize_t get_segm_name(qstring* buf, segment_t* s, int flags)  # Get true segment name by pointer to segment. 
    ssize_t get_visible_segm_name(qstring* buf, segment_t* s)  # Get segment name by pointer to segment. 
    ssize_t get_segm_expr(qstring* buf, ea_t from_, sel_t sel)  # Get colored segment name expression in the form (segname...
    ssize_t get_segm_class(qstring* buf, segment_t* s)  # Get segment class. Segment class is arbitrary text (max...
    int set_segm_class(segment_t* s, char* sclass, int flags)  # Set segment class. 
    uchar segtype(ea_t ea)  # Get segment type. 
    char* get_segment_alignment(uchar align)  # Get text representation of segment alignment code. 
    char* get_segment_combination(uchar comb)  # Get text representation of segment combination code. 
    ea_t get_segm_para(segment_t* s)  # Get segment base paragraph. Segment base paragraph may...
    ea_t get_segm_base(segment_t* s)  # Get segment base linear address. Segment base linear...
    bint set_segm_addressing(segment_t* s, size_t bitness)  # Change segment addressing mode (16, 32, 64 bits). You...
    bint is_debugger_segm(ea_t ea)  # Does the address belong to a debug segment?
    bint is_ephemeral_segm(ea_t ea)  # Does the address belong to an ephemeral segment?
    ea_t correct_address(ea_t ea, ea_t from_, ea_t to, ea_t size, bint skip_check)  # ---------------------------------------------------------...
    bint update_segm(segment_t* s)  # ---------------------------------------------------------...
    adiff_t segm_adjust_diff(segment_t* s, adiff_t delta)  # Truncate and sign extend a delta depending on the segment
    ea_t segm_adjust_ea(segment_t* s, ea_t ea)  # Truncate an address depending on the segment
    bint requires_color_esc(char c)  # Is the given char a color escape character?
    void tag_addr(qstring* buf, ea_t ea, bint ins)  # Insert an address mark into a string. 
    char* tag_advance(char* line, int cnt)  # Move pointer to a 'line' to 'cnt' positions right. Take...
    char* tag_skipcodes(char* line)  # Move the pointer past all color codes. 
    char* tag_skipcode(char* line)  # Skip one color code. This function should be used if you...
    ssize_t tag_strlen(char* line)  # Calculate length of a colored string This function...
    ssize_t tag_remove(qstring* buf, char* str, int init_level)  # Remove color escape sequences from a string. 
    color_t calc_prefix_color(ea_t ea)  # Get prefix color for line at 'ea' 
    bgcolor_t calc_bg_color(ea_t ea)  # Get background color for line at 'ea' 
    bint add_sourcefile(ea_t ea1, ea_t ea2, char* filename)  # Mark a range of address as belonging to a source file....
    char* get_sourcefile(ea_t ea, range_t* bounds)  # Get name of source file occupying the given address. 
    bint del_sourcefile(ea_t ea)  # Delete information about the source file. 
    bint install_user_defined_prefix(size_t prefix_len, user_defined_prefix_t* udp, void* owner)  # User-defined line-prefixes are displayed just after the...
    bint add_extra_line(ea_t ea, bint isprev, char* format)  # Add anterior/posterior non-comment line(s). 
    bint add_extra_cmt(ea_t ea, bint isprev, char* format)  # Add anterior/posterior comment line(s). 
    bint add_pgm_cmt(char* format)  # Add anterior comment line(s) at the start of program. 
    int generate_disassembly(qstrvec_t* out, int* lnnum, ea_t ea, int maxsize, int flags)  # Generate disassembly (many lines) and put them into a...
    bint generate_disasm_line(qstring* buf, ea_t ea, int flags)  # Generate one line of disassembly This function discards...
    int get_last_pfxlen()  # Get length of the line prefix that was used for the last...
    char* closing_comment()  # Get pointer to the sequence of characters denoting...
    int get_first_free_extra_cmtidx(ea_t ea, int start)
    bint update_extra_cmt(ea_t ea, int what, char* str)
    bint del_extra_cmt(ea_t ea, int what)
    ssize_t get_extra_cmt(qstring* buf, ea_t ea, int what)
    void delete_extra_cmts(ea_t ea, int what)
    ea_t align_down_to_stack(ea_t newea)
    ea_t align_up_to_stack(ea_t ea1, ea_t ea2)
    error_t enable_flags(ea_t start_ea, ea_t end_ea, storage_type_t stt)  # ---------------------------------------------------------...
    error_t disable_flags(ea_t start_ea, ea_t end_ea)  # Deallocate flags for address range. Exit with an error...
    error_t change_storage_type(ea_t start_ea, ea_t end_ea, storage_type_t stt)  # Change flag storage type for address range. 
    ea_t next_addr(ea_t ea)  # Get next address in the program (i.e. next address which...
    ea_t prev_addr(ea_t ea)  # Get previous address in the program. 
    ea_t next_chunk(ea_t ea)  # Get the first address of next contiguous chunk in the program. 
    ea_t prev_chunk(ea_t ea)  # Get the last address of previous contiguous chunk in the...
    ea_t chunk_start(ea_t ea)  # Get start of the contiguous address block containing 'ea'. 
    asize_t chunk_size(ea_t ea)  # Get size of the contiguous address block containing 'ea'. 
    ea_t find_free_chunk(ea_t start, asize_t size, asize_t alignment)  # Search for a hole in the addressing space of the program. 
    ea_t next_unknown(ea_t ea, ea_t maxea)  # Similar to next_that(), but will find the next address...
    ea_t prev_unknown(ea_t ea, ea_t minea)  # Similar to prev_that(), but will find the previous...
    ea_t prev_head(ea_t ea, ea_t minea)  # Get start of previous defined item. 
    ea_t next_head(ea_t ea, ea_t maxea)  # Get start of next defined item. 
    ea_t prev_not_tail(ea_t ea)  # Get address of previous non-tail byte. 
    ea_t next_not_tail(ea_t ea)  # Get address of next non-tail byte. 
    ea_t adjust_visea(ea_t ea)  # Adjust the address and get the nearest visible address....
    ea_t prev_visea(ea_t ea)  # Get previous visible address. 
    ea_t next_visea(ea_t ea)  # Get next visible address. 
    bint is_first_visea(ea_t ea)  # Is an address the first visible address?
    bint is_last_visea(ea_t ea)  # Is an address the last visible address?
    bint is_visible_finally(ea_t ea)  # Is the address visible on the screen (not hidden)?
    ea_t get_item_head(ea_t ea)  # Get the start address of the item at 'ea'. If there is...
    ea_t get_item_end(ea_t ea)  # Get the end address of the item at 'ea'. The returned...
    ea_t calc_max_item_end(ea_t ea, int how)  # Calculate maximal reasonable end address of a new item....
    asize_t get_item_size(ea_t ea)  # Get size of item (instruction/data) in bytes. Unexplored...
    bint is_mapped(ea_t ea)  # Is the specified address 'ea' present in the program?
    flags64_t get_flags_ex(ea_t ea, int how)  # Get flags for the specified address, extended form
    flags64_t get_flags32(ea_t ea)  # Get only 32 low bits of flags. This function returns the...
    flags64_t get_flags(ea_t ea)  # Get flags value for address 'ea'. The byte value is not...
    flags64_t get_full_flags(ea_t ea)  # Get full flags value for address 'ea'. This function...
    flags64_t get_item_flag(ea_t from_, int n, ea_t ea, bint appzero)  # Get flag of the item at 'ea' even if it is a tail byte...
    bint get_item_refinfo(refinfo_t* ri, ea_t ea, int n)  # ---------------------------------------------------------...
    bint has_value(flags64_t F)  # Do flags contain byte value?
    void del_value(ea_t ea)  # Delete byte value from flags. The corresponding byte...
    bint is_loaded(ea_t ea)  # Does the specified address have a byte value (is initialized?)
    int nbits(ea_t ea)  # Get number of bits in a byte at the given address. 
    int bytesize(ea_t ea)  # Get number of bytes required to store a byte at the given address
    uchar get_byte(ea_t ea)  # Get one byte (8-bit) of the program at 'ea'. This...
    uchar get_db_byte(ea_t ea)  # Get one byte (8-bit) of the program at 'ea' from the...
    ushort get_word(ea_t ea)  # Get one word (16-bit) of the program at 'ea'. This...
    uint32 get_dword(ea_t ea)  # Get one dword (32-bit) of the program at 'ea'. This...
    uint64 get_qword(ea_t ea)  # Get one qword (64-bit) of the program at 'ea'. This...
    uint64 get_wide_byte(ea_t ea)  # Get one wide byte of the program at 'ea'. Some...
    uint64 get_wide_word(ea_t ea)  # Get one wide word (2 'byte') of the program at 'ea'....
    uint64 get_wide_dword(ea_t ea)  # Get two wide words (4 'bytes') of the program at 'ea'....
    bint get_octet(uchar* out, octet_generator_t* ogen)
    uint32 get_16bit(ea_t ea)  # Get 16bits of the program at 'ea'. 
    uint32 get_32bit(ea_t ea)  # Get not more than 32bits of the program at 'ea'. 
    uint64 get_64bit(ea_t ea)  # Get not more than 64bits of the program at 'ea'. 
    bint get_data_value(uval_t* v, ea_t ea, asize_t size)  # Get the value at of the item at 'ea'. This function...
    uint64 get_original_byte(ea_t ea)  # Get original byte value (that was before patching). This...
    uint64 get_original_word(ea_t ea)  # Get original word value (that was before patching). This...
    uint64 get_original_dword(ea_t ea)  # Get original dword (that was before patching) This...
    uint64 get_original_qword(ea_t ea)  # Get original qword value (that was before patching) This...
    bint put_byte(ea_t ea, uint64 x)  # Set value of one byte of the program. This function...
    void put_word(ea_t ea, uint64 x)  # Set value of one word of the program. This function...
    void put_dword(ea_t ea, uint64 x)  # Set value of one dword of the program. This function...
    void put_qword(ea_t ea, uint64 x)  # Set value of one qword (8 bytes) of the program. This...
    bint patch_byte(ea_t ea, uint64 x)  # Patch a byte of the program. The original value of the...
    bint patch_word(ea_t ea, uint64 x)  # Patch a word of the program. The original value of the...
    bint patch_dword(ea_t ea, uint64 x)  # Patch a dword of the program. The original value of the...
    bint patch_qword(ea_t ea, uint64 x)  # Patch a qword of the program. The original value of the...
    bint revert_byte(ea_t ea)  # Revert patched byte 
    void add_byte(ea_t ea, uint32 value)  # Add a value to one byte of the program. This function...
    void add_word(ea_t ea, uint64 value)  # Add a value to one word of the program. This function...
    void add_dword(ea_t ea, uint64 value)  # Add a value to one dword of the program. This function...
    void add_qword(ea_t ea, uint64 value)  # Add a value to one qword of the program. This function...
    bint get_zero_ranges(rangeset_t* zranges, range_t* range)  # Return set of ranges with zero initialized bytes. The...
    ssize_t get_bytes(void* buf, ssize_t size, ea_t ea, int gmb_flags, void* mask)  # Get the specified number of bytes of the program into...
    void put_bytes(ea_t ea, void* buf, size_t size)  # Modify the specified number of bytes of the program....
    void patch_bytes(ea_t ea, void* buf, size_t size)  # Patch the specified number of bytes of the program....
    bint is_code(flags64_t F)  # Does flag denote start of an instruction?
    bint f_is_code(flags64_t F, void*)
    bint is_data(flags64_t F)  # Does flag denote start of data?
    bint f_is_data(flags64_t F, void*)
    bint is_tail(flags64_t F)  # Does flag denote tail byte?
    bint f_is_tail(flags64_t F, void*)
    bint is_not_tail(flags64_t F)
    bint f_is_not_tail(flags64_t F, void*)
    bint is_unknown(flags64_t F)  # Does flag denote unexplored byte?
    bint is_head(flags64_t F)  # Does flag denote start of instruction OR data?
    bint f_is_head(flags64_t F, void*)
    bint is_manual_insn(ea_t ea)  # Is the instruction overridden? 
    ssize_t get_manual_insn(qstring* buf, ea_t ea)  # Retrieve the user-specified string for the manual instruction. 
    void set_manual_insn(ea_t ea, char* manual_insn)  # Set manual instruction string. 
    bint is_flow(flags64_t F)  # Does the previous instruction exist and pass execution...
    bint has_extra_cmts(flags64_t F)  # Does the current byte have additional anterior or...
    bint f_has_extra_cmts(flags64_t f, void*)
    bint has_cmt(flags64_t F)  # Does the current byte have an indented comment?
    bint f_has_cmt(flags64_t f, void*)
    bint has_xref(flags64_t F)  # Does the current byte have cross-references to it?
    bint f_has_xref(flags64_t f, void*)
    bint has_name(flags64_t F)  # Does the current byte have non-trivial (non-dummy) name?
    bint f_has_name(flags64_t f, void*)
    bint has_dummy_name(flags64_t F)  # Does the current byte have dummy (auto-generated, with...
    bint f_has_dummy_name(flags64_t f, void*)
    bint has_auto_name(flags64_t F)  # Does the current byte have auto-generated (no special...
    bint has_any_name(flags64_t F)  # Does the current byte have any name?
    bint has_user_name(flags64_t F)  # Does the current byte have user-specified name?
    bint f_has_user_name(flags64_t F, void*)
    bint is_invsign(ea_t ea, flags64_t F, int n)  # Should sign of n-th operand inverted during output?....
    bint toggle_sign(ea_t ea, int n)  # Toggle sign of n-th operand. allowed values of n:...
    bint is_bnot(ea_t ea, flags64_t F, int n)  # Should we negate the operand?.  {a_bnot} should be...
    bint toggle_bnot(ea_t ea, int n)
    bint is_lzero(ea_t ea, int n)  # Display leading zeroes? Display leading zeroes in...
    bint set_lzero(ea_t ea, int n)  # Set toggle lzero bit. This function changes the display...
    bint clr_lzero(ea_t ea, int n)  # Clear toggle lzero bit. This function reset the display...
    bint toggle_lzero(ea_t ea, int n)  # Toggle lzero bit. 
    bint leading_zero_important(ea_t ea, int n)  # Check if leading zeroes are important
    int get_operand_type_shift(uint32 n)  # Get the shift in `flags64_t` for the nibble representing...
    flags64_t get_operand_flag(uint8 typebits, int n)  # Place operand `n`'s type flag in the right nibble of a...
    bint is_flag_for_operand(flags64_t F, uint8 typebits, int n)  # Check that the 64-bit flags set has the expected type...
    bint is_defarg0(flags64_t F)  # Is the first operand defined? Initially operand has no...
    bint is_defarg1(flags64_t F)  # Is the second operand defined? Initially operand has no...
    bint is_off0(flags64_t F)  # Is the first operand offset? (example: push offset xxx)
    bint is_off1(flags64_t F)  # Is the second operand offset? (example: mov ax, offset xxx)
    bint is_char0(flags64_t F)  # Is the first operand character constant? (example: push 'a')
    bint is_char1(flags64_t F)  # Is the second operand character constant? (example: mov al, 'a')
    bint is_seg0(flags64_t F)  # Is the first operand segment selector? (example: push seg seg001)
    bint is_seg1(flags64_t F)  # Is the second operand segment selector? (example: mov...
    bint is_enum0(flags64_t F)  # Is the first operand a symbolic constant (enum member)?
    bint is_enum1(flags64_t F)  # Is the second operand a symbolic constant (enum member)?
    bint is_stroff0(flags64_t F)  # Is the first operand an offset within a struct?
    bint is_stroff1(flags64_t F)  # Is the second operand an offset within a struct?
    bint is_stkvar0(flags64_t F)  # Is the first operand a stack variable?
    bint is_stkvar1(flags64_t F)  # Is the second operand a stack variable?
    bint is_float0(flags64_t F)  # Is the first operand a floating point number?
    bint is_float1(flags64_t F)  # Is the second operand a floating point number?
    bint is_custfmt0(flags64_t F)  # Does the first operand use a custom data representation?
    bint is_custfmt1(flags64_t F)  # Does the second operand use a custom data representation?
    bint is_numop0(flags64_t F)  # Is the first operand a number (i.e. binary, octal,...
    bint is_numop1(flags64_t F)  # Is the second operand a number (i.e. binary, octal,...
    flags64_t get_optype_flags0(flags64_t F)  # Get flags for first operand
    flags64_t get_optype_flags1(flags64_t F)  # Get flags for second operand
    bint is_defarg(flags64_t F, int n)  #  For the following functions, 'n' may be: - zero based...
    bint is_off(flags64_t F, int n)
    bint is_char(flags64_t F, int n)
    bint is_seg(flags64_t F, int n)
    bint is_enum(flags64_t F, int n)
    bint is_manual(flags64_t F, int n)
    bint is_stroff(flags64_t F, int n)
    bint is_stkvar(flags64_t F, int n)
    bint is_fltnum(flags64_t F, int n)
    bint is_custfmt(flags64_t F, int n)
    bint is_numop(flags64_t F, int n)
    bint is_suspop(ea_t ea, flags64_t F, int n)
    bint op_adds_xrefs(flags64_t F, int n)  # Should processor module create xrefs from the operand?....
    bint set_op_type(ea_t ea, flags64_t type, int n)  # (internal function) change representation of operand(s). 
    bint op_seg(ea_t ea, int n)  # Set operand representation to be 'segment'. If applied...
    bint op_enum(ea_t ea, int n, tid_t id, uchar serial)  # Set operand representation to be enum type If applied to...
    tid_t get_enum_id(uchar* serial, ea_t ea, int n)  # Get enum id of 'enum' operand. 
    bint op_stroff(insn_t& insn, int n, tid_t* path, int path_len, adiff_t delta)  # Set operand representation to be 'struct offset'. 
    bint op_based_stroff(insn_t& insn, int n, adiff_t opval, ea_t base)  # Set operand representation to be 'struct offset' if the...
    int get_stroff_path(tid_t* path, adiff_t* delta, ea_t ea, int n)  # Get struct path of operand. 
    bint op_stkvar(ea_t ea, int n)  # Set operand representation to be 'stack variable'....
    bint set_forced_operand(ea_t ea, int n, char* op)  # Set forced operand. 
    ssize_t get_forced_operand(qstring* buf, ea_t ea, int n)  # Get forced operand. 
    bint is_forced_operand(ea_t ea, int n)  # Is operand manually defined?. 
    flags64_t combine_flags(flags64_t F)  # ---------------------------------------------------------...
    flags64_t char_flag()  # ---------------------------------------------------------...
    flags64_t off_flag()
    flags64_t enum_flag()
    flags64_t stroff_flag()
    flags64_t stkvar_flag()
    flags64_t flt_flag()
    flags64_t custfmt_flag()
    flags64_t seg_flag()
    flags64_t num_flag()
    flags64_t hex_flag()  # Get number flag of the base, regardless of current...
    flags64_t dec_flag()
    flags64_t oct_flag()
    flags64_t bin_flag()
    bint op_chr(ea_t ea, int n)  #  The following functions set operand representation. If...
    bint op_num(ea_t ea, int n)
    bint op_hex(ea_t ea, int n)
    bint op_dec(ea_t ea, int n)
    bint op_oct(ea_t ea, int n)
    bint op_bin(ea_t ea, int n)
    bint op_flt(ea_t ea, int n)
    bint op_custfmt(ea_t ea, int n, int fid)  # Set custom data format for operand (fid-custom data format id)
    bint clr_op_type(ea_t ea, int n)  # Remove operand representation information. (set operand...
    int get_default_radix()  # Get default base of number for the current processor. 
    int get_radix(flags64_t F, int n)  # Get radix of the operand, in: flags. If the operand is...
    flags64_t code_flag()  #  @ {
    flags64_t byte_flag()
    flags64_t word_flag()
    flags64_t dword_flag()
    flags64_t qword_flag()
    flags64_t oword_flag()
    flags64_t yword_flag()
    flags64_t zword_flag()
    flags64_t tbyte_flag()
    flags64_t strlit_flag()
    flags64_t stru_flag()
    flags64_t cust_flag()
    flags64_t align_flag()
    flags64_t float_flag()
    flags64_t double_flag()
    flags64_t packreal_flag()
    bint is_byte(flags64_t F)
    bint is_word(flags64_t F)
    bint is_dword(flags64_t F)
    bint is_qword(flags64_t F)
    bint is_oword(flags64_t F)
    bint is_yword(flags64_t F)
    bint is_zword(flags64_t F)
    bint is_tbyte(flags64_t F)
    bint is_float(flags64_t F)
    bint is_double(flags64_t F)
    bint is_pack_real(flags64_t F)
    bint is_strlit(flags64_t F)
    bint is_struct(flags64_t F)
    bint is_align(flags64_t F)
    bint is_custom(flags64_t F)
    bint f_is_byte(flags64_t F, void*)
    bint f_is_word(flags64_t F, void*)
    bint f_is_dword(flags64_t F, void*)
    bint f_is_qword(flags64_t F, void*)
    bint f_is_oword(flags64_t F, void*)
    bint f_is_yword(flags64_t F, void*)
    bint f_is_tbyte(flags64_t F, void*)
    bint f_is_float(flags64_t F, void*)
    bint f_is_double(flags64_t F, void*)
    bint f_is_pack_real(flags64_t F, void*)
    bint f_is_strlit(flags64_t F, void*)
    bint f_is_struct(flags64_t F, void*)
    bint f_is_align(flags64_t F, void*)
    bint f_is_custom(flags64_t F, void*)
    bint is_same_data_type(flags64_t F1, flags64_t F2)  # Do the given flags specify the same data type?
    flags64_t get_flags_by_size(size_t size)  # Get flags from size (in bytes). Supported sizes: 1, 2,...
    bint create_data(ea_t ea, flags64_t dataflag, asize_t size, tid_t tid)  # Convert to data (byte, word, dword, etc). This function...
    flags64_t calc_dflags(flags64_t f, bint force)
    bint create_byte(ea_t ea, asize_t length, bint force)  # Convert to byte
    bint create_word(ea_t ea, asize_t length, bint force)  # Convert to word
    bint create_dword(ea_t ea, asize_t length, bint force)  # Convert to dword
    bint create_qword(ea_t ea, asize_t length, bint force)  # Convert to quadword
    bint create_oword(ea_t ea, asize_t length, bint force)  # Convert to octaword/xmm word
    bint create_yword(ea_t ea, asize_t length, bint force)  # Convert to ymm word
    bint create_zword(ea_t ea, asize_t length, bint force)  # Convert to zmm word
    bint create_tbyte(ea_t ea, asize_t length, bint force)  # Convert to tbyte
    bint create_float(ea_t ea, asize_t length, bint force)  # Convert to float
    bint create_double(ea_t ea, asize_t length, bint force)  # Convert to double
    bint create_packed_real(ea_t ea, asize_t length, bint force)  # Convert to packed decimal real
    bint create_struct(ea_t ea, asize_t length, tid_t tid, bint force)  # Convert to struct
    bint create_custdata(ea_t ea, asize_t length, int dtid, int fid, bint force)  # Convert to custom data type
    bint create_align(ea_t ea, asize_t length, int alignment)  # Create an alignment item. 
    int calc_min_align(asize_t length)  # Calculate the minimal possible alignment exponent. 
    int calc_max_align(ea_t endea)  # Calculate the maximal possible alignment exponent. 
    int calc_def_align(ea_t ea, int mina, int maxa)  # Calculate the default alignment exponent. 
    bint create_16bit_data(ea_t ea, asize_t length)  # Convert to 16-bit quantity (take the byte size into account)
    bint create_32bit_data(ea_t ea, asize_t length)  # Convert to 32-bit quantity (take the byte size into account)
    size_t get_max_strlit_length(ea_t ea, int32 strtype, int options)  # Determine maximum length of string literal. If the...
    ssize_t get_strlit_contents(qstring* utf8, ea_t ea, size_t len, int32 type, size_t* maxcps, int flags)  # Get contents of string literal, as UTF-8-encoded...
    bint create_strlit(ea_t start, size_t len, int32 strtype)  # Convert to string literal and give a meaningful name....
    bint print_strlit_type(qstring* out, int32 strtype, qstring* out_tooltip, int flags)  # Get string type information: the string type name...
    opinfo_t* get_opinfo(opinfo_t* buf, ea_t ea, int n, flags64_t flags)  # Get additional information about an operand representation. 
    bint set_opinfo(ea_t ea, int n, flags64_t flag, opinfo_t* ti, bint suppress_events)  # Set additional information about an operand...
    asize_t get_data_elsize(ea_t ea, flags64_t F, opinfo_t* ti)  # Get size of data type specified in flags 'F'.  If flags...
    asize_t get_full_data_elsize(ea_t ea, flags64_t F, opinfo_t* ti)  # Get full size of data type specified in flags 'F'. takes...
    int is_varsize_item(ea_t ea, flags64_t F, opinfo_t* ti, asize_t* itemsize)  # Is the item at 'ea' variable size?. 
    asize_t get_possible_item_varsize(ea_t ea, tinfo_t& tif)  # Return the possible size of the item at EA of type TIF...
    bint can_define_item(ea_t ea, asize_t length, flags64_t flags)  # Can define item (instruction/data) of the specified...
    bint has_immd(flags64_t F)  # Has immediate value?
    bint is_func(flags64_t F)  # Is function start?
    bint set_immd(ea_t ea)  # Set 'has immediate operand' flag. Returns true if the...
    int register_custom_data_type(data_type_t* dtinfo)  # Register a new data type. 
    bint unregister_custom_data_type(int dtid)  # Unregister a data type. When the idb is closed, all...
    int register_custom_data_format(data_format_t* dtform)  # Register a new data format. 
    bint unregister_custom_data_format(int dfid)  # Unregister a data format. 
    data_type_t* get_custom_data_type(int dtid)  # Get definition of a registered custom data type. 
    data_format_t* get_custom_data_format(int dfid)  # Get definition of a registered custom data format. 
    bint attach_custom_data_format(int dtid, int dfid)  # Attach the data format to the data type. 
    bint detach_custom_data_format(int dtid, int dfid)  # Detach the data format from the data type. Unregistering...
    bint is_attached_custom_data_format(int dtid, int dfid)  # Is the custom data format attached to the custom data type? 
    int get_custom_data_types(intvec_t* out, asize_t min_size, asize_t max_size)  # Get list of registered custom data type ids. 
    int get_custom_data_formats(intvec_t* out, int dtid)  # Get list of attached custom data formats for the...
    int find_custom_data_type(char* name)  # Get id of a custom data type. 
    int find_custom_data_format(char* name)  # Get id of a custom data format. 
    bint set_cmt(ea_t ea, char* comm, bint rptble)  # Set an indented comment. 
    ssize_t get_cmt(qstring* buf, ea_t ea, bint rptble)  # Get an indented comment. 
    bint append_cmt(ea_t ea, char* str, bint rptble)  # Append to an indented comment. Creates a new comment if...
    ssize_t get_predef_insn_cmt(qstring* buf, insn_t& ins)  # Get predefined comment. 
    ea_t find_byte(ea_t sEA, asize_t size, uchar value, int bin_search_flags)  # ---------------------------------------------------------...
    ea_t find_byter(ea_t sEA, asize_t size, uchar value, int bin_search_flags)  # Find reverse a byte with the specified value (only 8-bit...
    bint parse_binpat_str(compiled_binpat_vec_t* out, ea_t ea, char* in_, int radix, int strlits_encoding, qstring* errbuf)  # Convert user-specified binary string to internal...
    ea_t bin_search(ea_t start_ea, ea_t end_ea, compiled_binpat_vec_t& data, int flags, size_t* out_matched_idx)  # Search for a pattern in the program. 
    ea_t next_inited(ea_t ea, ea_t maxea)  # Find the next initialized address
    ea_t prev_inited(ea_t ea, ea_t minea)  # Find the previous initialized address
    bint equal_bytes(ea_t ea, uchar* image, uchar* mask, size_t len, int bin_search_flags)  # Compare 'len' bytes of the program starting from 'ea'...
    bint bytes_match_for_bin_search(uchar c1, uchar c2, uchar* mask, int i, int bin_search_flags)  # Compare two bytes. This helper function is used for...
    ea_t find_binary(ea_t startea, ea_t endea, char* ubinstr, int radix, int sflag, int strlits_encoding)
    bint update_hidden_range(hidden_range_t* ha)  # Update hidden range information in the database. You...
    bint add_hidden_range(ea_t ea1, ea_t ea2, char* description, char* header, char* footer, bgcolor_t color)  # Mark a range of addresses as hidden. The range will be...
    hidden_range_t* get_hidden_range(ea_t ea)  # Get pointer to hidden range structure, in: linear address. 
    hidden_range_t* getn_hidden_range(int n)  # Get pointer to hidden range structure, in: number of...
    int get_hidden_range_qty()  # Get number of hidden ranges
    int get_hidden_range_num(ea_t ea)  # Get number of a hidden range. 
    hidden_range_t* get_prev_hidden_range(ea_t ea)  # Get pointer to previous hidden range. 
    hidden_range_t* get_next_hidden_range(ea_t ea)  # Get pointer to next hidden range. 
    hidden_range_t* get_first_hidden_range()  # Get pointer to the first hidden range. 
    hidden_range_t* get_last_hidden_range()  # Get pointer to the last hidden range. 
    bint del_hidden_range(ea_t ea)  # Delete hidden range. 
    bint add_mapping(ea_t from_, ea_t to, asize_t size)  # Add memory mapping range. 
    void del_mapping(ea_t ea)  # Delete memory mapping range. 
    ea_t use_mapping(ea_t ea)  # Translate address according to current mappings. 
    size_t get_mappings_qty()  # Get number of mappings.
    bint get_mapping(ea_t* from_, ea_t* to, asize_t* size, size_t n)  # Get memory mapping range by its number. 
    ssize_t get_hex_string(char* buf, size_t bufsize, uchar* bytes, size_t len)  # byte array to hex string
    bint is_func_entry(func_t* pfn)  # Does function describe a function entry chunk?
    bint is_func_tail(func_t* pfn)  # Does function describe a function tail chunk?
    void lock_func_range(func_t* pfn, bint lock)  # Lock function pointer Locked pointers are guaranteed to...
    bint is_func_locked(func_t* pfn)  # Is the function pointer locked?
    func_t* get_func(ea_t ea)  # ---------------------------------------------------------...
    int get_func_chunknum(func_t* pfn, ea_t ea)  # Get the containing tail chunk of 'ea'. 
    bint func_contains(func_t* pfn, ea_t ea)  # Does the given function contain the given address?
    bint is_same_func(ea_t ea1, ea_t ea2)  # Do two addresses belong to the same function?
    func_t* getn_func(size_t n)  # Get pointer to function structure by number. 
    size_t get_func_qty()  # Get total number of functions in the program
    int get_func_num(ea_t ea)  # Get ordinal number of a function. 
    func_t* get_prev_func(ea_t ea)  # Get pointer to the previous function. 
    func_t* get_next_func(ea_t ea)  # Get pointer to the next function. 
    ea_t get_func_ranges(rangeset_t* ranges, func_t* pfn)  # Get function ranges. 
    ssize_t get_func_cmt(qstring* buf, func_t* pfn, bint repeatable)  # Get function comment. 
    bint set_func_cmt(func_t* pfn, char* cmt, bint repeatable)  # Set function comment. This function works with function...
    bint update_func(func_t* pfn)  # Update information about a function in the database...
    bint add_func_ex(func_t* pfn)  # Add a new function. If the fn->end_ea is #BADADDR, then...
    bint add_func(ea_t ea1, ea_t ea2)  # Add a new function. If the function end address is...
    bint del_func(ea_t ea)  # Delete a function. 
    int set_func_start(ea_t ea, ea_t newstart)  # Move function chunk start address. 
    bint set_func_end(ea_t ea, ea_t newend)  # Move function chunk end address. 
    void reanalyze_function(func_t* pfn, ea_t ea1, ea_t ea2, bint analyze_parents)  # Reanalyze a function. This function plans to analyzes...
    int find_func_bounds(func_t* nfn, int flags)  # Determine the boundaries of a new function. This...
    ssize_t get_func_name(qstring* out, ea_t ea)  # Get function name. 
    asize_t calc_func_size(func_t* pfn)  # Calculate function size. This function takes into...
    int get_func_bitness(func_t* pfn)  # Get function bitness (which is equal to the function...
    int get_func_bits(func_t* pfn)  # Get number of bits in the function addressing
    int get_func_bytes(func_t* pfn)  # Get number of bytes in the function addressing
    bint is_visible_func(func_t* pfn)  # Is the function visible (not hidden)?
    bint is_finally_visible_func(func_t* pfn)  # Is the function visible (event after considering...
    void set_visible_func(func_t* pfn, bint visible)  # Set visibility of function
    int set_func_name_if_jumpfunc(func_t* pfn, char* oldname)  # Give a meaningful name to function if it consists of...
    ea_t calc_thunk_func_target(func_t* pfn, ea_t* fptr)  # Calculate target of a thunk function. 
    bint func_does_return(ea_t callee)  # Does the function return?. To calculate the answer,...
    bint reanalyze_noret_flag(ea_t ea)  # Plan to reanalyze noret flag. This function does not...
    bint set_noret_insn(ea_t insn_ea, bint noret)  # Signal a non-returning instruction. This function can be...
    func_t* get_fchunk(ea_t ea)  # ---------------------------------------------------------...
    func_t* getn_fchunk(int n)  # Get pointer to function chunk structure by number. 
    size_t get_fchunk_qty()  # Get total number of function chunks in the program
    int get_fchunk_num(ea_t ea)  # Get ordinal number of a function chunk in the global...
    func_t* get_prev_fchunk(ea_t ea)  # Get pointer to the previous function chunk in the global list. 
    func_t* get_next_fchunk(ea_t ea)  # Get pointer to the next function chunk in the global list. 
    bint append_func_tail(func_t* pfn, ea_t ea1, ea_t ea2)  # Append a new tail chunk to the function definition. If...
    bint remove_func_tail(func_t* pfn, ea_t tail_ea)  # Remove a function tail. If the tail belongs only to one...
    bint set_tail_owner(func_t* fnt, ea_t new_owner)  # Set a new owner of a function tail. The new owner...
    bint func_tail_iterator_set(func_tail_iterator_t* fti, func_t* pfn, ea_t ea)
    bint func_tail_iterator_set_ea(func_tail_iterator_t* fti, ea_t ea)
    bint func_parent_iterator_set(func_parent_iterator_t* fpi, func_t* pfn)
    bint func_item_iterator_decode_prev_insn(func_item_iterator_t* fii, insn_t* out)
    bint func_item_iterator_decode_preceding_insn(func_item_iterator_t* fii, eavec_t* visited, bint* p_farref, insn_t* out)
    bint f_any(flags64_t, void*)  # Helper function to accept any address
    ea_t get_prev_func_addr(func_t* pfn, ea_t ea)  #  Unlike func_item_iterator_t which always enumerates the...
    ea_t get_next_func_addr(func_t* pfn, ea_t ea)
    void read_regargs(func_t* pfn)  # ---------------------------------------------------------...
    void add_regarg(func_t* pfn, int reg, tinfo_t& tif, char* name)
    int plan_to_apply_idasgn(char* fname)  # Add a signature file to the list of planned signature files. 
    int apply_idasgn_to(char* signame, ea_t ea, bint is_startup)  # Apply a signature file to the specified address. 
    int get_idasgn_qty()  # Get number of signatures in the list of planned and...
    int get_current_idasgn()  # Get number of the the current signature. 
    int calc_idasgn_state(int n)  # Get state of a signature in the list of planned signatures 
    int del_idasgn(int n)  # Remove signature from the list of planned signatures. 
    int32 get_idasgn_desc(qstring* signame, qstring* optlibs, int n)  # Get information about a signature in the list. 
    ssize_t get_idasgn_title(qstring* buf, char* name)  # Get full description of the signature by its short name. 
    void determine_rtl()  # Determine compiler/vendor using the startup signatures....
    bint apply_startup_sig(ea_t ea, char* startup)  # Apply a startup signature file to the specified address.  
    int try_to_add_libfunc(ea_t ea)  # Apply the currently loaded signature file to the...
    ssize_t get_kernel_version(char* buf, size_t bufsize)  # Get IDA kernel version (in a string like "5.1").
    bint is_ida_library(char* path, size_t pathsize, void** handle)
    int l_compare(place_t* t1, place_t* t2)  # compare places and their lnnums
    int l_compare2(place_t* t1, place_t* t2, void* ud)
    bint l_equals(place_t* t1, place_t* t2, void* ud)
    bint is_tif_cursor_header(tif_cursor_t c)
    bint is_tif_cursor_footer(tif_cursor_t c)
    bint is_tif_cursor_index(tif_cursor_t c)
    int internal_register_place_class(place_t* tmplate, int flags, plugin_t* owner, int sdk_version)  # ---------------------------------------------------------...
    int register_place_class(place_t* tmplate, int flags, plugin_t* owner)  # ---------------------------------------------------------...
    place_t* get_place_class(int* out_flags, int* out_sdk_version, int id)  # ---------------------------------------------------------...
    place_t* get_place_class_template(int id)  # ---------------------------------------------------------...
    bint is_place_class_ea_capable(int id)  # ---------------------------------------------------------...
    int get_place_class_id(char* name)  # ---------------------------------------------------------...
    void request_refresh(uint64 mask, bint cnd)  # Request a refresh of a builtin window. 
    void clear_refresh_request(uint64 mask)
    bint is_refresh_requested(uint64 mask)  # Get a refresh request state 
    bint is_chooser_widget(twidget_type_t t)  # Does the given widget type specify a chooser widget?
    bint is_action_enabled(action_state_t s)  # Check if the given action state is one of AST_ENABLE*
    int execute_ui_requests(ui_requests_t* reqs)  # Execute a list of UI requests (::ui_execute_ui_requests_list). 
    bint cancel_exec_request(int req_id)  # Try to cancel an asynchronous exec request...
    synced_group_t* get_synced_group(TWidget* w)  # Get the group of widgets/registers this view is...
    bint jumpto(ea_t ea, int opnum, int uijmp_flags)  # Jump to the specified address (::ui_jumpto). 
    bint banner(int wait)  # Show a banner dialog box (::ui_banner). 
    bint is_msg_inited()  # Can we use msg() functions?
    void refresh_idaview()  # Refresh marked windows (::ui_refreshmarked)
    void refresh_idaview_anyway()  # Refresh all disassembly views (::ui_refresh), forces an...
    void analyzer_options()  # Allow the user to set analyzer options. (show a dialog...
    ea_t get_screen_ea()  # Get the address at the screen cursor (::ui_screenea)
    int get_opnum()  # Get current operand number, -1 means no operand (::ui_get_opnum)
    bint get_cursor(int* x, int* y)  # Get the cursor position on the screen (::ui_get_cursor). 
    bint get_output_cursor(int* x, int* y)  # Get coordinates of the output window's cursor...
    char* get_curline()  # Get current line from the disassemble window (::ui_get_curline). 
    void open_url(char* url)  # Open the given url (::ui_open_url)
    ea_t get_hexdump_ea(int hexdump_num)  # Get the current address in a hex view. 
    ushort get_key_code(char* keyname)  # Get keyboard key code by its name (::ui_get_key_code)
    ushort lookup_key_code(int key, int shift, bint is_qt)  # Get shortcut code previously created by ::ui_get_key_code. 
    void refresh_navband(bint force)  # Refresh navigation band if changed (::ui_refresh_navband). 
    bint refresh_chooser(char* title)  # Mark a non-modal custom chooser for a refresh...
    bint close_chooser(char* title)  # Close a non-modal chooser (::ui_close_chooser). 
    void install_command_interpreter(cli_t* cp)  # Install command line interpreter (::ui_install_cli)
    void remove_command_interpreter(cli_t* cp)  # Remove command line interpreter (::ui_install_cli)
    void gen_disasm_text(text_t& text, ea_t ea1, ea_t ea2, bint truncate_lines)  # Generate disassembly text for a range. 
    ssize_t execute_sync(exec_request_t& req, int reqf)  # Execute code in the main thread. 
    bint set_dock_pos(char* src_ctrl, char* dest_ctrl, int orient, int left, int top, int right, int bottom)  # Set the docking position of a widget (::ui_set_dock_pos). 
    int get_icon_id_by_name(char* icon_name)  # Retrieve the id of the icon by name (::ui_get_icon_id_by_name). 
    int load_custom_icon(char* file_name)  # Load an icon from a file (::ui_load_custom_icon_file)....
    void free_custom_icon(int icon_id)  # Free an icon loaded with load_custom_icon()...
    bint process_ui_action(char* name, int flags, void* param)  # Processes a UI action by name. 
    bint take_database_snapshot(snapshot_t* ss, qstring* err_msg)  # Take a database snapshot (::ui_take_database_snapshot). 
    bint register_action(action_desc_t& desc)  # Create a new action (::ui_register_action). After an...
    bint unregister_action(char* name)  # Delete a previously-registered action (::ui_unregister_action). 
    void get_registered_actions(qstrvec_t* out)  # Get a list of all currently-registered actions 
    bint create_toolbar(char* name, char* label, char* before, int flags)  # Create a toolbar with the given name, label and optional...
    bint delete_toolbar(char* name)  # Delete an existing toolbar 
    bint create_menu(char* name, char* label, char* menupath)  # Create a menu with the given name, label and optional...
    bint delete_menu(char* name)  # Delete an existing menu 
    bint attach_action_to_menu(char* menupath, char* name, int flags)  # Attach a previously-registered action to the menu...
    bint detach_action_from_menu(char* menupath, char* name)  # Detach an action from the menu (::ui_detach_action_from_menu). 
    bint attach_action_to_toolbar(char* toolbar_name, char* name)  # Attach an action to an existing toolbar...
    bint detach_action_from_toolbar(char* toolbar_name, char* name)  # Detach an action from the toolbar...
    bint register_and_attach_to_menu(char* menupath, char* name, char* label, char* shortcut, int flags, action_handler_t* handler, void* owner, int action_desc_t_flags)  # Helper. You are not encouraged to use this, as it mixes...
    void display_widget(TWidget* widget, uint32 options, char* dest_ctrl)  # Display a widget, dock it if not done before 
    void close_widget(TWidget* widget, int options)  # Close widget (::ui_close_widget, only gui version). 
    void activate_widget(TWidget* widget, bint take_focus)  # Activate widget (only gui version) (::ui_activate_widget). 
    TWidget* find_widget(char* caption)  # Find widget with the specified caption (only gui...
    TWidget* get_current_widget()  # Get a pointer to the current widget (::ui_get_current_widget).
    twidget_type_t get_widget_type(TWidget* widget)  # Get the type of the TWidget * (::ui_get_widget_type).
    bint get_widget_title(qstring* buf, TWidget* widget)  # Get the TWidget's title (::ui_get_widget_title).
    TWidget* create_custom_viewer(char* title, place_t* minplace, place_t* maxplace, place_t* curplace, int* rinfo, void* ud, int* cvhandlers, void* cvhandlers_ud, TWidget* parent)  # Create new ida viewer based on ::place_t...
    bint custom_viewer_jump(TWidget* v, int& loc, uint32 flags)
    bint ea_viewer_history_push_and_jump(TWidget* v, ea_t ea, int x, int y, int lnnum)  # Push current location in the history and jump to the...
    bint get_ea_viewer_history_info(int* nback, int* nfwd, TWidget* v)  # Get information about what's in the history...
    void refresh_custom_viewer(TWidget* custom_viewer)  # Refresh custom ida viewer (::ui_refresh_custom_viewer)
    void repaint_custom_viewer(TWidget* custom_viewer)  # Repaint the given widget immediately (::ui_repaint_qwidget)
    void destroy_custom_viewer(TWidget* custom_viewer)  # Destroy custom ida viewer
    place_t* get_custom_viewer_place(TWidget* custom_viewer, bint mouse, int* x, int* y)  # Get current place in a custom viewer...
    bint get_custom_viewer_location(int* out, TWidget* custom_viewer, bint mouse)
    bint is_idaq()  # Are we running inside IDA Qt?
    bint attach_action_to_popup(TWidget* widget, TPopupMenu* popup_handle, char* name, char* popuppath, int flags)  # Insert a previously-registered action into the widget's...
    bint detach_action_from_popup(TWidget* widget, char* name)  # Remove a previously-registered action, from the list of...
    bint attach_dynamic_action_to_popup(TWidget* unused, TPopupMenu* popup_handle, action_desc_t& desc, char* popuppath, int flags, qstring* buf)  # Create & insert an action into the widget's popup menu...
    bint update_action_label(char* name, char* label)  # Update an action's label (::ui_update_action_attr). 
    bint update_action_shortcut(char* name, char* shortcut)  # Update an action's shortcut (::ui_update_action_attr). 
    bint update_action_tooltip(char* name, char* tooltip)  # Update an action's tooltip (::ui_update_action_attr). 
    bint update_action_icon(char* name, int icon)  # Update an action's icon (::ui_update_action_attr). 
    bint update_action_state(char* name, action_state_t state)  # Update an action's state (::ui_update_action_attr). 
    bint update_action_checkable(char* name, bint checkable)  # Update an action's checkability (::ui_update_action_attr). 
    bint update_action_checked(char* name, bint checked)  # Update an action's checked state (::ui_update_action_attr). 
    bint update_action_visibility(char* name, bint visible)  # Update an action's visibility (::ui_update_action_attr). 
    bint get_action_label(qstring* label, char* name)  # Get an action's label (::ui_get_action_attr). 
    bint get_action_shortcut(qstring* shortcut, char* name)  # Get an action's shortcut (::ui_get_action_attr). 
    bint get_action_tooltip(qstring* tooltip, char* name)  # Get an action's tooltip (::ui_get_action_attr). 
    bint get_action_icon(char* name, int* icon)  # Get an action's icon (::ui_get_action_attr). 
    bint get_action_state(char* name, action_state_t* state)  # Get an action's state (::ui_get_action_attr). 
    bint get_action_checkable(char* name, bint* checkable)  # Get an action's checkability (::ui_get_action_attr). 
    bint get_action_checked(char* name, bint* checked)  # Get an action's checked state (::ui_get_action_attr). 
    bint get_action_visibility(char* name, bint* visibility)  # Get an action's visibility (::ui_get_action_attr). 
    void set_custom_viewer_handlers(TWidget* custom_viewer, int* cvh, void* cvh_ud)  # Set handlers for custom viewer events Any of these...
    void* set_custom_viewer_handler(TWidget* custom_viewer, custom_viewer_handler_id_t handler_id, void* handler_or_data)  # Set a handler for a custom viewer event...
    bint set_custom_viewer_qt_aware(TWidget* custom_viewer)  # Allow the given viewer to interpret Qt events...
    char* get_custom_viewer_curline(TWidget* custom_viewer, bint mouse)  # Get current line of custom viewer...
    int get_custom_viewer_place_xcoord(TWidget* custom_viewer, place_t* pline, place_t* pitem)  # Get the X position of the item, in the line 
    bint get_user_input_event(input_event_t* out)  # Get the current user input event (mouse button press,...
    bint get_output_curline(qstring* buf, bint mouse)  # Get current line of output window (::ui_get_output_curline). 
    bint get_output_selected_text(qstring* buf)  # Returns selected text from output window...
    TWidget* get_current_viewer()  # Get current ida viewer (idaview or custom viewer)...
    TWidget* get_last_widget(uint64 mask)  # Get last ida viewer (idaview or custom viewer)...
    bint prompt_function_prototype(qstring* errbuf, tinfo_t* out_tif, func_t* pfn, tinfo_t* tif, char* name)  # Open function prototype editor to edit function type and...
    bint parse_tagged_line_sections(tagged_line_sections_t* out, char* line)  # Collect tagged sections in a color-tagged line (produced...
    tcc_renderer_type_t get_view_renderer_type(TWidget* v)  # Get the type of renderer currently in use in the given...
    void set_view_renderer_type(TWidget* v, tcc_renderer_type_t rt)  # Set the type of renderer to use in a view...
    void set_custom_viewer_range(TWidget* custom_viewer, place_t* minplace, place_t* maxplace)  # Set position range for custom viewer...
    TWidget* create_empty_widget(char* title, int icon)  # Create an empty widget, serving as a container for...
    void msg_clear()  # Clear the "Output" window
    bint msg_save(qstring& path)  # Save the "Output" window contents into a file 
    void msg_get_lines(qstrvec_t* out, int count)  # Retrieve the last 'count' lines from the output window,...
    TWidget* get_active_modal_widget()  # Get the current, active modal TWidget instance. Note...
    int get_navband_pixel(bint* out_is_vertical, ea_t ea)  # Translate the provided ea_t, into its pixel position...
    ea_t get_navband_ea(int pixel)  # Translate the pixel position on the navigation band,...
    void* get_window_id(char* name)  # Get the system-specific window ID (GUI version only) 
    bint is_idaview(TWidget* v)  # Is the given custom view an idaview? (::ui_is_idaview)
    bint read_selection(TWidget* v, twinpos_t* p1, twinpos_t* p2)  # Get the selected range boundaries (::ui_read_selection). 
    bint read_range_selection(TWidget* v, ea_t* ea1, ea_t* ea2)  # Get the address range for the selected range boundaries,...
    void unmark_selection()  # Unmark selection (::ui_unmarksel)
    TWidget* create_code_viewer(TWidget* custview, int flags, TWidget* parent)  # Create a code viewer (::ui_create_code_viewer). A code...
    void* set_code_viewer_handler(TWidget* code_viewer, custom_viewer_handler_id_t handler_id, void* handler_or_data)  # Set a handler for a code viewer event...
    bint set_code_viewer_user_data(TWidget* code_viewer, void* ud)  # Set the user data on a code viewer...
    void* get_viewer_user_data(TWidget* viewer)  # Get the user data from a custom viewer...
    tcc_place_type_t get_viewer_place_type(TWidget* viewer)  # Get the type of ::place_t instances a viewer uses &...
    void set_code_viewer_line_handlers(TWidget* code_viewer, int* click_handler, int* popup_handler, int* dblclick_handler, int* drawicon_handler, int* linenum_handler)  # Set handlers for code viewer line events. Any of these...
    bint set_code_viewer_lines_icon_margin(TWidget* code_viewer, int margin)  # Set space allowed for icons in the margin of a code...
    bint set_code_viewer_lines_alignment(TWidget* code_viewer, int align)  # Set alignment for lines in a code viewer...
    bint set_code_viewer_lines_radix(TWidget* code_viewer, int radix)  # Set radix for values displayed in a code viewer...
    bint set_code_viewer_is_source(TWidget* code_viewer)  # Specify that the given code viewer is used to display...
    int get_tab_size(char* path)  # Get the size of a tab in spaces (::ui_get_tab_size). 
    void clr_cancelled()  # Clear "Cancelled" flag (::ui_clr_cancelled)
    void set_cancelled()  # Set "Cancelled" flag (::ui_set_cancelled)
    bint user_cancelled()  # Test the cancellation flag (::ui_test_cancelled). 
    bint ui_load_new_file(qstring* temp_file, qstring* filename, linput_t** pli, ushort neflags, int** ploaders)  # Display a load file dialog and load file (::ui_load_file). 
    bint ui_run_debugger(char* dbgopts, char* exename, int argc, char** argv)  # Load a debugger plugin and run the specified program...
    bint load_dbg_dbginfo(char* path, linput_t* li, ea_t base, bint verbose)  # Load debugging information from a file. 
    int add_idc_hotkey(char* hotkey, char* idcfunc)  # Add hotkey for IDC function (::ui_add_idckey). 
    bint get_highlight(qstring* out_str, TWidget* viewer, uint32* out_flags, uint32 flags)  # Get the highlighted identifier in the viewer...
    bint set_highlight(TWidget* viewer, char* str, int flags)  # Set the highlighted identifier in the viewer...
    TWidget* open_exports_window(ea_t ea)  # Open the exports window (::ui_open_builtin). 
    TWidget* open_imports_window(ea_t ea)  # Open the exports window (::ui_open_builtin). 
    TWidget* open_names_window(ea_t ea)  # Open the names window (::ui_open_builtin). 
    TWidget* open_funcs_window(ea_t ea)  # Open the 'Functions' window (::ui_open_builtin). 
    TWidget* open_strings_window(ea_t ea, ea_t selstart, ea_t selend)  # Open the 'Strings' window (::ui_open_builtin). 
    TWidget* open_segments_window(ea_t ea)  # Open the segments window (::ui_open_builtin). 
    TWidget* open_segregs_window(ea_t ea)  # Open the segment registers window (::ui_open_builtin). 
    TWidget* open_selectors_window()  # Open the selectors window (::ui_open_builtin). 
    TWidget* open_signatures_window()  # Open the signatures window (::ui_open_builtin). 
    TWidget* open_tils_window()  # Open the type libraries window (::ui_open_builtin). 
    TWidget* open_loctypes_window(int ordinal, tif_cursor_t* cursor)  # Open the local types window (::ui_open_builtin2). 
    TWidget* open_til_view_window(tinfo_t* tif, tif_cursor_t* cursor)  # Open the sub-til window (::ui_open_builtin2). 
    TWidget* open_calls_window(ea_t ea)  # Open the function calls window (::ui_open_builtin). 
    TWidget* open_problems_window(ea_t ea)  # Open the problems window (::ui_open_builtin). 
    TWidget* open_bpts_window(ea_t ea)  # Open the breakpoints window (::ui_open_builtin). 
    TWidget* open_threads_window()  # Open the threads window (::ui_open_builtin). 
    TWidget* open_modules_window()  # Open the modules window (::ui_open_builtin). 
    TWidget* open_trace_window()  # Open the tracing window (::ui_open_builtin). 
    TWidget* open_stack_window()  # Open the call stack window (::ui_open_builtin). 
    TWidget* open_xrefs_window(ea_t ea)  # Open the cross references window (::ui_open_builtin). 
    TWidget* open_frame_window(func_t* pfn, uval_t offset)  # Open the frame window for the given function...
    TWidget* open_navband_window(ea_t ea, int zoom)  # Open the navigation band window (::ui_open_builtin). 
    TWidget* open_disasm_window(char* window_title, rangevec_t* ranges)  # Open a disassembly view (::ui_open_builtin). 
    TWidget* open_hexdump_window(char* window_title)  # Open a hexdump view (::ui_open_builtin). 
    TWidget* open_notepad_window()  # Open the notepad window (::ui_open_builtin). 
    TWidget* open_bookmarks_window(TWidget* w)  # Open the bookmarks window (::ui_open_builtin). 
    bint sync_sources(sync_source_t& what, sync_source_t& with_, bint sync)  # [Un]synchronize sources 
    char* choose_idasgn()  # Choose a signature (::ui_choose, ::chtype_idasgn). 
    bint choose_til(qstring* buf)  # Choose a type library (::ui_choose, ::chtype_idatil). 
    ea_t choose_entry(char* title)  # Choose an entry point (::ui_choose, ::chtype_entry). 
    ea_t choose_name(char* title)  # Choose a name (::ui_choose, ::chtype_name). 
    ea_t choose_stkvar_xref(func_t* pfn, tid_t srkvar_tid)  # Choose an xref to a stack variable (::ui_choose, ::chtype_name). 
    ea_t choose_xref(ea_t to)  # Choose an xref to an address (::ui_choose, ::chtype_xref). 
    bint choose_enum(tinfo_t* out, char* title, uint32 default_ord)  # Choose an enum (::ui_choose, ::chtype_enum). 
    bint choose_enum_by_value(tinfo_t* out, char* title, uint32 default_ord, uint64 value, int nbytes, uchar* serial)  # Choose an enum, restricted by value & size (::ui_choose,...
    func_t* choose_func(char* title, ea_t default_ea)  # Choose a function (::ui_choose, ::chtype_func). 
    segment_t* choose_segm(char* title, ea_t default_ea)  # Choose a segment (::ui_choose, ::chtype_segm). 
    bint choose_struct(tinfo_t* out, char* title)  # Choose a structure (::ui_choose, ::chtype_struct). 
    sreg_range_t* choose_srcp(char* title)  # Choose a segment register change point (::ui_choose,...
    void* get_chooser_obj(char* chooser_caption)  # Get the underlying object of the specified chooser...
    bint get_chooser_data(qstrvec_t* out, char* chooser_caption, int n)  # Get the text corresponding to the index N in the chooser...
    bint get_chooser_rows(chooser_row_info_vec_t* out, char* chooser_caption, size_t what)  # Get the chooser contents corresponding to the rows...
    bint enable_chooser_item_attrs(char* chooser_caption, bint enable)  # Enable item-specific attributes for chooser items...
    void show_wait_box(char* format)  # Display a dialog box with "Please wait...". The behavior...
    void hide_wait_box()  # Hide the "Please wait dialog box"
    void replace_wait_box(char* format)  # Replace the label of "Please wait dialog box"
    void beep(beep_t beep_type)  # Issue a beeping sound (::ui_beep). 
    bint display_copyright_warning()  # Display copyright warning (::ui_copywarn). 
    void ask_for_feedback(char* format)  # Show a message box asking to send the input file to...
    bint ask_addr(ea_t* addr, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_seg(sel_t* sel, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_long(sval_t* value, char* format)  # Display a dialog box and wait for the user to input an...
    void error(char* format)  # Display error dialog box and exit. If you just want to...
    ssize_t warning(char* format)
    ssize_t info(char* format)
    void nomem(char* format)
    int msg(char* format)
    int ask_yn(int deflt, char* format)  # Display a dialog box and get choice from "Yes", "No", "Cancel". 
    int ask_buttons(char* Yes, char* No, char* Cancel, int deflt, char* format)  # Display a dialog box and get choice from maximum three...
    bint ask_str(qstring* str, int hist, char* format)
    bint ask_ident(qstring* str, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_ident2(qstring* str, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_text(qstring* answer, size_t max_size, char* defval, char* format)
    char* ask_file(bint for_saving, char* defval, char* format)
    int register_addon(addon_info_t* info)  # Register an add-on. Show its info in the About box. For...
    int addon_count()  # Get number of installed addons
    bint get_addon_info(char* id, addon_info_t* info)  # Get info about a registered addon with a given product...
    bint get_addon_info_idx(int index, addon_info_t* info)  # Get info about a registered addon with specific index....
    char* add_spaces(char* str, size_t bufsize, ssize_t len)  # Add space characters to the colored string so that its...
    char* trim(char* str)  # Remove trailing space characters from a string. 
    char* skip_spaces(char* ptr)  # Skip whitespaces in the string. 
    ssize_t qcleanline(qstring* buf, char cmt_char, uint32 flags)  # Performs some cleanup operations to a line.  
    char* strarray(strarray_t* array, size_t array_size, int code)  # Find a line with the specified code in the ::strarray_t...
    size_t ea2str(char* buf, size_t bufsize, ea_t ea)  # Convert linear address to UTF-8 string
    bint str2ea(ea_t* out, char* str, ea_t screen_ea)  # Convert string to linear address. Tries to interpret the...
    bint str2ea_ex(ea_t* out, char* str, ea_t screen_ea, int flags)  # Same as str2ea() but possibly with some steps skipped. 
    bint atoea(ea_t* out, char* str)  # Convert a number in C notation to an address. decimal:...
    void get_user_strlist_options(int* out)
    bint del_idc_hotkey(char* hotkey)
    void ida_checkmem(char* file, int line)
    char xrefchar(char xrtype)  # Get character describing the xref type. 
    bint add_cref(ea_t from_, ea_t to, cref_t type)  # Create a code cross-reference. 
    bint del_cref(ea_t from_, ea_t to, bint expand)  # Delete a code cross-reference. 
    bint add_dref(ea_t from_, ea_t to, dref_t type)  # Create a data cross-reference. 
    void del_dref(ea_t from_, ea_t to)  # Delete a data cross-reference. 
    bint xrefblk_t_first_from(xrefblk_t*, ea_t from_, int flags)  #  Should not be called directly! @ {
    bint xrefblk_t_next_from(xrefblk_t*)
    bint xrefblk_t_first_to(xrefblk_t*, ea_t to, int flags)
    bint xrefblk_t_next_to(xrefblk_t*)
    ea_t get_first_dref_from(ea_t from_)  # ---------------------------------------------------------...
    ea_t get_next_dref_from(ea_t from_, ea_t current)  # Get next data referenced from the specified address. 
    ea_t get_first_dref_to(ea_t to)  # Get address of instruction/data referencing to the...
    ea_t get_next_dref_to(ea_t to, ea_t current)  # Get address of instruction/data referencing to the...
    ea_t get_first_cref_from(ea_t from_)  # Get first instruction referenced from the specified...
    ea_t get_next_cref_from(ea_t from_, ea_t current)  # Get next instruction referenced from the specified instruction. 
    ea_t get_first_cref_to(ea_t to)  # Get first instruction referencing to the specified...
    ea_t get_next_cref_to(ea_t to, ea_t current)  # Get next instruction referencing to the specified instruction. 
    ea_t get_first_fcref_from(ea_t from_)  #  The following functions are similar to...
    ea_t get_next_fcref_from(ea_t from_, ea_t current)
    ea_t get_first_fcref_to(ea_t to)
    ea_t get_next_fcref_to(ea_t to, ea_t current)
    bint has_external_refs(func_t* pfn, ea_t ea)  # Does 'ea' have references from outside of 'pfn'?
    bint has_jump_or_flow_xref(ea_t ea)  # Are there jump or flow references to EA?
    bint create_switch_table(ea_t insn_ea, switch_info_t& si)  # Create switch table from the switch information. Usually...
    void create_switch_xrefs(ea_t insn_ea, switch_info_t& si)  # Create code xrefs for the switch table. This function...
    bint calc_switch_cases(casevec_t* casevec, eavec_t* targets, ea_t insn_ea, switch_info_t& si)  # Get detailed information about the switch table cases. 
    void delete_switch_table(ea_t jump_ea, switch_info_t& si)  # Delete information created by the call of...
    bint create_xrefs_from(ea_t ea)
    void delete_all_xrefs_from(ea_t ea, bint expand)
    uint8 insn_get_next_byte(insn_t* insn)
    uint16 insn_get_next_word(insn_t* insn)
    uint32 insn_get_next_dword(insn_t* insn)
    uint64 insn_get_next_qword(insn_t* insn)
    bint insn_create_op_data(insn_t& insn, ea_t ea, int opoff, op_dtype_t dtype)
    void insn_add_cref(insn_t& insn, ea_t to, int opoff, cref_t type)
    void insn_add_dref(insn_t& insn, ea_t to, int opoff, dref_t type)
    ea_t insn_add_off_drefs(insn_t& insn, op_t& x, dref_t type, int outf)
    bint insn_create_stkvar(insn_t& insn, op_t& x, adiff_t v, int flags)
    size_t get_immvals(uval_t* out, ea_t ea, int n, flags64_t F, insn_t* cache)  # Get immediate values at the specified address. This...
    size_t get_printable_immvals(uval_t* out, ea_t ea, int n, flags64_t F, insn_t* cache)  # Get immediate ready-to-print values at the specified address 
    int get_lookback()  # Number of instructions to look back. This variable is...
    ea_t calc_dataseg(insn_t& insn, int n, int rgnum)  # Get data segment for the instruction operand. 'opnum'...
    ea_t map_data_ea(insn_t& insn, ea_t addr, int opnum)  # Map a data address. 
    ea_t map_code_ea(insn_t& insn, ea_t addr, int opnum)  # Map a code address. This function takes into account the...
    ea_t map_ea(insn_t& insn, op_t& op, bint iscode)
    outctx_base_t* create_outctx(ea_t ea, flags64_t F, int suspop)  # ---------------------------------------------------------...
    bint print_insn_mnem(qstring* out, ea_t ea)  # Print instruction mnemonics. 
    bint format_charlit(qstring* out, uchar** ptr, size_t size, uint32 flags, int encidx)  # Format character literal. Try and format 'size' bytes...
    bint print_fpval(char* buf, size_t bufsize, void* v, int size)  # Print a floating point value. 
    flags64_t get_dtype_flag(op_dtype_t dtype)  # ---------------------------------------------------------...
    size_t get_dtype_size(op_dtype_t dtype)  # Get size of opt_::dtype field
    op_dtype_t get_dtype_by_size(asize_t size)  # Get op_t::dtype from size
    bint is_floating_dtype(op_dtype_t dtype)  # Is a floating type operand?
    int create_insn(ea_t ea, insn_t* out)  # ---------------------------------------------------------...
    int decode_insn(insn_t* out, ea_t ea)  # Analyze the specified address and fill 'out'. This...
    bint can_decode(ea_t ea)  # Can the bytes at address 'ea' be decoded as instruction? 
    bint print_operand(qstring* out, ea_t ea, int n, int getn_flags, printop_t* newtype)  # Generate text representation for operand #n. This...
    ea_t decode_prev_insn(insn_t* out, ea_t ea)  # Decode previous instruction if it exists, fill 'out'. 
    ea_t decode_preceding_insn(insn_t* out, ea_t ea, bint* p_farref)  # Decode preceding instruction in the execution flow....
    bint construct_macro(macro_constructor_t* _this, insn_t* insn, bint enable)  # Do not directly call this function, use macro_constructor_t
    int get_spoiled_reg(insn_t& insn, uint32* regs, size_t n)  # Does the instruction spoil any register from 'regs'?....
    bint parse_config_value(idc_value_t* out, lexer_t* lx, token_t& value)
    char* cfgopt_t__apply(cfgopt_t* _this, int vtype, void* vdata)
    char* cfgopt_t__apply2(cfgopt_t* _this, int vtype, void* vdata, void* obj)
    char* cfgopt_t__apply3(cfgopt_t* _this, lexer_t* lx, int vtype, void* vdata, void* obj)
    bint get_config_value(jvalue_t* out, char* key)  # Get json value from ida.cfg 
    bint has_cf_chg(uint32 feature, uint opnum)  # Does an instruction with the specified feature modify...
    bint has_cf_use(uint32 feature, uint opnum)  # Does an instruction with the specified feature use a...
    bint has_insn_feature(uint16 icode, uint32 bit)  # Does the specified instruction have the specified feature?
    bint is_call_insn(insn_t& insn)  # Is the instruction a "call"?
    bint is_ret_insn(insn_t& insn, uchar flags)  # @ }
    bint is_indirect_jump_insn(insn_t& insn)  # Is the instruction an indirect jump?
    bint is_basic_block_end(insn_t& insn, bint call_insn_stops_block)  # Is the instruction the end of a basic block?
    bint hook_event_listener(hook_type_t hook_type, event_listener_t* cb, void* owner, int hkcb_flags)  # Install an event listener. The installed listener will...
    bint unhook_event_listener(hook_type_t hook_type, event_listener_t* cb)  # Uninstall an event listener. 
    void remove_event_listener(event_listener_t* cb)  # remove all hooks in all databases for specified...
    processor_t* get_ph()  # The following two structures contain information about...
    asm_t* get_ash()
    ea_helper_t* get_eah()
    int str2reg(char* p)
    int is_align_insn(ea_t ea)  # If the instruction at 'ea' looks like an alignment...
    ssize_t get_reg_name(qstring* buf, int reg, size_t width, int reghi)  # Get text representation of a register. For most...
    bint parse_reg_name(reg_info_t* ri, char* regname)  # Get register info by name. 
    bint set_processor_type(char* procname, setproc_level_t level)  # Set target processor type. Once a processor module is...
    char* get_idp_name(char* buf, size_t bufsize)  # Get name of the current processor module. The name is...
    bint set_target_assembler(int asmnum)  # Set target assembler. 
    void* set_module_data(int* data_id, void* data_ptr)  # Register pointer to database specific module data. 
    void* clr_module_data(int data_id)  # Unregister pointer to database specific module data. 
    void* get_module_data(int data_id)  # Get pointer to the database specific module data. 
    void gen_gdl(gdl_graph_t* g, char* fname)  # Create GDL file for graph
    int display_gdl(char* fname)  # Display GDL file by calling wingraph32. The exact name...
    bint gen_flow_graph(char* filename, char* title, func_t* pfn, ea_t ea1, ea_t ea2, int gflags)  # Build and display a flow graph. 
    bint gen_simple_call_chart(char* filename, char* wait, char* title, int gflags)  # Build and display a simple function call graph. 
    bint gen_complex_call_chart(char* filename, char* wait, char* title, ea_t ea1, ea_t ea2, int flags, int32 recursion_depth)  # Build and display a complex xref graph. 
    bint is_noret_block(fc_block_type_t btype)  # Does this block never return?
    bint is_ret_block(fc_block_type_t btype)  # Does this block return?
    void loader_failure(char* format)  # Display a message about a loader failure and stop the...
    load_info_t* build_loaders_list(linput_t* li, char* filename)  # Build list of potential loaders
    void free_loaders_list(load_info_t* list)  # Free the list of loaders
    char* get_loader_name_from_dll(char* dllname)  # Get name of loader from its DLL file (for example, for...
    ssize_t get_loader_name(char* buf, size_t bufsize)  # Get name of loader used to load the input file into the...
    bint load_binary_file(char* filename, linput_t* li, ushort _neflags, int fileoff, ea_t basepara, ea_t binoff, uint64 nbytes)  # Load a binary file into the database. This function...
    bint load_nonbinary_file(char* filename, linput_t* li, char* sysdlldir, ushort _neflags, load_info_t* loader)  # Load a non-binary file into the database. This function...
    int process_archive(qstring* temp_file, linput_t* li, qstring* module_name, ushort* neflags, char* defmember, load_info_t* loader, qstring* errbuf)  # Calls loader_t::process_archive() For parameters and...
    int gen_file(ofile_type_t otype, FILE* fp, ea_t ea1, ea_t ea2, int flags)  # ---------------------------------------------------------...
    int file2base(linput_t* li, int pos, ea_t ea1, ea_t ea2, int patchable)  # Load portion of file into the database. This function...
    int mem2base(void* memptr, ea_t ea1, ea_t ea2, int fpos)  # Load database from the memory. This function works for...
    int base2file(FILE* fp, int pos, ea_t ea1, ea_t ea2)  # Unload database to a binary file. This function works...
    bint extract_module_from_archive(char* filename, size_t bufsize, char** temp_file_ptr, bint is_remote)  # Extract a module for an archive file. Parse an archive...
    void create_filename_cmt()  # Add long comment at - Input file:     .... - File...
    filetype_t get_basic_file_type(linput_t* li)  # Get the input file type. This function can recognize...
    size_t get_file_type_name(char* buf, size_t bufsize)  # Get name of the current file type. The current file type...
    void set_import_ordinal(uval_t modnode, ea_t ea, uval_t ord)  # Set information about the ordinal import entry. This...
    void set_import_name(uval_t modnode, ea_t ea, char* name)  # Set information about the named import entry. This...
    int load_ids_module(char* fname)  # Load and apply IDS file. This function loads the...
    char* get_plugin_options(char* plugin)  # Get plugin options from the command line. If the user...
    int _load_core_module(idadll_t* dllmem, char* file, char* entry)
    void load_core_module_or_die(idadll_t* dllmem, char* file, char* entry)
    bint load_core_module(idadll_t* dllmem, char* file, char* entry)
    void free_dll(idadll_t* dllmem)
    idp_descs_t* get_idp_descs()  # Get IDA processor modules descriptions
    plugin_info_t* get_plugins()  # Get pointer to the list of plugins. (some plugins might...
    plugin_t* find_plugin(char* name, bint load_if_needed)  # Find a user-defined plugin and optionally load it. 
    plugin_t* load_plugin(char* name)
    bint run_plugin(plugin_t* ptr, size_t arg)  # Run a loaded plugin with the specified argument. 
    bint load_and_run_plugin(char* name, size_t arg)  # Load & run a plugin
    bint invoke_plugin(plugin_info_t* ptr)  # Run a plugin as configured. 
    size_t get_debugger_plugins(dbg_info_t** array)  # Get information about available debuggers
    void init_plugins(int flag)  # Initialize plugins with the specified flag
    void term_plugins(int flag)  # Terminate plugins with the specified flag
    int get_fileregion_offset(ea_t ea)  # Get offset in the input file which corresponds to the...
    ea_t get_fileregion_ea(int offset)  # Get linear address which corresponds to the specified...
    int gen_exe_file(FILE* fp)  # ---------------------------------------------------------...
    bint reload_file(char* file, bint is_remote)  # ---------------------------------------------------------...
    bint build_snapshot_tree(snapshot_t* root)  # ---------------------------------------------------------...
    bint update_snapshot_attributes(char* filename, snapshot_t* root, snapshot_t* attr, int uf)  # ---------------------------------------------------------...
    int flush_buffers()  # Flush buffers to the disk
    bint is_trusted_idb()  # Is the database considered as trusted?
    bint save_database(char* outfile, uint32 flags, snapshot_t* root, snapshot_t* attr)  # ---------------------------------------------------------...
    bint is_database_flag(uint32 dbfl)  # Get the current database flag 
    void set_database_flag(uint32 dbfl, bint cnd)  # Set or clear database flag 
    void clr_database_flag(uint32 dbfl)
    bint is_temp_database()  # Is a temporary database?
    char* get_path(path_type_t pt)  # Get the file path 
    void set_path(path_type_t pt, char* path)  # Set the file path 
    bint is_database_ext(char* ext)  # Check the file extension 
    char* get_elf_debug_file_directory()  # Get the value of the ELF_DEBUG_FILE_DIRECTORY...
    bint set_name(ea_t ea, char* name, int flags)  # Set or delete name of an item at the specified address....
    bint force_name(ea_t ea, char* name, int flags)  # @ }
    bint del_global_name(ea_t ea)  #  
    bint del_local_name(ea_t ea)
    bint set_dummy_name(ea_t from_, ea_t ea)  # Give an autogenerated (dummy) name. Autogenerated names...
    bint make_name_auto(ea_t ea)  #  This bit affects value of has_user_name(),...
    bint make_name_user(ea_t ea)
    bint validate_name(qstring* name, nametype_t type, int flags)  # Validate a name. If SN_NOCHECK is specified, this...
    bint is_valid_cp(wchar32_t cp, nametype_t kind, void* data)  # Is the given codepoint acceptable in the given context?
    void set_cp_validity(ucdr_kind_t kind, wchar32_t cp, wchar32_t endcp, bint valid)  # Mark the given codepoint (or range) as acceptable or...
    bint get_cp_validity(ucdr_kind_t kind, wchar32_t cp, wchar32_t endcp)  # Is the given codepoint (or range) acceptable in the...
    bint is_ident_cp(wchar32_t cp)  # Can a character appear in a name? (present in...
    bint is_strlit_cp(wchar32_t cp, rangeset_crefvec_t* specific_ranges)  # Can a character appear in a string literal (present in...
    bint is_visible_cp(wchar32_t cp)  # Can a character be displayed in a name? (present in ::NameChars)
    bint is_ident(char* name)  # Is a valid name? (including ::MangleChars)
    bint is_uname(char* name)  # Is valid user-specified name? (valid name & !dummy prefix). 
    bint is_valid_typename(char* name)  # Is valid type name? 
    ea_t dummy_name_ea(char* name)  # Is dummy name? 
    ssize_t extract_name(qstring* out, char* line, int x)  # Extract a name or address from the specified string. 
    void hide_name(ea_t ea)  # Remove name from the list of names 
    void show_name(ea_t ea)  # Insert name to the list of names
    ea_t get_name_ea(ea_t from_, char* name)  # Get the address of a name. This function resolves a name...
    ea_t get_name_base_ea(ea_t from_, ea_t to)  # Get address of the name used in the expression for the address 
    int get_name_value(uval_t* value, ea_t from_, char* name)  # Get value of the name. This function knows about:...
    ssize_t get_ea_name(qstring* out, ea_t ea, int gtn_flags, getname_info_t* gtni)  # Get name at the specified address. 
    ssize_t get_name(qstring* out, ea_t ea, int gtn_flags)  # Convenience functions for get_ea_name returning ssize_t
    ssize_t get_visible_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_colored_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_short_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_long_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_colored_short_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_colored_long_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_demangled_name(qstring* out, ea_t ea, int32 inhibitor, int demform, int gtn_flags)
    ssize_t get_colored_demangled_name(qstring* out, ea_t ea, int32 inhibitor, int demform, int gtn_flags)
    int calc_gtn_flags(ea_t from_, ea_t ea)
    color_t get_name_color(ea_t from_, ea_t ea)  # Get name color. 
    ssize_t get_name_expr(qstring* out, ea_t from_, int n, ea_t ea, uval_t off, int flags)  # Convert address to name expression (name with a...
    ssize_t get_nice_colored_name(qstring* buf, ea_t ea, int flags)  # Get a nice colored name at the specified address. Ex: -...
    flags64_t append_struct_fields(qstring* out, adiff_t* disp, int n, tid_t* path, int plen, flags64_t flags, adiff_t delta, bint appzero)  # Append names of struct fields to a name if the name is a...
    int get_struct_operand(adiff_t* disp, adiff_t* delta, tid_t* path, ea_t ea, int n)  # Get offset within a structure if the operand refers to...
    bint is_public_name(ea_t ea)  #  @ {
    void make_name_public(ea_t ea)
    void make_name_non_public(ea_t ea)
    bint is_weak_name(ea_t ea)  #  @ {
    void make_name_weak(ea_t ea)
    void make_name_non_weak(ea_t ea)
    size_t get_nlist_size()  # Get number of names in the list
    size_t get_nlist_idx(ea_t ea)  # Get index of the name in the list 
    bint is_in_nlist(ea_t ea)  # Is the name included into the name list?
    ea_t get_nlist_ea(size_t idx)  # Get address from the list at 'idx'
    char* get_nlist_name(size_t idx)  # Get name using idx
    void rebuild_nlist()  # Rebuild the name list
    void reorder_dummy_names()  # Renumber dummy names
    int set_debug_names(ea_t* addrs, char** names, int qty)  #  Debug names exist during the debugging session. The...
    bint set_debug_name(ea_t ea, char* name)
    ssize_t get_debug_name(qstring* out, ea_t* ea_ptr, debug_name_how_t how)
    void del_debug_names(ea_t ea1, ea_t ea2)
    ea_t get_debug_name_ea(char* name)
    void get_debug_names(ea_name_vec_t* names, ea_t ea1, ea_t ea2)
    int32 demangle_name(qstring* out, char* name, uint32 disable_mask, demreq_type_t demreq)  # Demangle a name. 
    int32 detect_compiler_using_demangler(char* name)
    bint is_name_defined_locally(func_t* pfn, char* name, ignore_name_def_t ignore_name_def, ea_t ea1, ea_t ea2)  # Is the name defined locally in the specified function? 
    bint cleanup_name(qstring* out, ea_t ea, char* name, uint32 flags)  # Clean a name. This function removes punctuation marks...
    bint is_type_const(type_t t)  # ---------------------------------------------------------...
    bint is_type_volatile(type_t t)
    type_t get_base_type(type_t t)
    type_t get_type_flags(type_t t)
    type_t get_full_type(type_t t)
    bint is_typeid_last(type_t t)  # Is the type_t the last byte of type declaration? (there...
    bint is_type_partial(type_t t)  # Identifies an unknown or void type with a known size (see
    bint is_type_void(type_t t)
    bint is_type_unknown(type_t t)
    bint is_type_ptr(type_t t)
    bint is_type_complex(type_t t)
    bint is_type_func(type_t t)
    bint is_type_array(type_t t)
    bint is_type_typedef(type_t t)
    bint is_type_sue(type_t t)
    bint is_type_struct(type_t t)
    bint is_type_union(type_t t)
    bint is_type_struni(type_t t)
    bint is_type_enum(type_t t)
    bint is_type_bitfld(type_t t)
    bint is_type_int(type_t bt)  # Does the type_t specify one of the basic types in
    bint is_type_int128(type_t t)  # Does the type specify a 128-bit value? (signed or unsigned, see
    bint is_type_int64(type_t t)  # Does the type specify a 64-bit value? (signed or unsigned, see
    bint is_type_int32(type_t t)  # Does the type specify a 32-bit value? (signed or unsigned, see
    bint is_type_int16(type_t t)  # Does the type specify a 16-bit value? (signed or unsigned, see
    bint is_type_char(type_t t)  # Does the type specify a char value? (signed or unsigned, see
    bint is_type_paf(type_t t)  # Is the type a pointer, array, or function type?
    bint is_type_ptr_or_array(type_t t)  # Is the type a pointer or array type?
    bint is_type_floating(type_t t)  # Is the type a floating point type?
    bint is_type_integral(type_t t)  # Is the type an integral type (char/short/int/long/bool)?
    bint is_type_ext_integral(type_t t)  # Is the type an extended integral type? (integral or enum)
    bint is_type_arithmetic(type_t t)  # Is the type an arithmetic type? (floating or integral)
    bint is_type_ext_arithmetic(type_t t)  # Is the type an extended arithmetic type? (arithmetic or enum)
    bint is_type_uint(type_t t)
    bint is_type_uchar(type_t t)
    bint is_type_uint16(type_t t)
    bint is_type_uint32(type_t t)
    bint is_type_uint64(type_t t)
    bint is_type_uint128(type_t t)
    bint is_type_ldouble(type_t t)
    bint is_type_double(type_t t)
    bint is_type_float(type_t t)
    bint is_type_tbyte(type_t t)
    bint is_type_bool(type_t t)
    bint is_tah_byte(type_t t)  # The TAH byte (type attribute header byte) denotes the...
    bint is_sdacl_byte(type_t t)  # Identify an sdacl byte. The first sdacl byte has the...
    bint append_argloc(qtype* out, argloc_t& vloc)  # ---------------------------------------------------------...
    bint extract_argloc(argloc_t* vloc, type_t** ptype, bint forbid_stkoff)  # Deserialize an argument location. Argument FORBID_STKOFF...
    type_t* resolve_typedef(til_t* til, type_t* type)
    bint is_restype_void(til_t* til, type_t* type)  # low level functions to be used in...
    bint is_restype_enum(til_t* til, type_t* type)
    bint is_restype_struni(til_t* til, type_t* type)
    bint is_restype_struct(til_t* til, type_t* type)
    type_t get_scalar_bt(int size)  # Get a base type for the specified size. This function...
    til_t* new_til(char* name, char* desc)  # Initialize a til
    int add_base_tils(qstring* errbuf, til_t* ti, char* tildir, char* bases, bint gen_events)  # Add multiple base tils. 
    til_t* load_til(char* name, qstring* errbuf, char* tildir)  # Load til from a file without adding it to the database...
    bint sort_til(til_t* ti)  # Sort til (use after modifying it). 
    bint compact_til(til_t* ti)  # Collect garbage in til. Must be called before storing the til. 
    bint store_til(til_t* ti, char* tildir, char* name)  # Store til to a file. If the til contains garbage, it...
    void free_til(til_t* ti)  # Free memory allocated by til
    til_t* load_til_header(char* tildir, char* name, qstring* errbuf)  # Get human-readable til description
    bint is_code_far(cm_t cm)  # Does the given model specify far code?.
    bint is_data_far(cm_t cm)  # Does the given model specify far data?.
    int install_custom_argloc(custloc_desc_t* custloc)  # Save a custom argloc
    bint remove_custom_argloc(int idx)  # Delete the custom argloc at the given index
    custloc_desc_t* retrieve_custom_argloc(int idx)  # Retrieve the custom argloc at the given index
    int verify_argloc(argloc_t& vloc, int size, rangeset_t* gaps)  # Verify argloc_t. 
    bint optimize_argloc(argloc_t* vloc, int size, rangeset_t* gaps)  # Verify and optimize scattered argloc into simple form....
    size_t print_argloc(char* buf, size_t bufsize, argloc_t& vloc, int size, int vflags)  # Convert an argloc to human readable form
    int for_all_arglocs(aloc_visitor_t& vv, argloc_t& vloc, int size, int off)  # Compress larger argloc types and initiate the aloc visitor
    int for_all_const_arglocs(const_aloc_visitor_t& vv, argloc_t& vloc, int size, int off)  # See for_all_arglocs()
    callcnv_t helper_get_cc(cm_t cm, callcnv_t new_callcnv)  # Helper functions that maintain binary compatibility with...
    void helper_set_cc(cm_t* cm, callcnv_t* new_callcnv, callcnv_t cc)
    callcnv_t get_effective_cc(callcnv_t cc)  # Get effective calling convention (with respect to default CC)
    bint is_user_cc(callcnv_t cc)  # Does the calling convention specify argument locations...
    bint is_vararg_cc(callcnv_t cc)  # Does the calling convention use ellipsis?
    bint is_purging_cc(callcnv_t cc)  # Does the calling convention clean the stack arguments...
    bint is_golang_cc(callcnv_t cc)  # GO language calling convention (return value in stack)?
    bint is_custom_callcnv(callcnv_t cc)  # Is custom calling convention?
    bint is_swift_cc(callcnv_t cc)  # Swift calling convention (arguments and return values in...
    bint get_stkarg_area_info(stkarg_area_info_t* out, callcnv_t cc)  # ---------------------------------------------------------...
    callcnv_t register_custom_callcnv(custom_callcnv_t& ccinf)  # Register a calling convention 
    bint unregister_custom_callcnv(callcnv_t callcnv)  # Unregister a calling convention 
    custom_callcnv_t* get_custom_callcnv(callcnv_t callcnv)  # Retrieve custom calling convention details
    callcnv_t find_custom_callcnv(char* name)  # Find a calling convention by its name 
    size_t get_custom_callcnvs(qstrvec_t* names, callcnvs_t* codes)  # Get all custom calling conventions 
    comp_t get_comp(comp_t comp)  # Get compiler bits
    char* get_compiler_name(comp_t id)  # Get full compiler name
    char* get_compiler_abbr(comp_t id)  # Get abbreviated compiler name
    void get_compilers(compvec_t* ids, qstrvec_t* names, qstrvec_t* abbrs)  # Get names of all built-in compilers
    comp_t is_comp_unsure(comp_t comp)  # See ::COMP_UNSURE
    comp_t default_compiler()  # Get compiler specified by {inf,idainfo,cc}
    bint is_gcc()  # Is the target compiler ::COMP_GNU?
    bint is_gcc32()  # Is the target compiler 32 bit gcc?
    bint is_gcc64()  # Is the target compiler 64 bit gcc?
    bint gcc_layout()  # Should use the struct/union layout as done by gcc?
    bint set_compiler(compiler_info_t& cc, int flags, char* abiname)  # Change current compiler. 
    bint set_compiler_id(comp_t id, char* abiname)  # Set the compiler id (see
    bint set_abi_name(char* abiname, bint user_level)  # Set abi name (see
    ssize_t get_abi_name(qstring* out)  # Get ABI name. 
    bint append_abi_opts(char* abi_opts, bint user_level)  # Add/remove/check ABI option General form of full abi...
    bint remove_abi_opts(char* abi_opts, bint user_level)
    bint set_compiler_string(char* compstr, bint user_level)
    bint use_golang_cc()  # is GOLANG calling convention used by default?
    void switch_to_golang()  # switch to GOLANG calling convention (to be used as default CC)
    int convert_pt_flags_to_hti(int pt_flags)  # Convert to Type parsing flags lesser than 0x10 don't...
    bint parse_decl(tinfo_t* out_tif, qstring* out_name, til_t* til, char* decl, int pt_flags)  # Parse ONE declaration. If the input string contains more...
    bint print_type(qstring* out, ea_t ea, int prtype_flags)  # Get type declaration for the specified address. 
    int get_named_type(til_t* ti, char* name, int ntf_flags, type_t** type, p_list** fields, char** cmt, p_list** fieldcmts, sclass_t* sclass, uint32* value)  # Get named typeinfo. The returned pointers are pointers...
    int get_named_type64(til_t* ti, char* name, int ntf_flags, type_t** type, p_list** fields, char** cmt, p_list** fieldcmts, sclass_t* sclass, uint64* value)  # See get_named_type() above. 
    char* tinfo_errstr(tinfo_code_t code)  # Helper function to convert an error code into a...
    bint del_named_type(til_t* ti, char* name, int ntf_flags)  # Delete information about a symbol. 
    char* first_named_type(til_t* ti, int ntf_flags)  # Enumerate types. 
    char* next_named_type(til_t* ti, char* name, int ntf_flags)  #  
    uint32 copy_named_type(til_t* dsttil, til_t* srctil, char* name)  # Copy a named type from one til to another. This function...
    bint decorate_name(qstring* out, char* name, bint should_decorate, callcnv_t cc, tinfo_t* type)  # Decorate/undecorate a C symbol name. 
    bint gen_decorate_name(qstring* out, char* name, bint should_decorate, callcnv_t cc, tinfo_t* type)  # Generic function for decorate_name() (may be used in IDP modules)
    ssize_t calc_c_cpp_name(qstring* out, char* name, tinfo_t* type, int ccn_flags)  # Get C or C++ form of the name. 
    bint enable_numbered_types(til_t* ti, bint enable)  # Enable the use of numbered types in til. Currently it is...
    bint get_numbered_type(til_t* ti, uint32 ordinal, type_t** type, p_list** fields, char** cmt, p_list** fieldcmts, sclass_t* sclass)  # Retrieve a type by its ordinal number
    uint32 alloc_type_ordinals(til_t* ti, int qty)  # Allocate a range of ordinal numbers for new types. 
    uint32 alloc_type_ordinal(til_t* ti)  #  {alloc_type_ordinals,ti,1}
    uint32 get_ordinal_limit(til_t* ti)  # Get number of allocated ordinals + 1. If there are no...
    uint32 get_ordinal_count(til_t* ti)  # Get number of allocated ordinals. 
    bint del_numbered_type(til_t* ti, uint32 ordinal)  # Delete a numbered type
    bint set_type_alias(til_t* ti, uint32 src_ordinal, uint32 dst_ordinal)  # Create a type alias. Redirects all references to source...
    uint32 get_alias_target(til_t* ti, uint32 ordinal)  # Find the final alias destination. If the ordinal has not...
    int32 get_type_ordinal(til_t* ti, char* name)  # Get type ordinal by its name
    char* get_numbered_type_name(til_t* ti, uint32 ordinal)  # Get type name (if exists) by its ordinal. If the type is...
    ssize_t create_numbered_type_name(qstring* buf, int32 ord)  # Create anonymous name for numbered type. This name can...
    bint is_ordinal_name(char* name, uint32* ord)  # Check if the name is an ordinal name. Ordinal names have...
    void build_anon_type_name(qstring* buf, type_t* type, p_list* fields)  # Generate a name like $hex_numbers based on the field...
    int compact_numbered_types(til_t* ti, uint32 min_ord, intvec_t* p_ordmap, int flags)  # Compact numbered types to get rid of empty slots. 
    bint is_type_choosable(til_t* ti, uint32 ordinal)  # Check if a struct/union type is choosable 
    void set_type_choosable(til_t* ti, uint32 ordinal, bint value)  # Enable/disable 'choosability' flag for a struct/union type 
    ea_t get_vftable_ea(uint32 ordinal)  # Get address of a virtual function table. 
    uint32 get_vftable_ordinal(ea_t vftable_ea)  # Get ordinal number of the virtual function table. 
    bint set_vftable_ea(uint32 ordinal, ea_t vftable_ea)  # Set the address of a vftable instance for a vftable type. 
    bint del_vftable_ea(uint32 ordinal)  # Delete the address of a vftable instance for a vftable type. 
    size_t get_default_align()  # Get default alignment for structure fields. 
    void align_size(size_t& cur_tot_size, size_t elem_size, size_t algn)  # Get alignment delta for the a structure field. 
    bint deref_ptr(ea_t* ptr_ea, tinfo_t& tif, ea_t* closure_obj)  # Dereference a pointer. 
    bint remove_tinfo_pointer(tinfo_t* tif, char** pname, til_t* til)  # Remove pointer of a type. (i.e. convert "char *" into...
    int add_til(char* name, int flags)  # Load a til file and add it the database type libraries...
    bint del_til(char* name)  # Unload a til file
    bint apply_named_type(ea_t ea, char* name)  # Apply the specified named type to the address. 
    bint apply_tinfo(ea_t ea, tinfo_t& tif, uint32 flags)  # Apply the specified type to the specified address. This...
    bint apply_cdecl(til_t* til, ea_t ea, char* decl, int flags)  # Apply the specified type to the address. This function...
    bint apply_callee_tinfo(ea_t caller, tinfo_t& tif)  # Apply the type of the called function to the calling...
    bint get_arg_addrs(eavec_t* out, ea_t caller)  # Retrieve argument initialization addresses. This...
    bint apply_once_tinfo_and_name(ea_t dea, tinfo_t& tif, char* name)  # Apply the specified type and name to the address. This...
    int guess_tinfo(tinfo_t* out, tid_t id)  # Generate a type information about the id from the...
    void set_c_header_path(char* incdir)  # Set include directory path the target compiler
    ssize_t get_c_header_path(qstring* buf)  # Get the include directory path of the target compiler
    void set_c_macros(char* macros)  # Set predefined macros for the target compiler
    ssize_t get_c_macros(qstring* buf)  # Get predefined macros for the target compiler
    til_t* get_idati()  # Pointer to the local type library - this til is private...
    bint get_idainfo_by_type(size_t* out_size, flags64_t* out_flags, opinfo_t* out_mt, tinfo_t& tif, size_t* out_alsize)  # Extract information from a tinfo_t. 
    bint get_tinfo_by_flags(tinfo_t* out, flags64_t flags)  # Get tinfo object that corresponds to data flags 
    void copy_tinfo_t(tinfo_t* _this, tinfo_t& r)
    bint detach_tinfo_t(tinfo_t* _this)
    void clear_tinfo_t(tinfo_t* _this)
    bint create_tinfo(tinfo_t* _this, type_t bt, type_t bt2, void* ptr)
    int verify_tinfo(typid_t typid)
    bint get_tinfo_details(typid_t typid, type_t bt2, void* buf)
    size_t get_tinfo_size(uint32* p_effalign, typid_t typid, int gts_code)
    size_t get_tinfo_pdata(void* outptr, typid_t typid, int what)
    size_t get_tinfo_property(typid_t typid, int gta_prop)
    size_t get_tinfo_property4(typid_t typid, int gta_prop, size_t p1, size_t p2, size_t p3, size_t p4)
    size_t set_tinfo_property(tinfo_t* tif, int sta_prop, size_t x)
    size_t set_tinfo_property4(tinfo_t* tif, int sta_prop, size_t p1, size_t p2, size_t p3, size_t p4)
    bint serialize_tinfo(qtype* type, qtype* fields, qtype* fldcmts, tinfo_t* tif, int sudt_flags)
    bint deserialize_tinfo(tinfo_t* tif, til_t* til, type_t** ptype, p_list** pfields, p_list** pfldcmts, char* cmt)
    int find_tinfo_udt_member(udm_t* udm, typid_t typid, int strmem_flags)
    bint print_tinfo(qstring* result, char* prefix, int indent, int cmtindent, int flags, tinfo_t* tif, char* name, char* cmt)
    char* dstr_tinfo(tinfo_t* tif)
    int visit_subtypes(tinfo_visitor_t* visitor, type_mods_t* out, tinfo_t& tif, char* name, char* cmt)
    bint compare_tinfo(typid_t t1, typid_t t2, int tcflags)
    int lexcompare_tinfo(typid_t t1, typid_t t2, int)
    bint get_stock_tinfo(tinfo_t* tif, stock_type_id_t id)
    uint64 read_tinfo_bitfield_value(typid_t typid, uint64 v, int bitoff)
    uint64 write_tinfo_bitfield_value(typid_t typid, uint64 dst, uint64 v, int bitoff)
    bint get_tinfo_attr(typid_t typid, qstring& key, bytevec_t* bv, bint all_attrs)
    bint set_tinfo_attr(tinfo_t* tif, type_attr_t& ta, bint may_overwrite)
    bint del_tinfo_attr(tinfo_t* tif, qstring& key, bint make_copy)
    bint get_tinfo_attrs(typid_t typid, type_attrs_t* tav, bint include_ref_attrs)
    bint set_tinfo_attrs(tinfo_t* tif, type_attrs_t* ta)
    uint32 score_tinfo(tinfo_t* tif)
    tinfo_code_t save_tinfo(tinfo_t* tif, til_t* til, size_t ord, char* name, int ntf_flags)
    bint append_tinfo_covered(rangeset_t* out, typid_t typid, uint64 offset)
    bint calc_tinfo_gaps(rangeset_t* out, typid_t typid)
    bint name_requires_qualifier(qstring* out, typid_t typid, char* name, uint64 offset)
    bint value_repr_t__from_opinfo(value_repr_t* _this, flags64_t flags, aflags_t afl, opinfo_t* opinfo, array_parameters_t* ap)
    size_t value_repr_t__print_(value_repr_t* _this, qstring* result, bint colored)
    bint value_repr_t__parse_value_repr(value_repr_t* _this, qstring& attr, type_t target_type)
    ssize_t udt_type_data_t__find_member(udt_type_data_t* _this, udm_t* udm, int strmem_flags)
    ssize_t udt_type_data_t__get_best_fit_member(udt_type_data_t* _this, asize_t disp)
    uchar enum_type_data_t__get_max_serial(enum_type_data_t* ei, uint64 value)
    tinfo_code_t enum_type_data_t__set_value_repr(enum_type_data_t* ei, value_repr_t& repr)
    tinfo_code_t enum_type_data_t__get_value_repr(enum_type_data_t* ei, value_repr_t* repr)
    void tinfo_get_innermost_udm(tinfo_t* itif, tinfo_t* tif, uint64 offset, size_t* udm_idx, uint64* bit_offset, bint return_member_type)
    ssize_t get_udm_by_tid(tinfo_t* tif, udm_t* udm, tid_t tid)
    ssize_t get_edm_by_tid(tinfo_t* tif, edm_t* edm, tid_t tid)
    bint get_type_by_tid(tinfo_t* tif, tid_t tid)
    tid_t get_tinfo_tid(tinfo_t* tif, bint force_tid)
    ssize_t get_tinfo_by_edm_name(tinfo_t* tif, til_t* til, char* mname)
    ssize_t get_frame_var(tinfo_t* tif, sval_t* actval, insn_t& insn, op_t* x, sval_t v)
    bint tinfo_get_func_frame(tinfo_t* tif, func_t* pfn)
    callcnv_t guess_func_cc(func_type_data_t& fti, int npurged, int cc_flags)  # ---------------------------------------------------------...
    bint dump_func_type_data(qstring* out, func_type_data_t& fti, int praloc_bits)  # Use func_type_data_t::dump()
    bint calc_retloc(func_type_data_t* fti)
    bint calc_arglocs(func_type_data_t* fti)
    bint calc_varglocs(func_type_data_t* fti, regobjs_t* regs, relobj_t* stkargs, int nfixed)
    bint stroff_as_size(int plen, tinfo_t& tif, asize_t value)  # ---------------------------------------------------------...
    int visit_stroff_udms(udm_visitor_t& sfv, tid_t* path, int plen, adiff_t* disp, bint appzero)  # ---------------------------------------------------------...
    bint is_one_bit_mask(uval_t mask)  # ---------------------------------------------------------...
    int get_arg_align(int type_align, int slotsize, callcnv_t cc)  # ---------------------------------------------------------...
    sval_t align_stkarg_up(sval_t spoff, int type_align, int slotsize, callcnv_t cc)  # ---------------------------------------------------------...
    tinfo_t remove_pointer(tinfo_t& tif)  # ::BT_PTR: If the current type is a pointer, return the...
    error_t unpack_idcobj_from_idb(idc_value_t* obj, tinfo_t& tif, ea_t ea, bytevec_t* off0, int pio_flags)  # Read a typed idc object from the database
    error_t unpack_idcobj_from_bv(idc_value_t* obj, tinfo_t& tif, bytevec_t& bytes, int pio_flags)  # Read a typed idc object from the byte vector
    error_t pack_idcobj_to_idb(idc_value_t* obj, tinfo_t& tif, ea_t ea, int pio_flags)  # Write a typed idc object to the database
    error_t pack_idcobj_to_bv(idc_value_t* obj, tinfo_t& tif, relobj_t* bytes, void* objoff, int pio_flags)  # Write a typed idc object to the byte vector. Byte vector...
    bint apply_tinfo_to_stkarg(insn_t& insn, op_t& x, uval_t v, tinfo_t& tif, char* name)  # Helper function for the processor modules. to be called from
    void gen_use_arg_tinfos(argtinfo_helper_t* _this, ea_t caller, func_type_data_t* fti, funcargvec_t* rargs)  # Do not call this function directly, use argtinfo_helper_t
    bint func_has_stkframe_hole(ea_t ea, func_type_data_t& fti)  # Looks for a hole at the beginning of the stack...
    int lower_type(til_t* til, tinfo_t* tif, char* name, lowertype_helper_t* _helper)  # ---------------------------------------------------------...
    int replace_ordinal_typerefs(til_t* til, tinfo_t* tif)  # Replace references to ordinal types by name references....
    void begin_type_updating(update_type_t utp)  # Mark the beginning of a large update operation on the...
    void end_type_updating(update_type_t utp)  # Mark the end of a large update operation on the types...
    tid_t get_named_type_tid(char* name)  # Get named local type TID 
    bint get_tid_name(qstring* out, tid_t tid)  # Get a type name for the specified TID 
    uint32 get_tid_ordinal(tid_t tid)  # Get type ordinal number for TID 
    ssize_t get_udm_by_fullname(udm_t* udm, char* fullname)  # Get udt member by full name 
    bint get_idainfo_by_udm(flags64_t* flags, opinfo_t* ti, udm_t& udm, ea_t refinfo_ea)  # Calculate IDA info from udt member 
    tid_t create_enum_type(char* enum_name, enum_type_data_t& ei, int enum_width, type_sign_t sign, bint convert_to_bitmask, char* enum_cmt)  # Create type enum 
    bint format_cdata(qstrvec_t* outvec, idc_value_t& idc_value, tinfo_t* tif, valstr_t* vtree, format_data_info_t* fdi)  # Format a data value as a C initializer. 
    int print_cdata(text_sink_t& printer, idc_value_t& idc_value, tinfo_t* tif, format_data_info_t* fdi)  # The same as format_cdata(), but instead of returning the...
    int print_decls(text_sink_t& printer, til_t* til, ordvec_t* ordinals, uint32 pdf_flags)  # Print types (and possibly their dependencies) in a...
    int calc_number_of_children(argloc_t& loc, tinfo_t& tif, bint dont_deref_ptr)  # Calculate max number of lines of a formatted c data,...
    bint get_enum_member_expr(qstring* buf, tinfo_t& tif, int serial, uint64 value)  # Return a C expression that can be used to represent an...
    bint choose_named_type(til_symbol_t* out_sym, til_t* root_til, char* title, int ntf_flags, predicate_t* predicate)  # Choose a type from a type library. 
    void* hexrays_alloc(size_t size)
    void hexrays_free(void* ptr)
    uvlr_t max_vlr_value(int size)  # ---------------------------------------------------------...
    uvlr_t min_vlr_svalue(int size)
    uvlr_t max_vlr_svalue(int size)
    bint is_unsigned_cmpop(cmpop_t cmpop)
    bint is_signed_cmpop(cmpop_t cmpop)
    bint is_cmpop_with_eq(cmpop_t cmpop)
    bint is_cmpop_without_eq(cmpop_t cmpop)
    bint is_may_access(maymust_t maymust)  # do not include global memory into the spoiled list of a call
    ea_t get_merror_desc(qstring* out, merror_t code, mba_t* mba)  # Get textual description of an error code 
    bint must_mcode_close_block(mcode_t mcode, bint including_calls)  # Must an instruction with the given opcode be the last...
    bint is_mcode_propagatable(mcode_t mcode)  # May opcode be propagated? Such opcodes can be used in...
    bint is_mcode_addsub(mcode_t mcode)  # Is add or sub instruction?
    bint is_mcode_xdsu(mcode_t mcode)  # Is xds or xdu instruction? We use 'xdsu' as a shortcut...
    bint is_mcode_set(mcode_t mcode)  # Is a 'set' instruction? (an instruction that sets a...
    bint is_mcode_set1(mcode_t mcode)  # Is a 1-operand 'set' instruction? Only 'sets' is in this group
    bint is_mcode_j1(mcode_t mcode)  # Is a 1-operand conditional jump instruction? Only 'jcnd'...
    bint is_mcode_jcond(mcode_t mcode)  # Is a conditional jump?
    bint is_mcode_convertible_to_jmp(mcode_t mcode)  # Is a 'set' instruction that can be converted into a...
    bint is_mcode_convertible_to_set(mcode_t mcode)  # Is a conditional jump instruction that can be converted...
    bint is_mcode_call(mcode_t mcode)  # Is a call instruction? (direct or indirect)
    bint is_mcode_fpu(mcode_t mcode)  # Must be an FPU instruction?
    bint is_mcode_commutative(mcode_t mcode)  # Is a commutative instruction?
    bint is_mcode_shift(mcode_t mcode)  # Is a shift instruction?
    bint is_mcode_divmod(mcode_t op)  # Is a kind of div or mod instruction?
    bint has_mcode_seloff(mcode_t op)  # Is an instruction with the selector/offset pair?
    mcode_t set2jcnd(mcode_t code)  # Convert setX opcode into corresponding jX opcode This...
    mcode_t jcnd2set(mcode_t code)  # Convert setX opcode into corresponding jX opcode This...
    mcode_t negate_mcode_relation(mcode_t code)  # Negate a conditional opcode. Conditional jumps can be...
    mcode_t swap_mcode_relation(mcode_t code)  # Swap a conditional opcode. Only conditional jumps and...
    mcode_t get_signed_mcode(mcode_t code)  # Return the opcode that performs signed operation....
    mcode_t get_unsigned_mcode(mcode_t code)  # Return the opcode that performs unsigned operation....
    bint is_signed_mcode(mcode_t code)  # Does the opcode perform a signed operation?
    bint is_unsigned_mcode(mcode_t code)  # Does the opcode perform a unsigned operation?
    bint mcode_modifies_d(mcode_t mcode)  # Does the 'd' operand gets modified by the instruction?...
    char* dstr(tinfo_t* tif)  # Print the specified type info. This function can be used...
    bint is_type_correct(type_t* ptr)  # Verify a type string. 
    bint is_small_udt(tinfo_t& tif)  # Is a small structure or union? 
    bint is_nonbool_type(tinfo_t& type)  # Is definitely a non-boolean type? 
    bint is_bool_type(tinfo_t& type)  # Is a boolean type? 
    bint is_ptr_or_array(type_t t)  # Is a pointer or array type?
    bint is_paf(type_t t)  # Is a pointer, array, or function type?
    bint is_inplace_def(tinfo_t& type)  # Is struct/union/enum definition (not declaration)?
    int partial_type_num(tinfo_t& type)  # Calculate number of partial subtypes. 
    tinfo_t get_float_type(int width)  # Get a type of a floating point value with the specified width 
    tinfo_t get_int_type_by_width_and_sign(int srcwidth, type_sign_t sign)  # Create a type info by width and sign. Returns a simple...
    tinfo_t get_unk_type(int size)  # Create a partial type info by width. Returns a partially...
    tinfo_t dummy_ptrtype(int ptrsize, bint isfp)  # Generate a dummy pointer type 
    tinfo_t make_pointer(tinfo_t& type)  # Create a pointer type. This function performs the...
    tinfo_t create_typedef(char* name)  # Create a reference to a named type. 
    bint get_type(uval_t id, tinfo_t* tif, type_source_t guess)  # Get a global type. Global types are types of addressable...
    bint set_type(uval_t id, tinfo_t& tif, type_source_t source, bint force)  # Set a global type. 
    void print_vdloc(qstring* vout, vdloc_t& loc, int nbytes)  # Print vdloc. Since vdloc does not always carry the size...
    bint arglocs_overlap(vdloc_t& loc1, size_t w1, vdloc_t& loc2, size_t w2)  # ---------------------------------------------------------...
    bint restore_user_lvar_settings(lvar_uservec_t* lvinf, ea_t func_ea)  # Restore user defined local variable settings in the database. 
    void save_user_lvar_settings(ea_t func_ea, lvar_uservec_t& lvinf)  # Save user defined local variable settings into the database. 
    bint modify_user_lvars(ea_t entry_ea, user_lvar_modifier_t& mlv)  # Modify saved local variable settings. 
    bint modify_user_lvar_info(ea_t func_ea, uint mli_flags, lvar_saved_info_t& info)  # Modify saved local variable settings of one variable. 
    bint locate_lvar(lvar_locator_t* out, ea_t func_ea, char* varname)  # Find a variable by name. 
    bint rename_lvar(ea_t func_ea, char* oldname, char* newname)  # Rename a local variable. 
    bint restore_user_defined_calls(udcall_map_t* udcalls, ea_t func_ea)  # Restore user defined function calls from the database. 
    void save_user_defined_calls(ea_t func_ea, udcall_map_t& udcalls)  # Save user defined local function calls into the database. 
    bint parse_user_call(udcall_t* udc, char* decl, bint silent)  # Convert function type declaration into internal structure 
    merror_t convert_to_user_call(udcall_t& udc, codegen_t& cdg)  # try to generate user-defined call for an instruction 
    bint install_microcode_filter(microcode_filter_t* filter, bint install)  # register/unregister non-standard microcode generator 
    mlist_t& get_temp_regs()  # ---------------------------------------------------------...
    bint is_kreg(mreg_t r)  # Is a kernel register? Kernel registers are temporary...
    mreg_t reg2mreg(int reg)  # Map a processor register to a microregister. 
    int mreg2reg(mreg_t reg, int width)  # Map a microregister to a processor register. 
    int get_mreg_name(qstring* out, mreg_t reg, int width, void* ud)  # Get the microregister name. 
    void install_optinsn_handler(optinsn_t* opt)  # Install an instruction level custom optimizer 
    bint remove_optinsn_handler(optinsn_t* opt)  # Remove an instruction level custom optimizer
    void install_optblock_handler(optblock_t* opt)  # Install a block level custom optimizer. 
    bint remove_optblock_handler(optblock_t* opt)  # Remove a block level custom optimizer
    minsn_t* getf_reginsn(minsn_t* ins)  # Skip assertions forward
    minsn_t* getb_reginsn(minsn_t* ins)  # Skip assertions backward
    bint change_hexrays_config(char* directive)  # ---------------------------------------------------------...
    char* get_hexrays_version()  # ---------------------------------------------------------...
    vdui_t* open_pseudocode(ea_t ea, int flags)  # Open pseudocode window. The specified function is...
    bint close_pseudocode(TWidget* f)  # Close pseudocode window. 
    vdui_t* get_widget_vdui(TWidget* f)  # Get the vdui_t instance associated to the TWidget 
    bint decompile_many(char* outfile, eavec_t* funcaddrs, int flags)  # Batch decompilation. Decompile all or the specified functions 
    void send_database(hexrays_failure_t& err, bint silent)  # Send the database to Hex-Rays. This function sends the...
    bint get_current_operand(gco_info_t* out)  # Get the instruction operand under the cursor. This...
    void remitem(citem_t* e)
    ctype_t negated_relation(ctype_t op)  # Negate a comparison operator. For example, becomes
    ctype_t swapped_relation(ctype_t op)  # Swap a comparison operator. For example, becomes
    type_sign_t get_op_signness(ctype_t op)  # Get operator sign. Meaningful for sign-dependent operators, like
    ctype_t asgop(ctype_t cop)  # Convert plain operator into assignment operator. For...
    ctype_t asgop_revert(ctype_t cop)  # Convert assignment operator into plain operator. For...
    bint op_uses_x(ctype_t op)  # Does operator use the 'x' field of cexpr_t?
    bint op_uses_y(ctype_t op)  # Does operator use the 'y' field of cexpr_t?
    bint op_uses_z(ctype_t op)  # Does operator use the 'z' field of cexpr_t?
    bint is_binary(ctype_t op)  # Is binary operator?
    bint is_unary(ctype_t op)  # Is unary operator?
    bint is_relational(ctype_t op)  # Is comparison operator?
    bint is_assignment(ctype_t op)  # Is assignment operator?
    bint accepts_udts(ctype_t op)  # Can operate on UDTs?
    bint is_prepost(ctype_t op)  # Is pre/post increment/decrement operator?
    bint is_commutative(ctype_t op)  # Is commutative operator?
    bint is_additive(ctype_t op)  # Is additive operator?
    bint is_multiplicative(ctype_t op)  # Is multiplicative operator?
    bint is_bitop(ctype_t op)  # Is bit related operator?
    bint is_logical(ctype_t op)  # Is logical operator?
    bint is_loop(ctype_t op)  # Is loop statement code?
    bint is_break_consumer(ctype_t op)  # Does a break statement influence the specified statement code?
    bint is_lvalue(ctype_t op)  # Is Lvalue operator?
    bint accepts_small_udts(ctype_t op)  # Is the operator allowed on small structure or union?
    cexpr_t* lnot(cexpr_t* e)  # Logically negate the specified expression. The specified...
    cinsn_t* new_block()  # Create a new block-statement.
    cexpr_t* create_helper(bint standalone, tinfo_t& type, char* format)  # Create a helper object..
    cexpr_t* call_helper(tinfo_t& rettype, carglist_t* args, char* format)  # Create a helper call.
    cexpr_t* make_num(uint64 n, cfunc_t* func, ea_t ea, int opnum, type_sign_t sign, int size)  # Create a number expression 
    cexpr_t* make_ref(cexpr_t* e)  # Create a reference. This function performs the following...
    cexpr_t* dereference(cexpr_t* e, int ptrsize, bint is_flt)  # Dereference a pointer. This function dereferences a...
    void save_user_labels(ea_t func_ea, user_labels_t* user_labels, cfunc_t* func)  # Save user defined labels into the database. 
    void save_user_cmts(ea_t func_ea, user_cmts_t* user_cmts)  # Save user defined comments into the database. 
    void save_user_numforms(ea_t func_ea, user_numforms_t* numforms)  # Save user defined number formats into the database. 
    void save_user_iflags(ea_t func_ea, user_iflags_t* iflags)  # Save user defined citem iflags into the database. 
    void save_user_unions(ea_t func_ea, user_unions_t* unions)  # Save user defined union field selections into the database. 
    user_labels_t* restore_user_labels(ea_t func_ea, cfunc_t* func)  # Restore user defined labels from the database. 
    user_cmts_t* restore_user_cmts(ea_t func_ea)  # Restore user defined comments from the database. 
    user_numforms_t* restore_user_numforms(ea_t func_ea)  # Restore user defined number formats from the database. 
    user_iflags_t* restore_user_iflags(ea_t func_ea)  # Restore user defined citem iflags from the database. 
    user_unions_t* restore_user_unions(ea_t func_ea)  # Restore user defined union field selections from the database. 
    void close_hexrays_waitbox()  # Close the waitbox displayed by the decompiler. Useful if...
    cfuncptr_t decompile(mba_ranges_t& mbr, hexrays_failure_t* hf, int decomp_flags)  # Decompile a snippet or a function. 
    cfuncptr_t decompile_func(func_t* pfn, hexrays_failure_t* hf, int decomp_flags)  # Decompile a function. Multiple decompilations of the...
    cfuncptr_t decompile_snippet(rangevec_t& ranges, hexrays_failure_t* hf, int decomp_flags)  # Decompile a snippet. 
    mba_t* gen_microcode(mba_ranges_t& mbr, hexrays_failure_t* hf, mlist_t* retlist, int decomp_flags, mba_maturity_t reqmat)  # Generate microcode of an arbitrary code snippet 
    mba_t* create_empty_mba(mba_ranges_t& mbr, hexrays_failure_t* hf)  # Create an empty microcode object
    cfuncptr_t create_cfunc(mba_t* mba)  # Create a new cfunc_t object. 
    bint mark_cfunc_dirty(ea_t ea, bint close_views)  # Flush the cached decompilation results. Erases a cache...
    void clear_cached_cfuncs()  # Flush all cached decompilation results.
    bint has_cached_cfunc(ea_t ea)  # Do we have a cached decompilation result for 'ea'?
    char* get_ctype_name(ctype_t op)
    qstring create_field_name(tinfo_t& type, uval_t offset)
    bint init_hexrays_plugin(int flags)  # ---------------------------------------------------------...
    void term_hexrays_plugin()  # ---------------------------------------------------------...
    operand_locator_t& user_numforms_first(user_numforms_iterator_t p)  # ---------------------------------------------------------...
    number_format_t& user_numforms_second(user_numforms_iterator_t p)  # ---------------------------------------------------------...
    user_numforms_iterator_t user_numforms_find(user_numforms_t* map, operand_locator_t& key)  # ---------------------------------------------------------...
    user_numforms_iterator_t user_numforms_insert(user_numforms_t* map, operand_locator_t& key, number_format_t& val)  # ---------------------------------------------------------...
    user_numforms_iterator_t user_numforms_begin(user_numforms_t* map)  # ---------------------------------------------------------...
    user_numforms_iterator_t user_numforms_end(user_numforms_t* map)  # ---------------------------------------------------------...
    user_numforms_iterator_t user_numforms_next(user_numforms_iterator_t p)  # ---------------------------------------------------------...
    user_numforms_iterator_t user_numforms_prev(user_numforms_iterator_t p)  # ---------------------------------------------------------...
    void user_numforms_erase(user_numforms_t* map, user_numforms_iterator_t p)  # ---------------------------------------------------------...
    void user_numforms_clear(user_numforms_t* map)  # ---------------------------------------------------------...
    size_t user_numforms_size(user_numforms_t* map)  # ---------------------------------------------------------...
    void user_numforms_free(user_numforms_t* map)  # ---------------------------------------------------------...
    user_numforms_t* user_numforms_new()  # ---------------------------------------------------------...
    lvar_locator_t& lvar_mapping_first(lvar_mapping_iterator_t p)  # ---------------------------------------------------------...
    lvar_locator_t& lvar_mapping_second(lvar_mapping_iterator_t p)  # ---------------------------------------------------------...
    lvar_mapping_iterator_t lvar_mapping_find(lvar_mapping_t* map, lvar_locator_t& key)  # ---------------------------------------------------------...
    lvar_mapping_iterator_t lvar_mapping_insert(lvar_mapping_t* map, lvar_locator_t& key, lvar_locator_t& val)  # ---------------------------------------------------------...
    lvar_mapping_iterator_t lvar_mapping_begin(lvar_mapping_t* map)  # ---------------------------------------------------------...
    lvar_mapping_iterator_t lvar_mapping_end(lvar_mapping_t* map)  # ---------------------------------------------------------...
    lvar_mapping_iterator_t lvar_mapping_next(lvar_mapping_iterator_t p)  # ---------------------------------------------------------...
    lvar_mapping_iterator_t lvar_mapping_prev(lvar_mapping_iterator_t p)  # ---------------------------------------------------------...
    void lvar_mapping_erase(lvar_mapping_t* map, lvar_mapping_iterator_t p)  # ---------------------------------------------------------...
    void lvar_mapping_clear(lvar_mapping_t* map)  # ---------------------------------------------------------...
    size_t lvar_mapping_size(lvar_mapping_t* map)  # ---------------------------------------------------------...
    void lvar_mapping_free(lvar_mapping_t* map)  # ---------------------------------------------------------...
    lvar_mapping_t* lvar_mapping_new()  # ---------------------------------------------------------...
    ea_t& udcall_map_first(udcall_map_iterator_t p)  # ---------------------------------------------------------...
    udcall_t& udcall_map_second(udcall_map_iterator_t p)  # ---------------------------------------------------------...
    udcall_map_iterator_t udcall_map_find(udcall_map_t* map, ea_t& key)  # ---------------------------------------------------------...
    udcall_map_iterator_t udcall_map_insert(udcall_map_t* map, ea_t& key, udcall_t& val)  # ---------------------------------------------------------...
    udcall_map_iterator_t udcall_map_begin(udcall_map_t* map)  # ---------------------------------------------------------...
    udcall_map_iterator_t udcall_map_end(udcall_map_t* map)  # ---------------------------------------------------------...
    udcall_map_iterator_t udcall_map_next(udcall_map_iterator_t p)  # ---------------------------------------------------------...
    udcall_map_iterator_t udcall_map_prev(udcall_map_iterator_t p)  # ---------------------------------------------------------...
    void udcall_map_erase(udcall_map_t* map, udcall_map_iterator_t p)  # ---------------------------------------------------------...
    void udcall_map_clear(udcall_map_t* map)  # ---------------------------------------------------------...
    size_t udcall_map_size(udcall_map_t* map)  # ---------------------------------------------------------...
    void udcall_map_free(udcall_map_t* map)  # ---------------------------------------------------------...
    udcall_map_t* udcall_map_new()  # ---------------------------------------------------------...
    treeloc_t& user_cmts_first(user_cmts_iterator_t p)  # ---------------------------------------------------------...
    citem_cmt_t& user_cmts_second(user_cmts_iterator_t p)  # ---------------------------------------------------------...
    user_cmts_iterator_t user_cmts_find(user_cmts_t* map, treeloc_t& key)  # ---------------------------------------------------------...
    user_cmts_iterator_t user_cmts_insert(user_cmts_t* map, treeloc_t& key, citem_cmt_t& val)  # ---------------------------------------------------------...
    user_cmts_iterator_t user_cmts_begin(user_cmts_t* map)  # ---------------------------------------------------------...
    user_cmts_iterator_t user_cmts_end(user_cmts_t* map)  # ---------------------------------------------------------...
    user_cmts_iterator_t user_cmts_next(user_cmts_iterator_t p)  # ---------------------------------------------------------...
    user_cmts_iterator_t user_cmts_prev(user_cmts_iterator_t p)  # ---------------------------------------------------------...
    void user_cmts_erase(user_cmts_t* map, user_cmts_iterator_t p)  # ---------------------------------------------------------...
    void user_cmts_clear(user_cmts_t* map)  # ---------------------------------------------------------...
    size_t user_cmts_size(user_cmts_t* map)  # ---------------------------------------------------------...
    void user_cmts_free(user_cmts_t* map)  # ---------------------------------------------------------...
    user_cmts_t* user_cmts_new()  # ---------------------------------------------------------...
    citem_locator_t& user_iflags_first(user_iflags_iterator_t p)  # ---------------------------------------------------------...
    int32& user_iflags_second(user_iflags_iterator_t p)  # ---------------------------------------------------------...
    user_iflags_iterator_t user_iflags_find(user_iflags_t* map, citem_locator_t& key)  # ---------------------------------------------------------...
    user_iflags_iterator_t user_iflags_insert(user_iflags_t* map, citem_locator_t& key, int32& val)  # ---------------------------------------------------------...
    user_iflags_iterator_t user_iflags_begin(user_iflags_t* map)  # ---------------------------------------------------------...
    user_iflags_iterator_t user_iflags_end(user_iflags_t* map)  # ---------------------------------------------------------...
    user_iflags_iterator_t user_iflags_next(user_iflags_iterator_t p)  # ---------------------------------------------------------...
    user_iflags_iterator_t user_iflags_prev(user_iflags_iterator_t p)  # ---------------------------------------------------------...
    void user_iflags_erase(user_iflags_t* map, user_iflags_iterator_t p)  # ---------------------------------------------------------...
    void user_iflags_clear(user_iflags_t* map)  # ---------------------------------------------------------...
    size_t user_iflags_size(user_iflags_t* map)  # ---------------------------------------------------------...
    void user_iflags_free(user_iflags_t* map)  # ---------------------------------------------------------...
    user_iflags_t* user_iflags_new()  # ---------------------------------------------------------...
    ea_t& user_unions_first(user_unions_iterator_t p)  # ---------------------------------------------------------...
    intvec_t& user_unions_second(user_unions_iterator_t p)  # ---------------------------------------------------------...
    user_unions_iterator_t user_unions_find(user_unions_t* map, ea_t& key)  # ---------------------------------------------------------...
    user_unions_iterator_t user_unions_insert(user_unions_t* map, ea_t& key, intvec_t& val)  # ---------------------------------------------------------...
    user_unions_iterator_t user_unions_begin(user_unions_t* map)  # ---------------------------------------------------------...
    user_unions_iterator_t user_unions_end(user_unions_t* map)  # ---------------------------------------------------------...
    user_unions_iterator_t user_unions_next(user_unions_iterator_t p)  # ---------------------------------------------------------...
    user_unions_iterator_t user_unions_prev(user_unions_iterator_t p)  # ---------------------------------------------------------...
    void user_unions_erase(user_unions_t* map, user_unions_iterator_t p)  # ---------------------------------------------------------...
    void user_unions_clear(user_unions_t* map)  # ---------------------------------------------------------...
    size_t user_unions_size(user_unions_t* map)  # ---------------------------------------------------------...
    void user_unions_free(user_unions_t* map)  # ---------------------------------------------------------...
    user_unions_t* user_unions_new()  # ---------------------------------------------------------...
    int& user_labels_first(user_labels_iterator_t p)  # ---------------------------------------------------------...
    qstring& user_labels_second(user_labels_iterator_t p)  # ---------------------------------------------------------...
    user_labels_iterator_t user_labels_find(user_labels_t* map, int& key)  # ---------------------------------------------------------...
    user_labels_iterator_t user_labels_insert(user_labels_t* map, int& key, qstring& val)  # ---------------------------------------------------------...
    user_labels_iterator_t user_labels_begin(user_labels_t* map)  # ---------------------------------------------------------...
    user_labels_iterator_t user_labels_end(user_labels_t* map)  # ---------------------------------------------------------...
    user_labels_iterator_t user_labels_next(user_labels_iterator_t p)  # ---------------------------------------------------------...
    user_labels_iterator_t user_labels_prev(user_labels_iterator_t p)  # ---------------------------------------------------------...
    void user_labels_erase(user_labels_t* map, user_labels_iterator_t p)  # ---------------------------------------------------------...
    void user_labels_clear(user_labels_t* map)  # ---------------------------------------------------------...
    size_t user_labels_size(user_labels_t* map)  # ---------------------------------------------------------...
    void user_labels_free(user_labels_t* map)  # ---------------------------------------------------------...
    user_labels_t* user_labels_new()  # ---------------------------------------------------------...
    ea_t& eamap_first(eamap_iterator_t p)  # ---------------------------------------------------------...
    cinsnptrvec_t& eamap_second(eamap_iterator_t p)  # ---------------------------------------------------------...
    eamap_iterator_t eamap_find(eamap_t* map, ea_t& key)  # ---------------------------------------------------------...
    eamap_iterator_t eamap_insert(eamap_t* map, ea_t& key, cinsnptrvec_t& val)  # ---------------------------------------------------------...
    eamap_iterator_t eamap_begin(eamap_t* map)  # ---------------------------------------------------------...
    eamap_iterator_t eamap_end(eamap_t* map)  # ---------------------------------------------------------...
    eamap_iterator_t eamap_next(eamap_iterator_t p)  # ---------------------------------------------------------...
    eamap_iterator_t eamap_prev(eamap_iterator_t p)  # ---------------------------------------------------------...
    void eamap_erase(eamap_t* map, eamap_iterator_t p)  # ---------------------------------------------------------...
    void eamap_clear(eamap_t* map)  # ---------------------------------------------------------...
    size_t eamap_size(eamap_t* map)  # ---------------------------------------------------------...
    void eamap_free(eamap_t* map)  # ---------------------------------------------------------...
    eamap_t* eamap_new()  # ---------------------------------------------------------...
    cinsn_t*& boundaries_first(boundaries_iterator_t p)  # ---------------------------------------------------------...
    rangeset_t& boundaries_second(boundaries_iterator_t p)  # ---------------------------------------------------------...
    boundaries_iterator_t boundaries_find(boundaries_t* map, cinsn_t*& key)  # ---------------------------------------------------------...
    boundaries_iterator_t boundaries_insert(boundaries_t* map, cinsn_t*& key, rangeset_t& val)  # ---------------------------------------------------------...
    boundaries_iterator_t boundaries_begin(boundaries_t* map)  # ---------------------------------------------------------...
    boundaries_iterator_t boundaries_end(boundaries_t* map)  # ---------------------------------------------------------...
    boundaries_iterator_t boundaries_next(boundaries_iterator_t p)  # ---------------------------------------------------------...
    boundaries_iterator_t boundaries_prev(boundaries_iterator_t p)  # ---------------------------------------------------------...
    void boundaries_erase(boundaries_t* map, boundaries_iterator_t p)  # ---------------------------------------------------------...
    void boundaries_clear(boundaries_t* map)  # ---------------------------------------------------------...
    size_t boundaries_size(boundaries_t* map)  # ---------------------------------------------------------...
    void boundaries_free(boundaries_t* map)  # ---------------------------------------------------------...
    boundaries_t* boundaries_new()  # ---------------------------------------------------------...
    chain_t& block_chains_get(block_chains_iterator_t p)  # ---------------------------------------------------------...
    block_chains_iterator_t block_chains_find(block_chains_t* set, chain_t& val)  # ---------------------------------------------------------...
    block_chains_iterator_t block_chains_insert(block_chains_t* set, chain_t& val)  # ---------------------------------------------------------...
    block_chains_iterator_t block_chains_begin(block_chains_t* set)  # ---------------------------------------------------------...
    block_chains_iterator_t block_chains_end(block_chains_t* set)  # ---------------------------------------------------------...
    block_chains_iterator_t block_chains_next(block_chains_iterator_t p)  # ---------------------------------------------------------...
    block_chains_iterator_t block_chains_prev(block_chains_iterator_t p)  # ---------------------------------------------------------...
    void block_chains_erase(block_chains_t* set, block_chains_iterator_t p)  # ---------------------------------------------------------...
    void block_chains_clear(block_chains_t* set)  # ---------------------------------------------------------...
    size_t block_chains_size(block_chains_t* set)  # ---------------------------------------------------------...
    void block_chains_free(block_chains_t* set)  # ---------------------------------------------------------...
    block_chains_t* block_chains_new()  # ---------------------------------------------------------...
