# cython: language_level=3
# distutils: language=c++
#
# THIS FILE IS AUTO-GENERATED BY pxdgen - DO NOT EDIT
# Generated: 2025-11-30 01:47:49
# Source: typeinf.hpp
#

from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libc.stdint cimport uint8_t, uint16_t, uint32_t, uint64_t
from libc.stdint cimport intptr_t, uintptr_t
from libc.stddef cimport size_t, ptrdiff_t
from libc.stdio cimport FILE
from libcpp cimport bool as cppbool

cdef extern from "typeinf.hpp":
    # =========================================================================
    # Fundamental Types
    # =========================================================================
    ctypedef int64_t adiff_t
    ctypedef uint64_t asize_t
    ctypedef uint32_t bgcolor_t
    ctypedef uint64_t bmask_t
    ctypedef uint64_t ea_t
    ctypedef uint64_t enum_t
    ctypedef int32_t error_t
    ctypedef uint64_t flags64_t
    ctypedef uint32_t flags_t
    ctypedef int16_t int16
    ctypedef int32_t int32
    ctypedef int64_t int64
    ctypedef int8_t int8
    ctypedef uint64_t nodeidx_t
    ctypedef uint8_t op_dtype_t
    ctypedef uint64_t sel_t
    ctypedef int8_t sint8
    ctypedef int64_t sval_t
    ctypedef uint64_t tid_t
    ctypedef uint8_t uchar
    ctypedef uint32_t uint
    ctypedef uint16_t uint16
    ctypedef uint32_t uint32
    ctypedef uint64_t uint64
    ctypedef uint8_t uint8
    ctypedef uint16_t ushort
    ctypedef uint64_t uval_t

    # =========================================================================
    # Typedefs
    # =========================================================================
    ctypedef int16_t int_least16_t
    ctypedef int32_t int_least32_t
    ctypedef int64_t int_least64_t
    ctypedef uint8_t uint_least8_t
    ctypedef uint16_t uint_least16_t
    ctypedef uint32_t uint_least32_t
    ctypedef uint64_t uint_least64_t
    ctypedef int8_t int_fast8_t
    ctypedef int16_t int_fast16_t
    ctypedef int32_t int_fast32_t
    ctypedef int64_t int_fast64_t
    ctypedef uint8_t uint_fast8_t
    ctypedef uint16_t uint_fast16_t
    ctypedef uint32_t uint_fast32_t
    ctypedef uint64_t uint_fast64_t
    ctypedef int64_t quad_t
    ctypedef quad_t* qaddr_t
    ctypedef int32_t swblk_t
    ctypedef uint64 ulonglong
    ctypedef int64 longlong
    ctypedef uint16 wchar16_t
    ctypedef uint32 wchar32_t
    ctypedef uint32 ea32_t
    ctypedef uint64 ea64_t
    ctypedef uval_t inode_t  # The inode_t type is the specialization specific inode...
    ctypedef size_t diffpos_t  # A position in the difference source. This is an abstract...
    ctypedef int qhandle_t
    ctypedef uint16[11] eNI  # There is one more internal format used by IDA to store...
    ctypedef uchar comp_t  # ---------------------------------------------------------...
    ctypedef uchar cm_t
    ctypedef uint32 callcnv_t
    ctypedef uint64 nodeidx64_t
    ctypedef uint32 nodeidx32_t
    ctypedef flags_t aflags_t  #  See
    ctypedef uchar reftype_t  # @ }
    ctypedef uchar type_t  # ---------------------------------------------------------...
    ctypedef uchar p_list
    ctypedef uchar color_t  # @ }
    ctypedef uint64 tif_cursor_t  # ---------------------------------------------------------...
    ctypedef int cpidx_t  # ---------------------------------------------------------...
    ctypedef int cplen_t
    ctypedef int twidget_type_t  # ---------------------------------------------------------...
    ctypedef action_ctx_base_t action_update_ctx_t
    ctypedef int input_event_modifiers_t
    ctypedef input_event_modifiers_t view_event_state_t
    ctypedef view_mouse_event_location_t location_t
    ctypedef action_ctx_base_t action_activation_ctx_t  # ---------------------------------------------------------...
    ctypedef uchar optype_t  # ---------------------------------------------------------...
    ctypedef int help_t  #   The interface consists of two structures: - definition...
    ctypedef int ignore_name_def_t  # What name types to ignore
    ctypedef uchar p_string  # Inside a type string, a pascal-like string: dt length, characters
    ctypedef uint64 bmask64_t  # unsigned value that describes a bitmask
    ctypedef uchar bte_t  # ---------------------------------------------------------...
    ctypedef int type_sign_t
    ctypedef int argloc_type_t  # Specifies the location type of a function argument or a...
    ctypedef size_t biggest_t
    ctypedef uint64 typid_t  # @ }

    # =========================================================================
    # Enums
    # =========================================================================
    cdef enum:
        QOS_CLASS_USER_INTERACTIVE = 33
        QOS_CLASS_USER_INITIATED = 25
        QOS_CLASS_DEFAULT = 21
        QOS_CLASS_UTILITY = 17
        QOS_CLASS_BACKGROUND = 9
        QOS_CLASS_UNSPECIFIED = 0
    cdef enum:
        pool_size
        pool_nelems
    cdef enum tty_control_t:  # Teletype control
        TCT_UNKNOWN
        TCT_OWNER
        TCT_NOT_OWNER
    cdef enum:
        QMOVE_CROSS_FS  # UNIX: allow moving between different filesystem
        QMOVE_OVERWRITE  # Overwrite existing file
        QMOVE_OVR_RO  # Overwrite file even if it is write-protected
    cdef enum fpvalue_kind_t:  # Floating value kinds. They are useful when checking for NaN/Inf
        FPV_BADARG  # wrong value of max_exp
        FPV_NORM  # regular value
        FPV_NAN  # NaN
        FPV_PINF  # positive infinity
        FPV_NINF  # negative infinity
    cdef enum fpvalue_error_t:  #  Return values for ieee_realcvt and processor_t::realcvt request
        REAL_ERROR_OK = 1  # no error
        REAL_ERROR_FORMAT = -1  # realcvt: not supported format for current .idp
        REAL_ERROR_RANGE = -2  # realcvt: number too big (small) for store (mem...
        REAL_ERROR_BADDATA = -3  # realcvt: illegal real data for load (IEEE data...
        REAL_ERROR_FPOVER = 2  # floating overflow or underflow
        REAL_ERROR_BADSTR = 3  # asctoreal: illegal input string
        REAL_ERROR_ZERODIV = 4  # ediv: divide by 0
        REAL_ERROR_INTOVER = 5  # eetol*: integer overflow
    cdef enum range_kind_t:  # ---------------------------------------------------------...
        RANGE_KIND_UNKNOWN
        RANGE_KIND_FUNC
        RANGE_KIND_SEGMENT
        RANGE_KIND_HIDDEN_RANGE
    cdef enum filetype_t:  # ---------------------------------------------------------...
        f_EXE_old  # MS DOS EXE File
        f_COM_old  # MS DOS COM File
        f_BIN  # Binary File
        f_DRV  # MS DOS Driver
        f_WIN  # New Executable (NE)
        f_HEX  # Intel Hex Object File
        f_MEX  # MOS Technology Hex Object File
        f_LX  # Linear Executable (LX)
        f_LE  # Linear Executable (LE)
        f_NLM  # Netware Loadable Module (NLM)
        f_COFF  # Common Object File Format (COFF)
        f_PE  # Portable Executable (PE)
        f_OMF  # Object Module Format
        f_SREC  # Motorola SREC (S-record)
        f_ZIP  # ZIP file (this file is never loaded to IDA database)
        f_OMFLIB  # Library of OMF Modules
        f_AR  # ar library
        f_LOADER  # file is loaded using LOADER DLL
        f_ELF  # Executable and Linkable Format (ELF)
        f_W32RUN  # Watcom DOS32 Extender (W32RUN)
        f_AOUT  # Linux a.out (AOUT)
        f_PRC  # PalmPilot program file
        f_EXE  # MS DOS EXE File
        f_COM  # MS DOS COM File
        f_AIXAR  # AIX ar library
        f_MACHO  # Mac OS X Mach-O
        f_PSXOBJ  # Sony Playstation PSX object file
        f_MD1IMG  # Mediatek Firmware Image
    cdef enum storage_type_t:  # ---------------------------------------------------------...
        STT_CUR = -1  # use current storage type (may be used only as...
        STT_VA = 0  # regular storage: virtual arrays, an explicit...
        STT_MM = 1  # memory map: sparse storage. useful for huge objects
        STT_DBG = 2  # memory map: temporary debugger storage. used internally
    cdef enum inftag_t:
        INF_VERSION
        INF_PROCNAME
        INF_GENFLAGS
        INF_LFLAGS
        INF_DATABASE_CHANGE_COUNT
        INF_FILETYPE
        INF_OSTYPE
        INF_APPTYPE
        INF_ASMTYPE
        INF_SPECSEGS
        INF_AF
        INF_AF2
        INF_BASEADDR
        INF_START_SS
        INF_START_CS
        INF_START_IP
        INF_START_EA
        INF_START_SP
        INF_MAIN
        INF_MIN_EA
        INF_MAX_EA
        INF_OMIN_EA
        INF_OMAX_EA
        INF_LOWOFF
        INF_HIGHOFF
        INF_MAXREF
        INF_PRIVRANGE
        INF_PRIVRANGE_START_EA
        INF_PRIVRANGE_END_EA
        INF_NETDELTA
        INF_XREFNUM
        INF_TYPE_XREFNUM
        INF_REFCMTNUM
        INF_XREFFLAG
        INF_MAX_AUTONAME_LEN
        INF_NAMETYPE
        INF_SHORT_DEMNAMES
        INF_LONG_DEMNAMES
        INF_DEMNAMES
        INF_LISTNAMES
        INF_INDENT
        INF_CMT_INDENT
        INF_MARGIN
        INF_LENXREF
        INF_OUTFLAGS
        INF_CMTFLG
        INF_LIMITER
        INF_BIN_PREFIX_SIZE
        INF_PREFFLAG
        INF_STRLIT_FLAGS
        INF_STRLIT_BREAK
        INF_STRLIT_ZEROES
        INF_STRTYPE
        INF_STRLIT_PREF
        INF_STRLIT_SERNUM
        INF_DATATYPES
        INF_OBSOLETE_CC
        INF_CC_ID
        INF_CC_CM
        INF_CC_SIZE_I
        INF_CC_SIZE_B
        INF_CC_SIZE_E
        INF_CC_DEFALIGN
        INF_CC_SIZE_S
        INF_CC_SIZE_L
        INF_CC_SIZE_LL
        INF_CC_SIZE_LDBL
        INF_ABIBITS
        INF_APPCALL_OPTIONS
        INF_FILE_FORMAT_NAME  # file format name for loader modules
        INF_GROUPS  # segment group information (see init_groups())
        INF_H_PATH  # C header path
        INF_C_MACROS  # C predefined macros
        INF_INCLUDE  # assembler include file name
        INF_DUALOP_GRAPH  # Graph text representation options
        INF_DUALOP_TEXT  # Text text representation options
        INF_MD5  # MD5 of the input file
        INF_IDA_VERSION  # version of ida which created the database
        INF_STR_ENCODINGS  # a list of encodings for the program strings
        INF_DBG_BINPATHS  # unused (20 indexes)
        INF_SHA256  # SHA256 of the input file
        INF_ABINAME  # ABI name (processor specific)
        INF_ARCHIVE_PATH  # archive file path
        INF_PROBLEMS  # problem lists
        INF_SELECTORS  # 2..63 are for selector_t blob (see init_selectors())
        INF_NOTEPAD  # notepad blob, occupies 1000 indexes (1MB of text)
        INF_SRCDBG_PATHS  # source debug paths, occupies 20 indexes
        INF_SRCDBG_UNDESIRED  # user-closed source files, occupies 20 indexes
        INF_INITIAL_VERSION  # initial version of database
        INF_CTIME  # database creation timestamp
        INF_ELAPSED  # seconds database stayed open
        INF_NOPENS  # how many times the database is opened
        INF_CRC32  # input file crc32
        INF_IMAGEBASE  # image base
        INF_IDSNODE  # ids modnode id (for import_module)
        INF_FSIZE  # input file size
        INF_OUTFILEENC  # output file encoding index
        INF_INPUT_FILE_PATH
        INF_COMPILER_INFO  # more inf fields
        INF_CALLCNV  # more inf fields
        INF_LAST  # more inf fields
    cdef enum hook_type_t:  # ---------------------------------------------------------...
        HT_IDP  # Hook to the processor module. The callback...
        HT_UI  # Hook to the user interface. The callback will...
        HT_DBG  # Hook to the debugger. The callback will...
        HT_IDB  # Hook to the database events. These events are...
        HT_DEV  # Internal debugger events. Not stable and...
        HT_VIEW  # Custom/IDA views notifications. Refer to...
        HT_OUTPUT  # Output window notifications. Refer to...
        HT_GRAPH  # Handling graph operations (::graph_notification_t)
        HT_IDD  # Hook to the debugger plugin. The callback will...
        HT_LAST
    cdef enum:
        SWITCH_INFO_VERSION
    cdef enum move_segm_code_t:  #  Return values for move_segm() add rebase_program() @ {
        MOVE_SEGM_OK = 0  # all ok
        MOVE_SEGM_PARAM = -1  # The specified segment does not exist
        MOVE_SEGM_ROOM = -2  # Not enough free room at the target address
        MOVE_SEGM_IDP = -3  # IDP module forbids moving the segment
        MOVE_SEGM_CHUNK = -4  # Too many chunks are defined, can't move
        MOVE_SEGM_LOADER = -5  # The segment has been moved but the loader complained
        MOVE_SEGM_ODD = -6  # Cannot move segments by an odd number of bytes
        MOVE_SEGM_ORPHAN = -7  # Orphan bytes hinder segment movement
        MOVE_SEGM_DEBUG = -8  # Debugger segments cannot be moved
        MOVE_SEGM_SOURCEFILES = -9  # Source files ranges of addresses hinder...
        MOVE_SEGM_MAPPING = -10  # Memory mapping ranges of addresses hinder...
        MOVE_SEGM_INVAL = -11  # Invalid argument (delta/target does not fit...
    cdef enum notify_recerr_t:  # whether or not a message should be printed, letting the...
        nr_none
        nr_once
    cdef enum mbox_kind_t:  # Message box kinds
        mbox_internal  # internal error
        mbox_info
        mbox_warning
        mbox_error
        mbox_nomem
        mbox_feedback
        mbox_readerror
        mbox_writeerror
        mbox_filestruct
        mbox_wait
        mbox_hide
        mbox_replace
    cdef enum choose_type_t:  # List chooser types
        chtype_generic  # the generic choose() function
        chtype_idasgn  # see choose_idasgn()
        chtype_entry  # see choose_entry()
        chtype_name  # see choose_name()
        chtype_stkvar_xref  # see choose_stkvar_xref()
        chtype_xref  # see choose_xref()
        chtype_func  # see choose_func()
        chtype_segm  # see choose_segm()
        chtype_strpath  # see choose_struc_path()
        chtype_idatil  # see choose_til()
        chtype_srcp  # see choose_srcp()
        chtype_struct  # see choose_struct()
        chtype_enum  # see choose_enum()
        chtype_enum_by_value_and_size  # see choose_enum_by_value()
    cdef enum beep_t:
        beep_default
    cdef enum tcc_renderer_type_t:  # TWidget renderer type
        TCCRT_INVALID  # invalid
        TCCRT_FLAT  # flat view
        TCCRT_GRAPH  # graph view
        TCCRT_PROXIMITY  # proximity view
    cdef enum tcc_place_type_t:  # TWidget ::place_t type
        TCCPT_INVALID  # invalid
        TCCPT_PLACE  # ::place_t
        TCCPT_SIMPLELINE_PLACE  # ::simpleline_place_t
        TCCPT_IDAPLACE  # ::idaplace_t
        TCCPT_TIPLACE  # ::tiplace_t
    cdef enum vme_button_t:  # Represents mouse button for view_mouse_event_t objects
        VME_UNKNOWN  # unknown mouse button
        VME_LEFT_BUTTON  # left mouse button
        VME_RIGHT_BUTTON  # right mouse button
        VME_MID_BUTTON  # middle mouse button
    cdef enum data_kind_t:  # data format to display
        dk_float
        dk_int
        dk_addr_names
        dk_addr_text
    cdef enum int_format_t:
        if_hex
        if_signed
        if_unsigned
    cdef enum byte_kind_t:  # result of get_byte_value()
        BK_VALID  # has a valid value
        BK_INVALIDADDR  # address is invalid
        BK_NOVALUE  # address is valid but contains no value
    cdef enum lecvt_code_t:  # ---------------------------------------------------------...
        LECVT_CANCELED = -1
        LECVT_ERROR = 0
        LECVT_OK = 1
    cdef enum action_state_t:  # Action states - returned by action_handler_t::update()
        AST_ENABLE_ALWAYS  # enable action and do not call...
        AST_ENABLE_FOR_IDB  # enable action for the current idb. call...
        AST_ENABLE_FOR_WIDGET  # enable action for the current widget. call...
        AST_ENABLE  # enable action - call...
        AST_DISABLE_ALWAYS  # disable action and do not call...
        AST_DISABLE_FOR_IDB  # analog of ::AST_ENABLE_FOR_IDB
        AST_DISABLE_FOR_WIDGET  # analog of ::AST_ENABLE_FOR_WIDGET
        AST_DISABLE  # analog of ::AST_ENABLE
    cdef enum:
        POPUP_INS
        POPUP_DEL
        POPUP_EDIT
        POPUP_REFRESH
        NSTDPOPUPS
    cdef enum cbres_t:  # return value of ins(), del(), edit(), enter(), refresh()...
        NOTHING_CHANGED
        ALL_CHANGED
        SELECTION_CHANGED
    cdef enum navaddr_type_t:  # ---------------------------------------------------------...
        nat_lib
        nat_fun
        nat_cod
        nat_dat
        nat_und
        nat_ext
        nat_err
        nat_gap
        nat_cur
        nat_auto  # auto-analysis cursor color
        nat_lum  # related to lumina
        nat_hlo  # highlight outline
        nat_last
    cdef enum custom_viewer_handler_id_t:  # Custom viewer & code viewer handler types
        CVH_USERDATA
        CVH_KEYDOWN  # see ::custom_viewer_keydown_t
        CVH_POPUP  # see ::custom_viewer_popup_t
        CVH_DBLCLICK  # see ::custom_viewer_dblclick_t
        CVH_CURPOS  # see ::custom_viewer_curpos_t
        CVH_CLOSE  # see ::custom_viewer_close_t
        CVH_CLICK  # see ::custom_viewer_click_t
        CVH_QT_AWARE  # see set_custom_viewer_qt_aware()
        CVH_HELP  # see ::custom_viewer_help_t
        CVH_MOUSEMOVE  # see ::custom_viewer_mouse_moved_t
        CDVH_USERDATA  # see set_code_viewer_user_data()
        CDVH_SRCVIEW  # see set_code_viewer_is_source()
        CDVH_LINES_CLICK  # see ::code_viewer_lines_click_t
        CDVH_LINES_DBLCLICK  # see ::code_viewer_lines_click_t
        CDVH_LINES_POPUP  # see ::code_viewer_lines_click_t
        CDVH_LINES_DRAWICON  # see ::code_viewer_lines_icon_t
        CDVH_LINES_LINENUM  # see ::code_viewer_lines_linenum_t
        CDVH_LINES_ICONMARGIN  # see set_code_viewer_lines_icon_margin()
        CDVH_LINES_RADIX  # see set_code_viewer_lines_radix()
        CDVH_LINES_ALIGNMENT  # see set_code_viewer_lines_alignment()
    cdef enum msg_notification_t:  # ---------------------------------------------------------...
        msg_activated  # The message window is activated. 
        msg_deactivated  # The message window is deactivated. 
        msg_click  # Click event. 
        msg_dblclick  # Double click event. 
        msg_closed  # View closed. 
        msg_keydown  # Key down event. 
    cdef enum view_notification_t:  # ---------------------------------------------------------...
        view_activated  # A view is activated 
        view_deactivated  # A view is deactivated 
        view_keydown  # Key down event 
        view_click  # Click event 
        view_dblclick  # Double click event 
        view_curpos  # Cursor position changed 
        view_created  # A view is being created. 
        view_close  # View closed 
        view_switched  # A view's renderer has changed. 
        view_mouse_over  # The user moved the mouse over (or out of) a...
        view_loc_changed  # The location for the view has changed (can be...
        view_mouse_moved  # The mouse moved on the view 
    cdef enum input_event_kind_t:  # ---------------------------------------------------------...
        iek_unknown
        iek_shortcut
        iek_key_press
        iek_key_release
        iek_mouse_button_press
        iek_mouse_button_release
        iek_mouse_wheel
    cdef enum:
        MFF_MAGIC
    cdef enum action_attr_t:  # Codes for getting/setting action attributes
        AA_NONE  # no effect
        AA_LABEL  # see update_action_label()
        AA_SHORTCUT  # see update_action_shortcut()
        AA_TOOLTIP  # see update_action_tooltip()
        AA_ICON  # see update_action_icon()
        AA_STATE  # see update_action_state()
        AA_CHECKABLE  # see update_action_checkable()
        AA_CHECKED  # see update_action_checked()
        AA_VISIBILITY  # see update_action_visibility()
    cdef enum cb_id:  #  @ {
        CB_INIT = -1
        CB_YES = -2  # the user pressed 'Yes' button
        CB_CLOSE = -3  # the form is closed by the window manager...
        CB_INVISIBLE = -4  # corresponds to ui_widget_invisible
        CB_DESTROYING = -5  # the actual widget tree is being destroyed
        CB_NO = -6  # the user pressed 'No' button
        CB_CANCEL = -7  # the user pressed 'Cancel' button or Esc
    cdef enum cref_t:  # CODE xref types
        fl_U  # unknown -- for compatibility with old...
        fl_CF  # Call Far This xref creates a function at the...
        fl_CN  # Call Near This xref creates a function at the...
        fl_JF  # Jump Far
        fl_JN  # Jump Near
        fl_USobsolete  # User specified (obsolete)
        fl_F  # Ordinary flow: used to specify execution flow...
    cdef enum dref_t:  # DATA xref types
        dr_U  # Unknown -- for compatibility with old...
        dr_O  # Offset The reference uses 'offset' of data...
        dr_W  # Write access
        dr_R  # Read access
        dr_T  # Text (for forced operands only) Name of data...
        dr_I  # Informational (a derived java class references...
        dr_S  # Reference to enum member (symbolic constant)
    cdef enum cfg_input_kind_t:
        cik_string
        cik_filename
        cik_path
    cdef enum event_t:  # Callback notification codes. These are passed to...
        ev_init  # The IDP module is just loaded. 
        ev_term  # The IDP module is being unloaded
        ev_newprc  # Before changing processor type. 
        ev_newasm  # Before setting a new assembler. 
        ev_newfile  # A new file has been loaded. 
        ev_oldfile  # An old file has been loaded. 
        ev_newbinary  # IDA is about to load a binary file. 
        ev_endbinary  # IDA has loaded a binary file. 
        ev_set_idp_options  # Set IDP-specific configuration option Also see...
        ev_set_proc_options  # Called if the user specified an option string...
        ev_ana_insn  # Analyze one instruction and fill 'out'...
        ev_emu_insn  # Emulate instruction, create cross-references,...
        ev_out_header  # Function to produce start of disassembled text 
        ev_out_footer  # Function to produce end of disassembled text 
        ev_out_segstart  # Function to produce start of segment 
        ev_out_segend  # Function to produce end of segment 
        ev_out_assumes  # Function to produce assume directives when...
        ev_out_insn  # Generate text representation of an instruction...
        ev_out_mnem  # Generate instruction mnemonics. This callback...
        ev_out_operand  # Generate text representation of an instruction...
        ev_out_data  # Generate text representation of data items...
        ev_out_label  # The kernel is going to generate an instruction...
        ev_out_special_item  # Generate text representation of an item in a...
        ev_gen_regvar_def  # Generate register variable definition line. 
        ev_gen_src_file_lnnum  # Callback: generate analog of:  directive. 
        ev_creating_segm  # A new segment is about to be created. 
        ev_moving_segm  # May the kernel move the segment? 
        ev_coagulate  # Try to define some unexplored bytes. This...
        ev_undefine  # An item in the database (insn or data) is...
        ev_treat_hindering_item  # An item hinders creation of another item. 
        ev_rename  # The kernel is going to rename a byte. 
        ev_is_far_jump  # is indirect far jump or call instruction?...
        ev_is_sane_insn  # Is the instruction sane for the current file type?. 
        ev_is_cond_insn  # Is conditional instruction? 
        ev_is_call_insn  # Is the instruction a "call"? 
        ev_is_ret_insn  # Is the instruction a "return"? 
        ev_may_be_func  # Can a function start here? 
        ev_is_basic_block_end  # Is the current instruction end of a basic...
        ev_is_indirect_jump  # Determine if instruction is an indirect jump....
        ev_is_insn_table_jump  # Reserved
        ev_is_switch  # Find 'switch' idiom or override processor...
        ev_calc_switch_cases  # Calculate case values and targets for a custom...
        ev_create_switch_xrefs  # Create xrefs for a custom jump table. 
        ev_is_align_insn  # Is the instruction created only for alignment...
        ev_is_alloca_probe  # Does the function at 'ea' behave as __alloca_probe? 
        ev_delay_slot_insn  # Get delay slot instruction 
        ev_is_sp_based  # Check whether the operand is relative to stack...
        ev_can_have_type  # Can the operand have a type as offset,...
        ev_cmp_operands  # Compare instruction operands 
        ev_adjust_refinfo  # Called from apply_fixup before converting...
        ev_get_operand_string  # Request text string for operand (cli, java, ...). 
        ev_get_reg_name  # Generate text representation of a register....
        ev_str2reg  # Convert a register name to a register number....
        ev_get_autocmt  # Callback: get dynamic auto comment. Will be...
        ev_get_bg_color  # Get item background color. Plugins can hook...
        ev_is_jump_func  # Is the function a trivial "jump" function?. 
        ev_func_bounds  # find_func_bounds() finished its work. The...
        ev_verify_sp  # All function instructions have been analyzed....
        ev_verify_noreturn  # The kernel wants to set 'noreturn' flags for a...
        ev_create_func_frame  # Create a function frame for a newly created...
        ev_get_frame_retsize  # Get size of function return address in bytes...
        ev_get_stkvar_scale_factor  # Should stack variable references be multiplied...
        ev_demangle_name  # Demangle a C++ (or another language) name into...
        ev_add_cref  # A code reference is being created. 
        ev_add_dref  # A data reference is being created. 
        ev_del_cref  # A code reference is being deleted. 
        ev_del_dref  # A data reference is being deleted. 
        ev_coagulate_dref  # Data reference is being analyzed. plugin may...
        ev_may_show_sreg  # The kernel wants to display the segment...
        ev_loader_elf_machine  # ELF loader machine type checkpoint. A plugin...
        ev_auto_queue_empty  # One analysis queue is empty. 
        ev_validate_flirt_func  # Flirt has recognized a library function. This...
        ev_adjust_libfunc_ea  # Called when a signature module has been...
        ev_assemble  # Assemble an instruction. (display a warning if...
        ev_extract_address  # Extract address from a string. 
        ev_realcvt  # Floating point -> IEEE conversion 
        ev_gen_asm_or_lst  # Callback: generating asm or lst file. The...
        ev_gen_map_file  # Generate map file. If not implemented the...
        ev_create_flat_group  # Create special segment representing the flat group. 
        ev_getreg  # IBM PC only internal request, should never be...
        ev_analyze_prolog  # Analyzes function prolog, epilog, and updates...
        ev_calc_spdelta  # Calculate amount of change to sp for the given...
        ev_calcrel  # Reserved
        ev_find_reg_value  # Find register value via a register tracker....
        ev_find_op_value  # Find operand value via a register tracker. The...
        ev_replaying_undo  # Replaying an undo/redo buffer 
        ev_ending_undo  # Ended undoing/redoing an action 
        ev_set_code16_mode  # Some processors have ISA 16-bit mode e.g. ARM...
        ev_get_code16_mode  # Get ISA 16-bit mode 
        ev_get_procmod  # Get pointer to the processor module object....
        ev_asm_installed  # After setting a new assembler 
        ev_get_reg_accesses  # Get info about the registers that are...
        ev_is_control_flow_guard  # Detect if an instruction is a "thunk call" to...
        ev_broadcast  # Broadcast call 
        ev_create_merge_handlers  # Create merge handlers, if needed 
        ev_privrange_changed  # Privrange interval has been moved to a new...
        ev_cvt64_supval  # perform 32-64 conversion for a netnode array element 
        ev_cvt64_hashval  # perform 32-64 conversion for a hash value 
        ev_get_regfinder  # Get pointer to the regfinder object. This...
        ev_gen_stkvar_def  # Generate stack variable definition line...
        ev_is_addr_insn  # Does the instruction calculate some address...
        ev_last_cb_before_debugger  # START OF DEBUGGER CALLBACKS
        ev_next_exec_insn  # Get next address to be executed This function...
        ev_calc_step_over  # Calculate the address of the instruction which...
        ev_calc_next_eas  # Calculate list of addresses the instruction in...
        ev_get_macro_insn_head  # Calculate the start of a macro instruction....
        ev_get_dbr_opnum  # Get the number of the operand to be displayed...
        ev_insn_reads_tbit  # Check if insn will read the TF bit. 
        ev_clean_tbit  # Clear the TF bit after an insn like pushf...
        ev_get_idd_opinfo  # Get operand information. This callback is used...
        ev_get_reg_info  # Get register information by its name. example:...
        ev_update_call_stack  # Calculate the call stack trace for the given...
        ev_last_cb_before_type_callbacks  # START OF TYPEINFO CALLBACKS TODO: get this...
        ev_setup_til  # Setup default type libraries. (called after...
        ev_get_abi_info  # Get all possible ABI names and optional...
        ev_max_ptr_size  # Get maximal size of a pointer in bytes. 
        ev_get_default_enum_size  # Get default enum size. Not generated anymore....
        ev_get_cc_regs  # Get register allocation convention for given...
        ev_get_simd_types  # Get SIMD-related types according to given...
        ev_calc_cdecl_purged_bytes
        ev_calc_purged_bytes  # Calculate number of purged bytes by the given...
        ev_calc_retloc  # Calculate return value location. 
        ev_calc_arglocs  # Calculate function argument locations. This...
        ev_calc_varglocs  # Calculate locations of the arguments that...
        ev_adjust_argloc  # Adjust argloc according to its type/size and...
        ev_lower_func_type  # Get function arguments which should be...
        ev_equal_reglocs  # Are 2 register arglocs the same?. We need this...
        ev_use_stkarg_type  # Use information about a stack argument. 
        ev_use_regarg_type  # Use information about register argument. 
        ev_use_arg_types  # Use information about callee arguments. 
        ev_arg_addrs_ready  # Argument address info is ready. 
        ev_decorate_name  # Decorate/undecorate a C symbol name. 
        ev_arch_changed  # The loader is done parsing arch-related...
        ev_get_stkarg_area_info  # Get some metrics of the stack argument area. 
        ev_last_cb_before_loader
        ev_loader  # This code and higher ones are reserved for the...
    cdef enum access_type_t:  # Possible memory and register access types.
        NO_ACCESS = 0
        WRITE_ACCESS = 1
        READ_ACCESS = 2
        RW_ACCESS = 3
    cdef enum setproc_level_t:  # Flags passed as 'level' parameter to set_processor_type()
        SETPROC_IDB  # set processor type for old idb
        SETPROC_LOADER  # set processor type for new idb; if the user...
        SETPROC_LOADER_NON_FATAL  # the same as SETPROC_LOADER but non-fatal failures.
        SETPROC_USER  # set user-specified processor used for -p and...
    cdef enum local_type_change_t:
        LTC_NONE  # no event (internal use)
        LTC_ADDED  # added a local type
        LTC_DELETED  # deleted a local type
        LTC_EDITED  # edited a local type
        LTC_ALIASED  # added a type alias
        LTC_COMPILER  # changed the compiler and calling convention
        LTC_TIL_LOADED  # loaded a til file
        LTC_TIL_UNLOADED  # unloaded a til file
        LTC_TIL_COMPACTED  # numbered types have been compacted
    cdef enum event_code_t:  # IDB event codes
        closebase  # The database will be closed now
        savebase  # The database is being saved
        upgraded  # The database has been upgraded and the...
        auto_empty  # Info: all analysis queues are empty. This...
        auto_empty_finally  # Info: all analysis queues are empty...
        determined_main  # The main() function has been determined. 
        extlang_changed  # The list of extlangs or the default extlang...
        idasgn_loaded  # FLIRT signature has been loaded for normal...
        kernel_config_loaded  # This event is issued when ida.cfg is parsed. 
        loader_finished  # External file loader finished its work. Use...
        flow_chart_created  # Gui has retrieved a function flow chart....
        compiler_changed  # The kernel has changed the compiler information. ( 
        changing_ti  # An item typestring (c/c++ prototype) is to be changed. 
        ti_changed  # An item typestring (c/c++ prototype) has been changed. 
        changing_op_ti  # An operand typestring (c/c++ prototype) is to...
        op_ti_changed  # An operand typestring (c/c++ prototype) has...
        changing_op_type  # An operand type (offset, hex, etc...) is to be...
        op_type_changed  # An operand type (offset, hex, etc...) has been...
        segm_added  # A new segment has been created. 
        deleting_segm  # A segment is to be deleted. 
        segm_deleted  # A segment has been deleted. 
        changing_segm_start  # Segment start address is to be changed. 
        segm_start_changed  # Segment start address has been changed. 
        changing_segm_end  # Segment end address is to be changed. 
        segm_end_changed  # Segment end address has been changed. 
        changing_segm_name  # Segment name is being changed. 
        segm_name_changed  # Segment name has been changed. 
        changing_segm_class  # Segment class is being changed. 
        segm_class_changed  # Segment class has been changed. 
        segm_attrs_updated  # Segment attributes has been changed. 
        segm_moved  # Segment has been moved. 
        allsegs_moved  # Program rebasing is complete. This event is...
        func_added  # The kernel has added a function. 
        func_updated  # The kernel has updated a function. 
        set_func_start  # Function chunk start address will be changed. 
        set_func_end  # Function chunk end address will be changed. 
        deleting_func  # The kernel is about to delete a function. 
        frame_deleted  # The kernel has deleted a function frame. 
        thunk_func_created  # A thunk bit has been set for a function. 
        func_tail_appended  # A function tail chunk has been appended. 
        deleting_func_tail  # A function tail chunk is to be removed. 
        func_tail_deleted  # A function tail chunk has been removed. 
        tail_owner_changed  # A tail chunk owner has been changed. 
        func_noret_changed  # #FUNC_NORET bit has been changed. 
        stkpnts_changed  # Stack change points have been modified. 
        updating_tryblks  # About to update tryblk information 
        tryblks_updated  # Updated tryblk information 
        deleting_tryblks  # About to delete tryblk information in given range 
        sgr_changed  # The kernel has changed a segment register value. 
        make_code  # An instruction is being created. 
        make_data  # A data item is being created. 
        destroyed_items  # Instructions/data have been destroyed in [ea1,ea2). 
        renamed  # The kernel has renamed a byte. See also the...
        byte_patched  # A byte has been patched. 
        changing_cmt  # An item comment is to be changed. 
        cmt_changed  # An item comment has been changed. 
        changing_range_cmt  # Range comment is to be changed. 
        range_cmt_changed  # Range comment has been changed. 
        extra_cmt_changed  # An extra comment has been changed. 
        item_color_changed  # An item color has been changed. 
        callee_addr_changed  # Callee address has been updated by the user. 
        bookmark_changed  # Boomarked position changed. 
        sgr_deleted  # The kernel has deleted a segment register value. 
        adding_segm  # A segment is being created. 
        func_deleted  # A function has been deleted. 
        dirtree_mkdir  # Dirtree: a directory has been created. 
        dirtree_rmdir  # Dirtree: a directory has been deleted. 
        dirtree_link  # Dirtree: an item has been linked/unlinked. 
        dirtree_move  # Dirtree: a directory or item has been moved. 
        dirtree_rank  # Dirtree: a directory or item rank has been changed. 
        dirtree_rminode  # Dirtree: an inode became unavailable. 
        dirtree_segm_moved  # Dirtree: inodes were changed due to a segment...
        local_types_changed  # Local types have been changed 
        lt_udm_created  # local type udt member has been added 
        lt_udm_deleted  # local type udt member has been deleted 
        lt_udm_renamed  # local type udt member has been renamed 
        lt_udm_changed  # local type udt member has been changed 
        lt_udt_expanded  # A structure type has been expanded/shrank. 
        frame_created  # A function frame has been created. 
        frame_udm_created  # Frame member has been added. 
        frame_udm_deleted  # Frame member has been deleted. 
        frame_udm_renamed  # Frame member has been renamed. 
        frame_udm_changed  # Frame member has been changed. 
        frame_expanded  # A frame type has been expanded/shrank. 
        idasgn_matched_ea  # A FLIRT match has been found 
        lt_edm_created  # local type enum member has been added 
        lt_edm_deleted  # local type enum member has been deleted 
        lt_edm_renamed  # local type enum member has been renamed 
        lt_edm_changed  # local type enum member has been changed 
        local_type_renamed  # Local type has been renamed 
    cdef enum ucdr_kind_t:  # @ }
        UCDR_STRLIT  # string literals
        UCDR_NAME  # regular (unmangled) names
        UCDR_MANGLED  # mangled names
        UCDR_TYPE  # type names
    cdef enum nametype_t:
        VNT_IDENT  # identifier (e.g., function name)
        VNT_TYPE  # type name (can contain ' < ', '>', ...)
        VNT_UDTMEM  # UDT (structure, union, enum) member
        VNT_STRLIT  # string literal
        VNT_VISIBLE  # visible cp (obsolete; will be deleted)
    cdef enum debug_name_how_t:  # Specify strategy for retrieving debug names
        DEBNAME_EXACT  # find a name at exactly the specified address
        DEBNAME_LOWER  # find a name with the address >= the specified address
        DEBNAME_UPPER  # find a name with the address >  the specified address
        DEBNAME_NICE  # find a name with the address < = the specified address
    cdef enum demreq_type_t:  # @ }
        DQT_NPURGED_8 = -8  # only calculate number of purged bytes (sizeof(arg)==8)
        DQT_NPURGED_4 = -4  # only calculate number of purged bytes (sizeof(arg)==4)
        DQT_NPURGED_2 = -2  # only calculate number of purged bytes (sizeof(arg)==2)
        DQT_COMPILER = 0  # only detect compiler that generated the name
        DQT_NAME_TYPE = 1  # only detect the name type (data/code)
        DQT_FULL = 2  # really demangle
    cdef enum argreg_policy_t:  # ---------------------------------------------------------...
        ARGREGS_POLICY_UNDEFINED
        ARGREGS_GP_ONLY  # GP registers used for all arguments
        ARGREGS_INDEPENDENT  # FP/GP registers used separately (like gcc64)
        ARGREGS_BY_SLOTS  # fixed FP/GP register per each slot (like vc64)
        ARGREGS_FP_MASKS_GP  # FP register also consumes one or more GP regs...
        ARGREGS_MIPS_O32  # MIPS ABI o32
        ARGREGS_RISCV  # Risc-V API FP arguments are passed in GP...
    cdef enum reg_kind_t:  # Init registers (sequential)
        GPREGS
        FPREGS
    cdef enum abs_t:  # ---------------------------------------------------------...
        ABS_UNK
        ABS_NO
        ABS_YES
    cdef enum sclass_t:
        SC_UNK  # unknown
        SC_TYPE  # typedef
        SC_EXT  # extern
        SC_STAT  # static
        SC_REG  # register
        SC_AUTO  # auto
        SC_FRIEND  # friend
        SC_VIRT  # virtual
    cdef enum tinfo_code_t:  # Error codes various tinfo functions:
        TERR_OK = 0  # ok
        TERR_SAVE_ERROR = -1  # failed to save
        TERR_SERIALIZE = -2  # failed to serialize
        TERR_BAD_NAME = -3  # name %s is not acceptable
        TERR_BAD_ARG = -4  # bad argument
        TERR_BAD_TYPE = -5  # bad type
        TERR_BAD_SIZE = -6  # bad size %d
        TERR_BAD_INDEX = -7  # bad index %d
        TERR_BAD_ARRAY = -8  # arrays are forbidden as function arguments
        TERR_BAD_BF = -9  # bitfields are forbidden as function arguments
        TERR_BAD_OFFSET = -10  # bad member offset %s
        TERR_BAD_UNIVAR = -11  # unions cannot have variable sized members
        TERR_BAD_VARLAST = -12  # variable sized member must be the last member...
        TERR_OVERLAP = -13  # the member overlaps with other members that...
        TERR_BAD_SUBTYPE = -14  # recursive structure nesting is forbidden
        TERR_BAD_VALUE = -15  # value 0x%I64X is not acceptable
        TERR_NO_BMASK = -16  # bitmask 0x%I64X is not found
        TERR_BAD_BMASK = -17  # Bad enum member mask 0x%I64X. The specified...
        TERR_BAD_MSKVAL = -18  # bad bmask and value combination...
        TERR_BAD_REPR = -19  # bad or incompatible field representation
        TERR_GRP_NOEMPTY = -20  # could not delete group mask for not empty group 0x%I64X
        TERR_DUPNAME = -21  # duplicate name %s
        TERR_UNION_BF = -22  # unions cannot have bitfields
        TERR_BAD_TAH = -23  # bad bits in the type attributes (TAH bits)
        TERR_BAD_BASE = -24  # bad base class
        TERR_BAD_GAP = -25  # bad gap
        TERR_NESTED = -26  # recursive structure nesting is forbidden
        TERR_NOT_COMPAT = -27  # the new type is not compatible with the old type
        TERR_BAD_LAYOUT = -28  # failed to calculate the structure/union layout
        TERR_BAD_GROUPS = -29  # bad group sizes for bitmask enum
        TERR_BAD_SERIAL = -30  # enum value has too many serials
        TERR_ALIEN_NAME = -31  # enum member name is used in another enum
        TERR_STOCK = -32  # stock type info cannot be modified
        TERR_ENUM_SIZE = -33  # bad enum size
        TERR_NOT_IMPL = -34  # not implemented
        TERR_TYPE_WORSE = -35  # the new type is worse than the old type
        TERR_BAD_FX_SIZE = -36  # cannot extend struct beyond fixed size
        TERR_STRUCT_SIZE = -37  # bad fixed structure size
        TERR_NOT_FOUND = -38  # member not found
        TERR_COUNT = 39
    cdef enum stock_type_id_t:  # IDs for common types
        STI_PCHAR  # char *
        STI_PUCHAR  # uint8 *
        STI_PCCHAR  # const char *
        STI_PCUCHAR  # const uint8 *
        STI_PBYTE  # _BYTE *
        STI_PINT  # int *
        STI_PUINT  # unsigned int *
        STI_PVOID  # void *
        STI_PPVOID  # void **
        STI_PCVOID  # const void *
        STI_ACHAR  # char[]
        STI_AUCHAR  # uint8[]
        STI_ACCHAR  # const char[]
        STI_ACUCHAR  # const uint8[]
        STI_FPURGING  # void __userpurge(int)
        STI_FDELOP  # void __cdecl(void *)
        STI_MSGSEND  # void *(void *, const char *, ...)
        STI_AEABI_LCMP  # int __fastcall __pure(int64 x, int64 y)
        STI_AEABI_ULCMP  # int __fastcall __pure(uint64 x, uint64 y)
        STI_DONT_USE  # unused stock type id; should not be used
        STI_SIZE_T  # size_t
        STI_SSIZE_T  # ssize_t
        STI_AEABI_MEMCPY  # void __fastcall(void *, const void *, size_t)
        STI_AEABI_MEMSET  # void __fastcall(void *, size_t, int)
        STI_AEABI_MEMCLR  # void __fastcall(void *, size_t)
        STI_RTC_CHECK_2  # int16 __fastcall(int16 x)
        STI_RTC_CHECK_4  # int32 __fastcall(int32 x)
        STI_RTC_CHECK_8  # int64 __fastcall(int64 x)
        STI_COMPLEX64  # struct complex64_t { float real, imag; }
        STI_COMPLEX128  # struct complex128_t { double real, imag; }
        STI_PUNKNOWN  # _UNKNOWN *
        STI_LAST
    cdef enum etf_flag_t:  # Constants to be used the editing methods  @ {
        ETF_NO_SAVE = 1  # don't save to til (normally typerefs are saved...
        ETF_NO_LAYOUT = 2  # don't calc type layout before editing
        ETF_MAY_DESTROY = 4  # may destroy other members
        ETF_COMPATIBLE = 8  # new type must be compatible with the old
        ETF_FUNCARG = 16  # udm - member is a function argument (cannot...
        ETF_FORCENAME = 32  # anyway use name, see below for more usage description
        ETF_AUTONAME = 64  # udm - generate a member name if was not...
        ETF_BYTIL = 128  # udm - new type was created by the type subsystem
        ETF_NO_ARRAY = 256  # add_udm, set_udm_type - do not convert type to...
    cdef enum gtd_udt_t:  # Constants to be used with get_udt_details()
        GTD_CALC_LAYOUT  # calculate udt layout
        GTD_NO_LAYOUT  # don't calculate udt layout please note that...
        GTD_DEL_BITFLDS  # delete udt bitfields
    cdef enum gtd_func_t:  # Constants to be used with get_func_details()
        GTD_CALC_ARGLOCS  # calculate func arg locations
        GTD_NO_ARGLOCS  # don't calculate func arg locations please note...
    cdef enum gts_code_t:  # Constants to be used with get_size()
        GTS_NESTED  # nested type (embedded into a udt)
        GTS_BASECLASS  # is baseclass of a udt
    cdef enum gta_prop_t:  # Various type properties (properties are 64-bit scalar values)
        GTA_DECLALIGN  # declared alignment
        GTA_RESOLVE  # real type (fully resolve eventual type references)
        GTA_REALTYPE  # real type (do not fully resolve type refs)
        GTA_TYPE_SIGN  # get type sign
        GTA_FROM_SUBTIL  # is from a subtil (not from main til)
        GTA_IS_FORWARD  # is forward declaration?
        GTA_IS_FUNCPTR  # is a pointer to a function?
        GTA_ORDINAL  # get initial type ordinal
        GTA_FINAL_ORDINAL  # get final (resolved) type ordinal
        GTA_PTR_OBJ  # ptr: pointed type
        GTA_SAFE_PTR_OBJ  # ptr: pointed type or type itself
        GTA_ARRAY_ELEM  # array: array element
        GTA_ARRAY_NELEMS  # array: number of elements
        GTA_PTRARR_SUBTIF  # ptr &array : pointed object or array element
        GTA_PTRARR_SIZE  # ptr &array : get size of subtype
        GTA_UNPADDED_SIZE  # udt: sizeof baseclass when embedded into a...
        GTA_UDT_NMEMBERS  # udt: get number of udt members
        GTA_IS_SMALL_UDT  # udt: is small udt (can be passed in regs)
        GTA_ONEMEM_TYPE  # udt &array : object consisting of one member:...
        GTA_ENUM_BASE_TYPE  # enum: get enum base type
        GTA_FUNC_CC  # func: calling convention
        GTA_PURGED_BYTES  # func: number of purged bytes
        GTA_IS_HIGH_TYPE  # func: is high type
        GTA_FUNC_NARGS  # func: number of arguments
        GTA_FUNC_RET  # func: get function return type
        GTA_FUNC_ARG  # func: get type of function arg
        GTA_LAST_FUNC_ARG
        GTA_IS_SSE_TYPE  # is a SSE vector type?
        GTA_IS_ANON_UDT  # is anonymous struct/union?
        GTA_OBSOLETE1
        GTA_HAS_VFTABLE  # has vftable?
        GTA_IS_SHIFTED_PTR  # is a shifted pointer?
        GTA_IS_VARSTRUCT  # is a variable-size structure?
        GTA_IS_VARMEMBER  # is a variable member type?
        GTA_IS_TYPEDEF  # is a typedef?
        GTA_FINAL_ELEM  # if array, skip possible arrays, return a non-array type
        GTA_FORWARD_TYPE  # if a forward declaration, return either...
        GTA_BITMASK  # enum: is bitmask or regular enum
        GTA_ENUM_RADIX  # enum: get enum radix
        GTA_EDM  # enum: get enum type member by index
        GTA_EDM_BYVAL  # enum: find enum type member by value/serial/bmask
        GTA_EDM_BYNAME  # enum: find enum type member by name
        GTA_HAS_UNION  # has members of type "union"?
        GTA_UDM_TID  # udt: get member TID
        GTA_ALIAS  # get type alias
        GTA_EDM_TID  # enum: get enum member tid
        GTA_FRAME_FUNC  # frame: get function address for the frame
        GTA_UDM_IS_BYTIL  # udm: was the member created due to the type system
        GTA_OBSOLETE2
        GTA_EDT_NMEMBERS  # enum: get number of enum members
        GTA_ENUM_WIDTH  # enum: get enum width
        GTA_ENUM_REPR  # enum: get enum value representation
        GTA_UDT_BITS  # udt: get udt_type_data_t::taudt_bits
    cdef enum sta_prop_t:
        STA_DECLALIGN  # set declared alignment
        STA_TYPE_SIGN  # set type sign
        STA_UDT_ALIGN  # calculate udt field alignments
        STA_UDT_METHODS  # set udt member functions
        STA_RENAME  # set type name
        STA_COMMENT  # set type comment
        STA_CLR_MODIFS  # clear 'const/volatile' bits
        STA_SET_SDA  # udt: set struct alignment
        STA_SET_PACK  # udt: set struct packing
        STA_ADD_UDM  # udt: add a struct member
        STA_DEL_UDMS  # udt: del struct members
        STA_UDM_NAME  # udt: rename a struct member
        STA_UDM_TYPE  # udt: set type of a struct member
        STA_UDM_CMT  # udt: set comment of a struct member
        STA_UDM_REPR  # udt: set repr of a struct member
        STA_EXPAND_UDT  # udt: expand/shrink struct
        STA_ENUM_WIDTH  # enum: set the width of enum base type
        STA_ENUM_SIGN  # enum: set enum sign
        STA_BITMASK  # enum: make/unmake enum a bitmask
        STA_ENUM_REPR  # enum: set enum base repr
        STA_ADD_EDM  # enum: add enum member
        STA_DEL_EDMS  # enum: del enum members
        STA_EDM_NAME  # enum: rename enum member
        STA_EDM_CMT  # enum: set comment of an enum member
        STA_EDIT_EDM  # enum: change constant value and/or bitmask
        STA_ALIAS  # set type alias
        STA_ALIGNMENT  # set type alignment
        STA_UDM_SET_BYTIL  # udm: the member is created due to the type system
        STA_FIXED_STRUCT  # struct: use fixed member offsets
        STA_STRUCT_SIZE  # struct: set struct size (only for fixed structs)
        STA_FUNCARG_NAME  # func: rename a function argument
        STA_FUNCARG_TYPE  # func: set type of a function argument
        STA_FUNC_RETTYPE  # func: set function return type
        STA_DEL_FUNCARGS  # func: del function arguments
        STA_ADD_FUNCARG  # func: add function argument
        STA_FUNC_CC  # func: set calling convention
        STA_ENUM_RADIX  # enum: set enum radix
        STA_FUNCARG_LOC  # func: set argument location
        STA_FUNC_RETLOC  # func: set location of function return value
        STA_TUPLE  # struct: set as tuple
    cdef enum gta_pdata_t:
        GTP_NAME  # get referenced name
        GTP_NEXT_NAME  # get immediately next referenced name
        GTP_FINAL_NAME  # get final referenced name
        GTP_TIL  # get type library
        GTP_UDT_METHODS  # get udt member functions
        GTP_COMMENT  # get type comment
        GTP_RPTCMT  # get repeatable type comment
        GTP_BIT_BUCKETS  # get bit buckets
        GTP_NICE_NAME  # get the referenced name and apply regular...
    cdef enum bitmask_cvt_stance_t:  # Set or clear the 'bitmask' attribute of an enum. This...
        ENUMBM_OFF  # convert to ordinal enum
        ENUMBM_ON  # convert to bitmask enum
        ENUMBM_AUTO  # convert to bitmask if the outcome is nice and useful
    cdef enum format_functype_t:  # ---------------------------------------------------------...
        FMTFUNC_PRINTF
        FMTFUNC_SCANF
        FMTFUNC_STRFTIME
        FMTFUNC_STRFMON
    cdef enum update_type_t:  # See begin_type_updating()
        UTP_ENUM
        UTP_STRUCT

    # =========================================================================
    # Template Classes
    # =========================================================================
    cdef cppclass qvector[T]:
        qvector() except +
        qvector(const qvector[T]& x) except +
        T& operator[](size_t idx)
        T& at(size_t idx)
        T& front()
        T& back()
        size_t size() const
        bint empty() const
        size_t capacity() const
        void reserve(size_t cnt) except +
        void push_back(const T& x) except +
        void pop_back() except +
        void clear() except +
        void resize(size_t newsize) except +
        void swap(qvector[T]& r) except +
        ctypedef T* iterator
        ctypedef const T* const_iterator
        iterator begin()
        iterator end()
        iterator erase(iterator it) except +
        iterator insert(iterator it, const T& x) except +
        const T* find(const T& x) const
        bint has(const T& x) const
        bint add_unique(const T& x) except +
    cdef cppclass _qstring[T]:
        _qstring() except +
        _qstring(const T* ptr) except +
        _qstring(const _qstring[T]& r) except +
        size_t length() const
        size_t size() const
        bint empty() const
        const T* c_str() const
        T& operator[](size_t idx)
        void clear() except +
        void resize(size_t newsize, T c) except +
        _qstring[T]& append(const T* ptr) except +
        _qstring[T]& append(const _qstring[T]& r) except +
        size_t find(const T* str, size_t pos) const
        size_t find(T c, size_t pos) const
        _qstring[T] substr(size_t pos, size_t len) except +
        bint operator==(const _qstring[T]& r) const
        bint operator!=(const _qstring[T]& r) const
        int compare(const _qstring[T]& r) const
    cdef cppclass qstack[T](qvector[T]):
        T& top()
        void push(const T& x) except +
        T pop() except +
    cdef cppclass qrefcnt_t[T]:
        qrefcnt_t() except +
        qrefcnt_t(T* p) except +
        qrefcnt_t(const qrefcnt_t[T]& r) except +
        T& operator*()
        bint operator==(const qrefcnt_t[T]& r) const
        bint operator!=(const qrefcnt_t[T]& r) const
        void reset()
        T* release()
        T* get()

    # =========================================================================
    # Template Instantiation Typedefs
    # =========================================================================
    ctypedef _qstring[char] qstring  # IDA string type
    ctypedef qvector[uint8_t] bytevec_t  # Vector of bytes
    ctypedef qvector[int] intvec_t  # Vector of ints
    ctypedef qvector[ea_t] eavec_t  # Vector of addresses
    ctypedef qvector[sval_t] svalvec_t  # Vector of signed values
    ctypedef qvector[uval_t] uvalvec_t  # Vector of unsigned values
    ctypedef qvector[qstring] qstrvec_t  # Vector of strings
    ctypedef qvector[bint] boolvec_t  # Vector of bools
    ctypedef qvector[sval_t] casevec_t  # Vector of case values
    ctypedef _qstring[char] value_type
    ctypedef _qstring[char] iterator
    ctypedef qvector[size_t] sizevec_t
    ctypedef _qstring[uchar] qtype
    ctypedef _qstring[wchar16_t] qwstring
    ctypedef qvector[channel_redir_t] channel_redirs_t
    ctypedef qvector[plugin_option_t] plugin_option_vec_t
    ctypedef qvector[range_t] rangevec_base_t
    ctypedef qvector[rangeset_t] array_of_rangesets
    ctypedef qvector[rangeset_t*] rangeset_crefvec_t
    ctypedef qvector[callcnv_t] callcnvs_t
    ctypedef qvector[refinfo_desc_t] refinfo_desc_vec_t
    ctypedef qvector[compiled_binpat_t] compiled_binpat_vec_t
    ctypedef qvector[simpleline_t] strvec_t  # A collection of simple lines to populate a custom view....
    ctypedef qvector[sync_source_t] sync_source_vec_t
    ctypedef qvector[twinline_t] text_t  # A group of lines in a text window
    ctypedef qvector[twinline_t*] section_lines_refs_t  # ---------------------------------------------------------...
    ctypedef qvector[section_lines_refs_t] sections_lines_refs_t
    ctypedef qvector[line_rendering_output_entry_t*] line_rendering_output_entries_refs_t
    ctypedef qvector[cpidx_t] cpidxvec_t
    ctypedef qvector[line_section_t] line_sections_t
    ctypedef qvector[tagged_line_section_t] tagged_line_section_vec_t
    ctypedef qvector[chooser_row_info_t] chooser_row_info_vec_t
    ctypedef qvector[reg_info_t] reginfovec_t
    ctypedef qvector[reg_access_t] reg_access_vec_t
    ctypedef qvector[ea_name_t] ea_name_vec_t
    ctypedef qvector[type_attr_t] type_attrs_t  # this vector must be sorted by keys
    ctypedef qvector[argloc_t] arglocs_t
    ctypedef qvector[argpart_t] argpartvec_t
    ctypedef qvector[comp_t] compvec_t  # Collection of compiler descriptions
    ctypedef qvector[tinfo_t] tinfovec_t
    ctypedef qvector[simd_info_t] simd_info_vec_t
    ctypedef qvector[funcarg_t] funcargvec_t
    ctypedef qvector[edm_t] edmvec_t  # vector of enum values. for regular enums, no sorting...
    ctypedef qvector[regobj_t] regobjvec_t
    ctypedef qvector[valstr_t] valstrvec_t
    ctypedef qvector[uint32] ordvec_t  # @ }

    # =========================================================================
    # Forward Declarations
    # =========================================================================
    cdef cppclass cfgopt_handler2_t
    cdef cppclass cfgopt_handler3_t
    cdef cppclass cfgopt_handler_t
    cdef cppclass cliopt_handler_t
    cdef cppclass config_changed_cb_t
    cdef cppclass enum__t
    cdef cppclass fd_set
    cdef cppclass hook_cb_t
    cdef cppclass macro_ructor_t
    cdef cppclass qmutex_t
    cdef cppclass qsemaphore_t
    cdef cppclass regval_getter_t
    cdef cppclass string
    cdef cppclass testf_t
    cdef cppclass usage_printer_t
    cdef cppclass va_list

    # =========================================================================
    # Classes
    # =========================================================================
    cdef cppclass _opaque_pthread_attr_t:
        long __sig
    cdef cppclass _opaque_pthread_cond_t:
        long __sig
        _opaque_pthread_cond_t(_opaque_pthread_cond_t&)
        _opaque_pthread_cond_t(_opaque_pthread_cond_t&&)
        _opaque_pthread_cond_t& operator=(_opaque_pthread_cond_t&)
        _opaque_pthread_cond_t& operator=(_opaque_pthread_cond_t&&)
    cdef cppclass _opaque_pthread_condattr_t:
        long __sig
    cdef cppclass _opaque_pthread_mutex_t:
        long __sig
        _opaque_pthread_mutex_t(_opaque_pthread_mutex_t&)
        _opaque_pthread_mutex_t(_opaque_pthread_mutex_t&&)
        _opaque_pthread_mutex_t& operator=(_opaque_pthread_mutex_t&)
        _opaque_pthread_mutex_t& operator=(_opaque_pthread_mutex_t&&)
    cdef cppclass _opaque_pthread_mutexattr_t:
        long __sig
        _opaque_pthread_mutexattr_t()
        _opaque_pthread_mutexattr_t(_opaque_pthread_mutexattr_t&)
        _opaque_pthread_mutexattr_t(_opaque_pthread_mutexattr_t&&)
    cdef cppclass _opaque_pthread_once_t:
        long __sig
    cdef cppclass _opaque_pthread_rwlock_t:
        long __sig
    cdef cppclass _opaque_pthread_rwlockattr_t:
        long __sig
    cdef cppclass _opaque_pthread_t:
        long __sig
    cdef cppclass exception_ptr:
        exception_ptr()
        exception_ptr(nullptr_t)
        exception_ptr(exception_ptr&)
        exception_ptr& operator=(exception_ptr&)
    cdef cppclass logic_error:
        logic_error(char*)
        logic_error(logic_error&)
        logic_error& operator=(logic_error&)
        char* what() const
    cdef cppclass runtime_error:
        runtime_error(char*)
        runtime_error(runtime_error&)
        runtime_error& operator=(runtime_error&)
        char* what() const
    cdef cppclass domain_error:
        domain_error(char* __s)
        domain_error(domain_error&)
        domain_error& operator=(domain_error&)
    cdef cppclass invalid_argument:
        invalid_argument(char* __s)
        invalid_argument(invalid_argument&)
        invalid_argument& operator=(invalid_argument&)
    cdef cppclass length_error:
        length_error(char* __s)
        length_error(length_error&)
        length_error& operator=(length_error&)
    cdef cppclass out_of_range:
        out_of_range(char* __s)
        out_of_range(out_of_range&)
        out_of_range& operator=(out_of_range&)
    cdef cppclass range_error:
        range_error(char* __s)
        range_error(range_error&)
        range_error& operator=(range_error&)
    cdef cppclass overflow_error:
        overflow_error(char* __s)
        overflow_error(overflow_error&)
        overflow_error& operator=(overflow_error&)
    cdef cppclass underflow_error:
        underflow_error(char* __s)
        underflow_error(underflow_error&)
        underflow_error& operator=(underflow_error&)
    cdef cppclass timespec:
        long tv_nsec
    cdef cppclass ida_movable_type
    cdef cppclass qrefcnt_obj_t:  # ------------------------------------------------------------
        int refcnt  # counter
        qrefcnt_obj_t()  # Constructor
        void release()  # Call destructor. We use release() instead of opera
        qrefcnt_obj_t& operator=(qrefcnt_obj_t&)
        qrefcnt_obj_t& operator=(qrefcnt_obj_t&&)
    cdef cppclass reloc_info_t:  # Relocation information (relocatable objects - see ::relobj_t
        reloc_info_t()
        reloc_info_t(reloc_info_t&)
        reloc_info_t(reloc_info_t&&)
    cdef cppclass relobj_t:  # Relocatable object
        ea_t base  # current base
        reloc_info_t ri  # relocation info
        relobj_t()
        bint relocate(ea_t ea, bint mf)
    cdef cppclass qlist
    cdef cppclass listnode_t:
        listnode_t* next
        listnode_t* prev
        void fix_links(size_t len)
    cdef cppclass const_iterator
    cdef cppclass linput_t
    cdef cppclass channel_redir_t:  # Tools for command line parsing
        int fd  # channel number
        qstring file  # file name to redirect to/from. if empty, the chann
        int flags
        int start  # begin of the redirection string in the command lin
        int length  # length of the redirection string in the command li
        bint is_input() const  # @ }
        bint is_output() const
        bint is_append() const
        bint is_quoted() const
    cdef cppclass cliopt_t:
        char shortname
        char* longname
        char* help
        int nargs  # number of arguments. Can be 0, 1 or -1. If '-1', i
    cdef cppclass cliopts_t:
        qstring prog_name
        qstring epilog
        bint print_usage
        void add(cliopt_t* opts, size_t nopts)
        int apply(int argc, char** argv, void* ud)
        cliopt_t* find_short(char shortname) const
        cliopt_t* find_long(char* longname) const
        void usage(bint is_error) const
    cdef cppclass plugin_option_t:  # Named option, supports two kinds of options: string option: 
        qstring name
        qstring value
        char* get_value(char* default_value) const
        bint get_string(qstring* out, char* desired_name, char* default_value) const
        bint get_bool(bint* out, char* desired_name, bint default_value) const
    cdef cppclass plugin_options_t:
        plugin_option_t* find(qstring& name) const
        bint erase(char* name)
    cdef cppclass instant_dbgopts_t:  # Options for instant debugging
        qstring debmod  # name of debugger module
        qstring env  # config variables for debmod. example: DEFAULT_CPU=
        qstring host  # remote hostname (if remote debugging)
        qstring pass_  # password for the remote debugger server
        int port  # port number for the remote debugger server
        int pid  # process to attach to (-1: ask the user)
        int event_id  # event to trigger upon attaching
        bint attach  # should attach to a process?
    cdef cppclass launch_process_params_t:  # Information for launching a process with IDA API Note: all s
        size_t cb  # size of this structure
        int flags
        char* path  # file to run
        char* args  # command line arguments
        ssize_t in_handle  # handle for stdin or -1
        ssize_t out_handle  # handle for stdout or -1
        ssize_t err_handle  # handle for stderr or -1
        char* env  # zero separated environment variables that will be 
        char* startdir  # current directory for the new process
        void* info  # os specific info (on windows it points to PROCESS_
    cdef cppclass qmutex_locker_t:  # Mutex locker object. Will lock a given mutex upon creation a
        pass
    cdef cppclass fpvalue_t:  # ------------------------------------------------------------
        void clear()
        bint operator==(fpvalue_t& r) const
        bint operator!=(fpvalue_t& r) const
        bint operator<(fpvalue_t& r) const
        bint operator>(fpvalue_t& r) const
        bint operator<=(fpvalue_t& r) const
        bint operator>=(fpvalue_t& r) const
        int compare(fpvalue_t& r) const
        fpvalue_error_t from_half(uint16 fpval)  # Convert to the processor-independent representatio
        fpvalue_error_t from_float(float fpval)
        fpvalue_error_t from_double(double fpval)
        fpvalue_error_t to_half(uint16* fpval) const  # Convert from the processor-independent representat
        fpvalue_error_t to_float(float* fpval) const
        fpvalue_error_t to_double(double* fpval) const
        fpvalue_error_t from_10bytes(void* fpval)  # Conversions for 10-byte floating point values.
        fpvalue_error_t to_10bytes(void* fpval) const
        fpvalue_error_t from_12bytes(void* fpval)  # Conversions for 12-byte floating point values.
        fpvalue_error_t to_12bytes(void* fpval) const
        fpvalue_error_t from_str(char** p_str)  # Convert string to IEEE. 
        void to_str(char* buf, size_t bufsize, uint mode) const  # Convert IEEE to string. 
        void from_sval(sval_t x)  # Convert integer to IEEE
        void from_int64(int64 x)
        void from_uint64(uint64 x)
        fpvalue_error_t to_sval(sval_t* out, bint round) const  # Convert IEEE to integer (+-0.5 if round)
        fpvalue_error_t to_int64(int64* out, bint round) const
        fpvalue_error_t to_uint64(uint64* out, bint round) const
        fpvalue_error_t fadd(fpvalue_t& y)  # Arithmetic operations
        fpvalue_error_t fsub(fpvalue_t& y)
        fpvalue_error_t fmul(fpvalue_t& y)
        fpvalue_error_t fdiv(fpvalue_t& y)
        fpvalue_error_t mul_pow2(int32 power_of_2)  # Multiply by a power of 2.
        void eabs()  # Calculate absolute value.
        bint is_negative() const  # Is negative value?
        void negate()  # Negate.
        fpvalue_kind_t get_kind() const  # Get value kind.
    cdef cppclass range_t:  # ------------------------------------------------------------
        ea_t start_ea  # start_ea included
        ea_t end_ea  # end_ea excluded
        range_t(ea_t ea1, ea_t ea2)
        bint operator==(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator!=(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator<(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator>(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator<=(range_t& r) const  # Compare two range_t instances, based on the start_
        bint operator>=(range_t& r) const  # Compare two range_t instances, based on the start_
        int compare(range_t& r) const  # Compare two range_t instances, based on the start_
        bint contains(ea_t ea) const  # Is 'ea' in the address range?
        bint contains(range_t& r) const  # Is every ea in 'r' also in this range_t?
        bint overlaps(range_t& r) const  # Is there an ea in 'r' that is also in this range_t
        void clear()  # Set #start_ea, #end_ea to 0
        bint empty() const  # Is the size of the range_t < = 0?
        asize_t size() const  # Get #end_ea - #start_ea
        void intersect(range_t& r)  # Assign the range_t to the intersection between the
        void extend(ea_t ea)  # Ensure that the range_t includes 'ea'
        size_t print(char* buf, size_t bufsize) const  # Print the range_t. 
        range_t(range_t&)
        range_t(range_t&&)
        range_t& operator=(range_t&)
        range_t& operator=(range_t&&)
    cdef cppclass rangevec_t:
        pass
    cdef cppclass rangeset_t:  # An ordered set of non-overlapping address ranges
        rangeset_t()  # Constructor
        rangeset_t(range_t& range)  # Constructor - Initialize set with 'range'
        rangeset_t(rangeset_t& ivs)  # Constructor - Initialize set with 'ivs'
        rangeset_t& operator=(rangeset_t& ivs)
        void swap(rangeset_t& r)  # Set this = 'r' and 'r' = this. See qvector::swap()
        bint add(range_t& range)  # Add an address range to the set. If 'range' inters
        bint add(ea_t start, ea_t _end)  # Create a new range_t from 'start' and 'end' and ad
        bint add(rangeset_t& aset)  # Add each element of 'aset' to the set. 
        bint sub(range_t& range)  # Subtract an address range from the set. All subset
        bint sub(ea_t ea)  # Subtract an ea (an range of size 1) from the set. 
        bint sub(rangeset_t& aset)  # Subtract each range in 'aset' from the set 
        bint has_common(range_t& range) const  # Is there an ea in 'range' that is also in the rang
        bint includes(range_t& range) const  # Is every ea in 'range' contained in the rangeset?
        size_t print(char* buf, size_t bufsize) const  # Print each range_t in the rangeset
        asize_t count() const  # Size in bytes
        range_t& getrange(int idx) const  # Get the range_t at index 'idx'
        range_t& lastrange() const  # Get the last range_t in the set
        size_t nranges() const  # Get the number of range_t elements in the set
        bint empty() const  # Does the set have zero elements
        void clear()  # Delete all elements from the set. See qvector::cle
        bint has_common(rangeset_t& aset) const  # Does any element of 'aset' overlap with an element
        bint contains(ea_t ea) const  # Does an element of the rangeset contain 'ea'? See 
        bint contains(rangeset_t& aset) const  # Is every element in 'aset' contained in an element
        bint intersect(rangeset_t& aset)  # Set the rangeset to its intersection with 'aset'. 
        bint is_subset_of(rangeset_t& aset) const  # Is every element in the rangeset contained in an e
        bint is_equal(rangeset_t& aset) const  # Do this rangeset and 'aset' have identical element
        bint operator==(rangeset_t& aset) const
        bint operator!=(rangeset_t& aset) const
        const_iterator begin() const
        const_iterator end() const
        iterator begin()
        iterator end()
        const_iterator lower_bound(ea_t ea) const  # Get the first range that contains at least one ea_
        const_iterator upper_bound(ea_t ea) const  # Get the first range such that every ea_t value in 
        range_t* find_range(ea_t ea) const  # Get the element from the set that contains 'ea'. 
        range_t* cached_range() const  # When searching the rangeset, we keep a cached elem
        ea_t next_addr(ea_t ea) const  # Get the smallest ea_t value greater than 'ea' cont
        ea_t prev_addr(ea_t ea) const  # Get the largest ea_t value less than 'ea' containe
        ea_t next_range(ea_t ea) const  # Get the smallest ea_t value greater than 'ea' that
        ea_t prev_range(ea_t ea) const  # Get the largest ea_t value less than 'ea' that is 
        int move_chunk(ea_t from_, ea_t to, asize_t size)  # Subtract the address range (from, from+size) and a
        int check_move_args(ea_t from_, ea_t to, asize_t size)  # Check if the intended move_chunk() arguments are c
        rangevec_t& as_rangevec() const  # Return underlying rangevec_t object
    cdef cppclass range64_t:  # ------------------------------------------------------------
        uint64 start
        uint64 end
        range64_t(uint64 _start, uint64 _end)
        bint operator==(range64_t& r) const
        bint operator!=(range64_t& r) const
        bint operator<(range64_t& r) const
        bint operator>(range64_t& r) const
        bint operator<=(range64_t& r) const
        bint operator>=(range64_t& r) const
        int compare(range64_t& r) const
        bint contains(uint64 x) const
        bint contains(range64_t& r) const
        bint overlaps(range64_t& r) const
        void clear()
        bint empty() const
        uint64 size() const
        void intersect(range64_t& r)
        void extend(uint64 ea)
        range64_t(range64_t&)
        range64_t(range64_t&&)
    cdef cppclass range64vec_t:
        range64_t* find_range(uint64 off) const
    cdef cppclass plugin_t
    cdef cppclass compiler_info_t:  # Information about the target compiler
        comp_t id  # compiler id (see
        cm_t cm  # memory model and calling convention (see see also 
        uchar size_i  # sizeof(int)
        uchar size_b  # sizeof(bool)
        uchar size_e  # sizeof(enum)
        uchar defalign  # default alignment for structures
        uchar size_s  # short
        uchar size_l  # long
        uchar size_ll  # longlong
        uchar size_ldbl  # longdouble (if different from
        callcnv_t _new_callcnv  # do not access directly; use get_cc/set_cc
        callcnv_t get_cc() const
        void set_cc(callcnv_t cc)
        compiler_info_t()
        compiler_info_t(compiler_info_t&)
        compiler_info_t(compiler_info_t&&)
    cdef cppclass idainfo:
        char zero  # this field is not present in the database
        ushort version  # Version of database
        ushort s_genflags
        uint32 lflags
        uint32 database_change_count  # incremented after each byte and regular segment mo
        ushort filetype  # The input file type
        ushort ostype  # OS type the program is for bit definitions in libf
        ushort apptype  # Application type bit definitions in libfuncs.hpp
        uchar asmtype  # target assembler number
        uchar specsegs  # What format do special segments use? 0-unspecified
        uint32 af
        uint32 af2
        uval_t baseaddr  # base address of the program (paragraphs)
        sel_t start_ss  # selector of the initial stack segment
        sel_t start_cs  # selector of the segment with the main entry point
        ea_t start_ip  # IP register value at the start of program executio
        ea_t start_ea  # Linear address of program entry point
        ea_t start_sp  # SP register value at the start of program executio
        ea_t main  # address of main()
        ea_t min_ea  # current limits of program
        ea_t max_ea  # maxEA is excluded
        ea_t omin_ea  # original minEA (is set after loading the input fil
        ea_t omax_ea  # original maxEA (is set after loading the input fil
        ea_t lowoff  # Low  limit for offsets (used in calculation of 'vo
        ea_t highoff  # High limit for offsets (used in calculation of 'vo
        uval_t maxref  # Max tail for references
        range_t privrange  # Range of addresses reserved for internal use. Init
        sval_t netdelta  # Delta value to be added to all addresses for mappi
        uchar xrefnum  # Number of references to generate in the disassembl
        uchar type_xrefnum  # Number of references to generate in the struct & e
        uchar refcmtnum  # Number of comment lines to generate for refs to st
        uchar s_xrefflag
        ushort max_autoname_len  # max autogenerated name length (without zero byte)
        char nametype
        uint32 short_demnames  # short form of demangled names
        uint32 long_demnames  # long form of demangled names see demangle.h for de
        uchar demnames
        uchar listnames
        uchar indent  # Indentation for instructions
        uchar cmt_indent  # Indentation for comments
        ushort margin  # max length of data lines
        ushort lenxref  # max length of line with xrefs
        uint32 outflags
        uchar s_cmtflg
        uchar s_limiter
        short bin_prefix_size  # Number of instruction bytes (opcodes) to show in l
        uchar s_prefflag
        uchar strlit_flags
        uchar strlit_break  # string literal line break symbol
        char strlit_zeroes  # leading zeroes
        int32 strtype  # current ascii string type see nalt.hpp for string 
        uval_t strlit_sernum  # serial number
        uval_t datatypes  # data types allowed in data carousel
        compiler_info_t cc  # Target compiler
        uint32 abibits  # ABI features. Depends on info returned by get_abi_
        uint32 appcall_options  # appcall options, see idd.hpp
        uint32 padding
    cdef cppclass ea_helper_t:  # ------------------------------------------------------------
        uval_t mask32
        uval_t mask64
        uval_t mask
        int ea_size
        bint enabled  # can be disabled for old databases
        void setup(bint is_64bit)
        void disable()
        bint is_enabled() const
        sval_t ea2sval(uval_t v) const
        uval_t trunc_uval(uval_t v) const
        ea_t uval2ea(uval_t v) const
        bint fits_ea_space(ea_t ea) const
        bint fits_ea_space(range_t& r) const
        ea_t trunc_ea(ea_t ea) const
        ea_t ea_space_end() const
        ea_t to_ea(sel_t cs, uval_t ip) const
        ea_t fix_ea_tid(ea_t ea) const
        bint is_ea_add_ok(uval_t x, uval_t y) const
        sval_t sval_max() const
        sval_t sval_min() const
        bint like_badaddr(ea_t ea) const
        ea_t align_ea(ea_t ea, int size) const
        bint advance_ea(ea_t* ea, asize_t n) const
    cdef cppclass post_event_visitor_t:  # Implements action to take when the event was processed by th
        post_event_visitor_t& operator=(post_event_visitor_t&)
    cdef cppclass dbctx_t
    cdef cppclass idbattr_valmap_t:  # ------------------------------------------------------------
        uint64 value
        char* valname
    cdef cppclass idbattr_info_t:  # ------------------------------------------------------------
        char* name  # human-readable name. if null, then the field will 
        uintptr_t offset  # field position: offset within a structure (IDI_STR
        size_t width  # field width in bytes
        uint64 bitmask  # mask for bitfields (0-not bitfield)
        uchar tag  # tag of node value (if IDI_NODEVAL is set)
        idbattr_valmap_t* vmap  # array value=>name (terminated by empty element)
        char* individual_node  # individual node name (nullptr - use default)
        uint idi_flags
        uint32 maxsize  # max bytes reserved for storage in netnode
        bint is_node_altval() const
        bint is_node_supval() const
        bint is_node_valobj() const
        bint is_node_blob() const
        bint is_node_var() const
        bint is_struc_field() const
        bint is_cstr() const
        bint is_qstring() const
        bint is_bytearray() const
        bint is_buf_var() const
        bint is_decimal() const
        bint is_hexadecimal() const
        bint is_readonly_var() const
        bint is_incremented() const
        bint is_val_mapped() const
        bint is_hash() const
        bint use_hlpstruc() const
        bint is_bitmap() const
        bint is_onoff() const
        bint is_scalar_var() const
        bint is_bitfield() const
        bint is_boolean() const
        bint has_individual_node() const
        char* str_true() const
        char* str_false() const
        size_t ridx() const
        char* hashname() const
        bint operator<(idbattr_info_t& r) const
    cdef cppclass altadjust_visitor_t:  # visitor to be used by altadjust2 to skip the adjustment of s
        bint should_skip(nodeidx_t ea)
        altadjust_visitor_t& operator=(altadjust_visitor_t&)
        altadjust_visitor_t& operator=(altadjust_visitor_t&&)
    cdef cppclass netnode:  # Definition of the IDA database node. Note that the size of t
        netnode(nodeidx_t num)  # Constructor to create a netnode to access informat
        netnode(char* _name, size_t namlen, bint do_create)  # Construct an instance of netnode class to access t
        bint exist(char* _name)  # Does the netnode with the specified name exist?
        bint create(char* _name, size_t namlen)  # Create a named netnode. 
        bint create()  # Create unnamed netnode. 
        void kill()  # Delete a netnode with all information attached to 
        ssize_t get_name(qstring* buf) const  # Get the netnode name. 
        bint rename(char* newname, size_t namlen)  # Rename a netnode. 
        ssize_t valobj(void* buf, size_t bufsize) const  # Get value of netnode. Netnode values are arbitrary
        ssize_t valstr(qstring* buf) const  # Get string value of netnode. See explanations for 
        ssize_t valstr(char* buf, size_t bufsize) const
        bint set(void* value, size_t length)  # Set value of netnode. 
        bint delvalue()  # Delete value of netnode. 
        bint set_long(nodeidx_t x)  # Value of netnode as a long number:
        bint value_exists() const
        nodeidx_t long_value() const
        nodeidx_t altval(nodeidx_t alt, uchar tag) const  # Get altval element of the specified array. 
        nodeidx_t altval_ea(ea_t ea, uchar tag) const
        bint altset(nodeidx_t alt, nodeidx_t value, uchar tag)  # Set value of altval array. 
        bint altset_ea(ea_t ea, nodeidx_t value, uchar tag)
        bint altdel(nodeidx_t alt, uchar tag)  # Delete element of altval array. 
        bint altdel_ea(ea_t ea, uchar tag)
        bint easet(ea_t ea, ea_t addr, uchar tag)  # Store/retrieve/delete an address value in the netn
        ea_t eaget(ea_t ea, uchar tag) const
        bint eadel(ea_t ea, uchar tag)
        bint easet_idx(nodeidx_t idx, ea_t addr, uchar tag)
        ea_t eaget_idx(nodeidx_t idx, uchar tag)
        bint easet_idx8(uchar idx, ea_t addr, uchar tag)
        ea_t eaget_idx8(uchar idx, uchar tag) const
        bint eadel_idx8(uchar idx, uchar tag)
        nodeidx_t altfirst(uchar tag) const  # Get first existing element of altval array. 
        nodeidx_t altnext(nodeidx_t cur, uchar tag) const  # Get next existing element of altval array. 
        nodeidx_t altlast(uchar tag) const  # Get last element of altval array. 
        nodeidx_t altprev(nodeidx_t cur, uchar tag) const  # Get previous existing element of altval array. 
        size_t altshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the altval array elements. Moves the array e
        void altadjust2(nodeidx_t from_, nodeidx_t to, nodeidx_t size, altadjust_visitor_t& av)
        uchar charval(nodeidx_t alt, uchar tag) const  #  The following functions behave in the same manner
        bint charset(nodeidx_t alt, uchar val, uchar tag)
        bint chardel(nodeidx_t alt, uchar tag)
        uchar charval_ea(ea_t ea, uchar tag) const
        bint charset_ea(ea_t ea, uchar val, uchar tag)
        bint chardel_ea(ea_t ea, uchar tag)
        nodeidx_t charfirst(uchar tag) const
        nodeidx_t charnext(nodeidx_t cur, uchar tag) const
        nodeidx_t charlast(uchar tag) const
        nodeidx_t charprev(nodeidx_t cur, uchar tag) const
        size_t charshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)
        nodeidx_t altval_idx8(uchar alt, uchar tag) const  #  Another set of functions to work with altvals. Th
        bint altset_idx8(uchar alt, nodeidx_t val, uchar tag)
        bint altdel_idx8(uchar alt, uchar tag)
        nodeidx_t altfirst_idx8(uchar tag) const
        nodeidx_t altnext_idx8(uchar cur, uchar tag) const
        nodeidx_t altlast_idx8(uchar tag) const
        nodeidx_t altprev_idx8(uchar cur, uchar tag) const
        uchar charval_idx8(uchar alt, uchar tag) const  #  Another set of functions to work with altvals. - 
        bint charset_idx8(uchar alt, uchar val, uchar tag)
        bint chardel_idx8(uchar alt, uchar tag)
        nodeidx_t charfirst_idx8(uchar tag) const
        nodeidx_t charnext_idx8(uchar cur, uchar tag) const
        nodeidx_t charlast_idx8(uchar tag) const
        nodeidx_t charprev_idx8(uchar cur, uchar tag) const
        bint altdel()  # Delete all elements of altval array. This function
        bint altdel_all(uchar tag)  # Delete all elements of the specified altval array.
        ssize_t supval(nodeidx_t alt, void* buf, size_t bufsize, uchar tag) const  # Get value of the specified supval array element. N
        ssize_t supval_ea(ea_t ea, void* buf, size_t bufsize, uchar tag) const
        ssize_t supstr(qstring* buf, nodeidx_t alt, uchar tag) const  # Get string value of the specified supval array ele
        ssize_t supstr_ea(qstring* buf, ea_t ea, uchar tag) const
        ssize_t supstr(nodeidx_t alt, char* buf, size_t bufsize, uchar tag) const
        ssize_t supstr_ea(ea_t ea, char* buf, size_t bufsize, uchar tag) const
        bint supset(nodeidx_t alt, void* value, size_t length, uchar tag)  # Set value of supval array element. 
        bint supset_ea(ea_t ea, void* value, size_t length, uchar tag)
        bint supdel(nodeidx_t alt, uchar tag)  # Delete supval element. 
        bint supdel_ea(ea_t ea, uchar tag)
        nodeidx_t lower_bound(nodeidx_t cur, uchar tag) const  # Get lower bound of existing elements of supval arr
        nodeidx_t lower_bound_ea(ea_t ea, uchar tag) const
        nodeidx_t supfirst(uchar tag) const  # Get first existing element of supval array. 
        nodeidx_t supnext(nodeidx_t cur, uchar tag) const  # Get next existing element of supval array. 
        nodeidx_t suplast(uchar tag) const  # Get last existing element of supval array. 
        nodeidx_t supprev(nodeidx_t cur, uchar tag) const  # Get previous existing element of supval array. 
        size_t supshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the supval array elements. Moves the array e
        ssize_t supval_idx8(uchar alt, void* buf, size_t bufsize, uchar tag) const  #  The following functions behave in the same manner
        ssize_t supstr_idx8(uchar alt, char* buf, size_t bufsize, uchar tag) const
        ssize_t supstr_idx8(qstring* buf, uchar alt, uchar tag) const
        bint supset_idx8(uchar alt, void* value, size_t length, uchar tag)
        bint supdel_idx8(uchar alt, uchar tag)
        nodeidx_t lower_bound_idx8(uchar alt, uchar tag) const
        nodeidx_t supfirst_idx8(uchar tag) const
        nodeidx_t supnext_idx8(uchar alt, uchar tag) const
        nodeidx_t suplast_idx8(uchar tag) const
        nodeidx_t supprev_idx8(uchar alt, uchar tag) const
        bint supdel()  # Delete all elements of supval array. This function
        bint supdel_all(uchar tag)  # Delete all elements of the specified supval array.
        int supdel_range(nodeidx_t idx1, nodeidx_t idx2, uchar tag)  # Delete range of elements in the specified supval a
        int supdel_range_idx8(uchar idx1, uchar idx2, uchar tag)  # Same as above, but accepts 8-bit indexes
        ssize_t hashval(char* idx, void* buf, size_t bufsize, uchar tag) const  # Get value of the specified hash element. 
        ssize_t hashstr(qstring* buf, char* idx, uchar tag) const  # Similar to supstr(), but accepts a hash index
        ssize_t hashstr(char* idx, char* buf, size_t bufsize, uchar tag) const
        nodeidx_t hashval_long(char* idx, uchar tag) const  # Get value of the specified hash element. 
        bint hashset(char* idx, void* value, size_t length, uchar tag)  # Set value of hash element. 
        bint hashset(char* idx, nodeidx_t value, uchar tag)  # Set value of hash element to long value. 
        bint hashdel(char* idx, uchar tag)  # Delete hash element. 
        ssize_t hashfirst(qstring* buf, uchar tag) const  # Get first existing element of hash. 
        ssize_t hashfirst(char* buf, size_t bufsize, uchar tag) const
        ssize_t hashnext(qstring* buf, char* idx, uchar tag) const  # Get next existing element of hash. 
        ssize_t hashnext(char* idx, char* buf, size_t bufsize, uchar tag) const
        ssize_t hashlast(qstring* buf, uchar tag) const  # Get last existing element of hash. 
        ssize_t hashlast(char* buf, size_t bufsize, uchar tag) const
        ssize_t hashprev(qstring* buf, char* idx, uchar tag) const  # Get previous existing element of supval array. 
        ssize_t hashprev(char* idx, char* buf, size_t bufsize, uchar tag) const
        bint hashdel_all(uchar tag)  # Delete all elements of hash. This function deletes
        size_t blobsize(nodeidx_t _start, uchar tag)  # Get size of blob. 
        size_t blobsize_ea(ea_t ea, uchar tag)
        void* getblob(void* buf, size_t* bufsize, nodeidx_t _start, uchar tag)  # Get blob from a netnode. 
        void* getblob_ea(void* buf, size_t* bufsize, ea_t ea, uchar tag)
        ssize_t getblob(qstring* buf, nodeidx_t _start, uchar tag)  # Get blob from a netnode into a qstring* and make s
        bint setblob(void* buf, size_t size, nodeidx_t _start, uchar tag)  # Store a blob in a netnode. 
        bint setblob_ea(void* buf, size_t size, ea_t ea, uchar tag)
        int delblob(nodeidx_t _start, uchar tag)  # Delete a blob. 
        int delblob_ea(ea_t ea, uchar tag)
        size_t blobshift(nodeidx_t from_, nodeidx_t to, nodeidx_t size, uchar tag)  # Shift the blob array elements. Moves the array ele
        bint start()  # Get first netnode in the graph. Sets netnodenumber
        bint end()  # Get last netnode in the graph. Sets netnodenumber 
        bint next()  # Get next netnode in the graph. Sets netnodenumber 
        bint prev()  # Get prev netnode in the graph. Sets netnodenumber 
        size_t copyto(netnode destnode, nodeidx_t count)  # --------------------------------------------------
        size_t moveto(netnode destnode, nodeidx_t count)
        bint operator==(netnode& n) const  # --------------------------------------------------
        bint operator!=(netnode& n) const
        bint operator==(nodeidx_t x) const
        bint operator!=(nodeidx_t x) const
        bint inited()  # @ }
        bint is_available()
    cdef cppclass xrefpos_t:  #  @ { Position of cursor in the window with cross-references 
        ea_t ea
        uchar type  # the type of xref (::cref_t & ::dref_t)
        xrefpos_t(ea_t ea_, uchar type_)
        bint is_valid() const
    cdef cppclass array_parameters_t:  # ------------------------------------------------------------
        int32 flags
        int32 lineitems  # number of items on a line
        int32 alignment  # -1 - don't align. 0  - align automatically. else i
        array_parameters_t(int32 _f, int32 _l, int32 _a)
        bint is_default() const
        array_parameters_t& operator=(array_parameters_t&)
        array_parameters_t& operator=(array_parameters_t&&)
    cdef cppclass switch_info_t:  # ------------------------------------------------------------
        uint32 flags
        ushort ncases  # number of cases (excluding default)
        ea_t jumps  # jump table start address
        ea_t values  # values table address (if #SWI_SPARSE is set)
        uval_t lowcase  # the lowest value in cases
        ea_t defjump  # default jump address (#BADADDR if no default case)
        ea_t startea  # start of the switch idiom
        int jcases  # number of entries in the jump table (SWI_INDIRECT)
        sval_t ind_lowcase
        ea_t elbase  # element base
        int regnum  # the switch expression as a value of the REGNUM reg
        op_dtype_t regdtype  # size of the switch expression register as dtype
        uval_t custom  # information for custom tables (filled and used by 
        int version
        ea_t expr_ea  # the address before that the switch expression is i
        eavec_t marks  # the insns marked as IM_SWITCH. They are used to de
        int get_shift() const  # See #SWI_SHIFT_MASK. possible answers: 0..3.
        void set_shift(int shift)  # See #SWI_SHIFT_MASK
        int get_jtable_element_size() const
        void set_jtable_element_size(int size)
        int get_vtable_element_size() const
        void set_vtable_element_size(int size)
        bint has_default() const
        bint has_elbase() const
        bint is_sparse() const
        bint is_custom() const
        bint is_indirect() const
        bint is_subtract() const
        bint is_nolowcase() const
        bint use_std_table() const
        bint is_user_defined() const
        sval_t get_lowcase() const
        int get_jtable_size() const
        void set_jtable_size(int size)
        void set_elbase(ea_t base)
        void set_expr(int r, op_dtype_t dt)
        bint get_jrange_vrange(range_t* jrange, range_t* vrange) const  # get separate parts of the switch
        int get_version() const
        switch_info_t()
        void clear()
        switch_info_t(switch_info_t&)
        switch_info_t(switch_info_t&&)
        switch_info_t& operator=(switch_info_t&)
        switch_info_t& operator=(switch_info_t&&)
    cdef cppclass custom_data_type_ids_t:  #  @ { Information about custom data types
        int16 dtid  # data type id
        void set(tid_t tid)
        tid_t get_dtid() const
        custom_data_type_ids_t()
        custom_data_type_ids_t(custom_data_type_ids_t&)
        custom_data_type_ids_t(custom_data_type_ids_t&&)
    cdef cppclass refinfo_t:  # Information about a reference
        ea_t target  # reference target (#BADADDR-none)
        ea_t base  # base of reference (may be BADADDR)
        adiff_t tdelta  # offset from the target
        uint32 flags
        reftype_t type() const  # @ }
        bint is_target_optional() const
        bint no_base_xref() const
        bint is_pastend() const
        bint is_rvaoff() const
        bint is_custom() const
        bint is_subtract() const
        bint is_signed() const
        bint is_no_zeros() const
        bint is_no_ones() const
        bint is_selfref() const
        void set_type(reftype_t rt)  # RT can include REFINFO_CUSTOM bit
        void init(uint32 reft_and_flags, ea_t _base, ea_t _target, adiff_t _tdelta)  # init the structure with some default values reft_a
        refinfo_t()
        refinfo_t(refinfo_t&)
        refinfo_t(refinfo_t&&)
        refinfo_t& operator=(refinfo_t&)
        refinfo_t& operator=(refinfo_t&&)
    cdef cppclass custom_refinfo_handler_t:  # Manage a custom refinfo type Custom refinfos are usually use
        int32 cbsize  # size of this structure
        char* name  # Format name, must be unique
        char* desc  # Refinfo description to use in Ctrl-R dialog
        int props  # properties (currently 0)
    cdef cppclass refinfo_desc_t:  # Get descriptions of all standard and custom refinfo types.
        uint32 type  # Refinfo type, see Custom refinfo has REFINFO_CUSTO
        char* name  # Refinfo name
        char* desc  # Refinfo description to use in Ctrl-R dialog
    cdef cppclass strpath_t:  # Information for structure offsets. ids[0] contains the id of
        int len
        adiff_t delta
        strpath_t()
        strpath_t(strpath_t&)
        strpath_t(strpath_t&&)
    cdef cppclass enum_const_t:  # See opinfo_t::ec
        tid_t tid
        uchar serial
        enum_const_t()
        enum_const_t(enum_const_t&)
        enum_const_t(enum_const_t&&)
    cdef cppclass opinfo_t:  # Additional information about an operand type
        refinfo_t ri  # for offset members
        tid_t tid  # for struct, etc. members
        strpath_t path  # for stroff
        int32 strtype  # for strings (
        enum_const_t ec  # for enums
        custom_data_type_ids_t cd  # for custom data
        opinfo_t()
        opinfo_t(opinfo_t&)
        opinfo_t(opinfo_t&&)
    cdef cppclass printop_t:  # ------------------------------------------------------------
        uint32 unused  # not used anymore, use flags64 instead (kept for ba
        opinfo_t ti  # new operand type
        uchar features  # features this instance holds
        int suspop  # out: will be set by print_operand()
        aflags_t aflags  # additional aflags
        flags64_t flags  # new operand representation flags
        printop_t()
        bint is_ti_initialized() const
        void set_ti_initialized(bint v)
        bint is_aflags_initialized() const
        void set_aflags_initialized(bint v)
        bint is_f64() const
        opinfo_t* get_ti() const
    cdef cppclass segment_t:  # Describes a program segment
        uval_t name  # use get/set_segm_name() functions
        uval_t sclass  # use get/set_segm_class() functions
        uval_t orgbase  # this field is IDP dependent. you may keep your inf
        uchar align
        uchar comb
        uchar perm  #  (0 means no information)
        uchar bitness  # Number of bits in the segment addressing - 0: 16 b
        ushort flags
        sel_t sel  # segment selector - should be unique. You can't cha
        uchar type  # segment type (see The kernel treats different segm
        bgcolor_t color  # the segment color
        bint is_16bit() const  # Is a 16-bit segment?
        bint is_32bit() const  # Is a 32-bit segment?
        bint is_64bit() const  # Is a 64-bit segment?
        int abits() const  # Get number of address bits
        int abytes() const  # Get number of address bytes
        bint comorg() const  #  See #SFL_COMORG @ {
        void set_comorg()
        void clr_comorg()
        bint ob_ok() const  #  See #SFL_OBOK @ {
        void set_ob_ok()
        void clr_ob_ok()
        bint is_visible_segm() const  #  See #SFL_HIDDEN @ {
        void set_visible_segm(bint visible)
        bint is_debugger_segm() const  #  See #SFL_DEBUG @ {
        void set_debugger_segm(bint debseg)  # use ::change_segment_status() to change the segmen
        bint is_loader_segm() const  #  See #SFL_LOADER @ {
        void set_loader_segm(bint ldrseg)
        bint is_hidden_segtype() const  #  See #SFL_HIDETYPE @ {
        void set_hidden_segtype(bint hide)
        bint is_header_segm() const  #  See #SFL_HEADER @ {
        void set_header_segm(bint on)
        bint is_ephemeral_segm() const  # Ephemeral segments are not analyzed automatically 
        bint update()  # Update segment information. You must call this fun
        segment_t()  # Constructor
    cdef cppclass lock_segment:  # Helper class to lock a segment pointer so it stays valid
        lock_segment(segment_t* _segm)
    cdef cppclass user_defined_prefix_t:  # Class to generate user-defined prefixes in the disassembly l
        user_defined_prefix_t(size_t prefix_len, void* owner)  # Creating a user-defined prefix object installs it.
        void get_user_defined_prefix(qstring* vout, ea_t ea, insn_t& insn, int lnnum, int indent, char* line)  # Get a user-defined prefix. This callback must be o
        user_defined_prefix_t& operator=(user_defined_prefix_t&)
    cdef cppclass encoder_t:  # A helper class, to encode from UTF-8, -> into the target enc
        bint get_bom(bytevec_t* out) const
        bint encode(qstring* s) const  # returns true if conversion was entirely successful
        bint print(FILE* out, char* format) const  # encode()s the UTF-8 string composed by format + ar
        bint requires_binary_mode() const  # should a file be opened as binary, or should it ra
        encoder_t& operator=(encoder_t&)
    cdef cppclass octet_generator_t:  # Get 8 bits of the program at 'ea'. The main usage of this fu
        uint64 value
        ea_t ea
        int avail_bits
        bint high_byte_first
        octet_generator_t(ea_t _ea)
        void invert_byte_order()
    cdef cppclass data_type_t:  # Information about a data type
        int cbsize  # size of this structure
        void* ud  # user-defined data to be passed to callbacks
        int props  # properties
        char* name  # name of the data type. must be unique
        char* menu_name  # Visible data type name to use in menus if nullptr,
        char* hotkey  # Hotkey for the corresponding menu item if nullptr,
        char* asm_keyword  # keyword to use for this type in the assembly if nu
        asize_t value_size  # size of the value in bytes
        bint is_present_in_menus() const  # Should this type be shown in UI menus 
    cdef cppclass data_format_t:  # Information about a data format
        int32 cbsize  # size of this structure
        void* ud  # user-defined data to be passed to callbacks
        int props  # properties (currently 0)
        char* name  # Format name, must be unique
        char* menu_name  # Visible format name to use in menus if nullptr, no
        char* hotkey  # Hotkey for the corresponding menu item if nullptr,
        asize_t value_size  # size of the value in bytes 0 means any size is ok 
        int32 text_width  # Usual width of the text representation This value 
        bint is_present_in_menus() const  # Should this format be shown in UI menus 
    cdef cppclass compiled_binpat_t:  # ------------------------------------------------------------
        bytevec_t bytes
        bytevec_t mask
        rangevec_t strlits  # range of string literals, in _bytes_ ranges (not C
        int encidx
        compiled_binpat_t()
        bint all_bytes_defined() const
        void qclear()
        bint operator==(compiled_binpat_t& r) const
        bint operator!=(compiled_binpat_t& r) const
    cdef cppclass hidden_range_t:  # Hidden ranges - address ranges which can be replaced by thei
        char* description  # description to display if the range is collapsed
        char* header  # header lines to display if the range is expanded
        char* footer  # footer lines to display if the range is expanded
        bint visible  # the range state
        bgcolor_t color  # range color
    cdef cppclass stkpnt_t:  #   This file also contains routines for working with library 
        pass
    cdef cppclass regvar_t
    cdef cppclass llabel_t
    cdef cppclass regarg_t:  # Register argument description. regargs are destroyed when th
        int reg
        type_t* type
        char* name
        regarg_t()
        regarg_t(regarg_t& r)
        regarg_t& operator=(regarg_t& r)
        void swap(regarg_t& r)
    cdef cppclass func_t:  # ------------------------------------------------------------
        uint64 flags
        uval_t frame  # netnode id of frame structure - see frame.hpp
        asize_t frsize  # size of local variables part of frame in bytes. If
        ushort frregs  # size of saved registers in frame. This range is im
        asize_t argsize  # number of bytes purged from the stack upon returni
        asize_t fpd  # frame pointer delta. (usually 0, i.e. realBP==typi
        bgcolor_t color  # user defined function color
        uint32 pntqty  # number of SP change points
        stkpnt_t* points  # array of SP change points. use ...stkpnt...() func
        int regvarqty  # number of register variables (-1-not read in yet) 
        regvar_t* regvars  # array of register variables. this array is sorted 
        int llabelqty  # number of local labels
        llabel_t* llabels  # local labels array. this array shouldn't be modifi
        int regargqty  # number of register arguments. During analysis IDA 
        regarg_t* regargs  # unsorted array of register arguments. use ...regar
        int tailqty  # number of function tails
        range_t* tails  # array of tails, sorted by ea. use func_tail_iterat
        ea_t owner  # the address of the main function possessing this t
        int refqty  # number of referers
        ea_t* referers  # array of referers (function start addresses). use 
        bint is_far() const  # Is a far function?
        bint does_return() const  # Does function return?
        bint analyzed_sp() const  # Has SP-analysis been performed?
        bint need_prolog_analysis() const  # Needs prolog analysis?
        func_t(ea_t start, ea_t end, flags64_t f)
    cdef cppclass lock_func:  # Helper class to lock a function pointer so it stays valid
        lock_func(func_t* _pfn)
    cdef cppclass lock_func_with_tails_t:  # lint -esym(1788, lock_func_with_tails_t) referenced only by 
        lock_func_with_tails_t(func_t* pfn)
        lock_func_with_tails_t(lock_func_with_tails_t&)
    cdef cppclass func_tail_iterator_t:  # Class to enumerate all function tails sorted by addresses. E
        func_tail_iterator_t()
        func_tail_iterator_t(func_t* _pfn, ea_t ea)
        bint set(func_t* _pfn, ea_t ea)
        bint set_ea(ea_t ea)
        bint set_range(ea_t ea1, ea_t ea2)  # set an arbitrary range
        range_t& chunk() const
        bint first()
        bint last()
        bint next()
        bint prev()
        bint main()
        func_tail_iterator_t(func_tail_iterator_t&)
        func_tail_iterator_t& operator=(func_tail_iterator_t&)
    cdef cppclass func_item_iterator_t:  # Class to enumerate all function instructions and data sorted
        func_item_iterator_t()
        func_item_iterator_t(func_t* pfn, ea_t _ea)
        bint set(func_t* pfn, ea_t _ea)  # Set a function range. if pfn == nullptr then a seg
        bint set_range(ea_t ea1, ea_t ea2)  # Set an arbitrary range
        bint first()
        bint last()
        ea_t current() const
        bint set_ea(ea_t _ea)
        range_t& chunk() const
        bint next_addr()
        bint next_head()
        bint next_code()
        bint next_data()
        bint next_not_tail()
        bint prev_addr()
        bint prev_head()
        bint prev_code()
        bint prev_data()
        bint prev_not_tail()
        bint decode_prev_insn(insn_t* out)
        bint decode_preceding_insn(eavec_t* visited, bint* p_farref, insn_t* out)
        bint succ_code()
        func_item_iterator_t(func_item_iterator_t&)
        func_item_iterator_t(func_item_iterator_t&&)
        func_item_iterator_t& operator=(func_item_iterator_t&&)
    cdef cppclass func_parent_iterator_t:  # Class to enumerate all function parents sorted by addresses.
        func_parent_iterator_t()
        func_parent_iterator_t(func_t* _fnt)
        bint set(func_t* _fnt)
        ea_t parent() const
        bint first()
        bint last()
        bint next()
        bint prev()
        void reset_fnt(func_t* _fnt)
    cdef cppclass sreg_range_t
    cdef cppclass minsn_t
    cdef cppclass idc_value_t
    cdef cppclass snapshot_t
    cdef cppclass place_t:  #  (location_t would be a better name but it is too late to re
        int lnnum  # Number of line within the current object
        place_t()
        place_t(int ln)
        void print(qstring* vout, void* ud) const  # Generate a short description of the location. This
        uval_t touval(void* ud) const  # Map the location to a number. This mapping is used
        place_t* clone() const  # Clone the location. 
        void copyfrom(place_t* from_)  # Copy the specified location object to the current 
        place_t* makeplace(void* ud, uval_t x, int lnnum) const  # Map a number to a location. When the user clicks o
        int compare(place_t* t2) const  # Deprecated. Please consider compare2(const place_t
        void adjust(void* ud)  # Adjust the current location to point to a displaya
        bint prev(void* ud)  # Move to the previous displayable location. 
        bint next(void* ud)  # Move to the next displayable location. 
        bint beginning(void* ud) const  # Are we at the first displayable object?. 
        bint ending(void* ud) const  # Are we at the last displayable object?. 
        int generate(qstrvec_t* out, int* out_deflnnum, color_t* out_pfx_color, bgcolor_t* out_bgcolor, void* ud, int maxsize) const  # Generate text lines for the current location. 
        void serialize(bytevec_t* out) const  # Serialize this instance. It is fundamental that al
        bint deserialize(uchar** pptr, uchar* end)  # De-serialize into this instance. 'pptr' should be 
        int id() const  # Get the place's ID (i.e., the value returned by re
        char* name() const  # Get this place type name. All instances of a given
        ea_t toea() const  # Map the location to an ea_t. 
        bint rebase(int&)  # Rebase the place instance 
        place_t* enter(uint32*) const  # Visit this place, possibly 'unhiding' a section of
        void leave(uint32) const  # Leave this place, possibly 'hiding' a section of t
        int compare2(place_t* t2, void*) const  # Compare two locations except line numbers (lnnum).
        bint equals(place_t* t2, void* ud) const  # Compare two places for equality, ignoring line num
        place_t& operator=(place_t&)
        place_t& operator=(place_t&&)
        place_t(place_t&)
        place_t(place_t&&)
    cdef cppclass simpleline_t:  # Maintain basic information for a line in a custom view
        qstring line  # line text
        color_t color  # line prefix color
        bgcolor_t bgcolor  # line background color
        simpleline_t()
        simpleline_t(color_t c, char* str)
        simpleline_t(char* str)
        simpleline_t(qstring& str)
    cdef cppclass simpleline_place_t:  # A location in a view populated by a ::strvec_t
        uint32 n  # line number
        simpleline_place_t()
        simpleline_place_t(int _n)
        simpleline_place_t& operator=(simpleline_place_t&)
        simpleline_place_t& operator=(simpleline_place_t&&)
    cdef cppclass idaplace_t:  # A location in a disassembly view
        ea_t ea  # address
        idaplace_t()
        idaplace_t(ea_t x, int ln)
        idaplace_t& operator=(idaplace_t&)
        idaplace_t& operator=(idaplace_t&&)
        idaplace_t(idaplace_t&)
        idaplace_t(idaplace_t&&)
    cdef cppclass hexplace_gen_t:  # A helper, used as 'userdata' for generating lines in a hexpl
        bint is_editing() const
        bint is_editing_text() const
        bint is_curitem_changed() const
        bint is_edited_byte(ea_t ea, uint64* out_value) const
        byte_kind_t get_byte_value(ea_t ea, uint64* out_value, bint* out_edited) const
        void get_encoding(qstring* out) const
        ea_t get_cur_item_ea() const
        void get_cur_item_text(qstring* out) const
        int get_alignment() const
        int get_line_len(ea_t ea) const
        int get_items_per_line() const
        int get_bytes_per_item() const
        int get_item_width(ea_t ea) const
        data_kind_t get_data_kind() const
        int_format_t get_int_format() const
        bint has_central_separator() const
        bint show_text() const
        bint show_segaddr() const
        int get_bitness() const
        bint is_addr_kind() const
        hexplace_gen_t& operator=(hexplace_gen_t&)
        hexplace_gen_t& operator=(hexplace_gen_t&&)
    cdef cppclass hexplace_t:  # ------------------------------------------------------------
        hexplace_t(ea_t _ea, int ln)
        void out_one_item(int& ctx, hexplace_gen_t* hg, int itemno, color_t* color, color_t patch_or_edit) const
        size_t ea2str(char* buf, size_t bufsize, hexplace_gen_t* hg, ea_t ea)  # convert ea to text use seg:off if segment base is 
        hexplace_t& operator=(hexplace_t&)
        hexplace_t& operator=(hexplace_t&&)
    cdef cppclass tiplace_t:  # ------------------------------------------------------------
        uint32 ordinal
        tif_cursor_t cursor
        tiplace_t()
        tiplace_t(uint32 ord, tif_cursor_t c, int _lnnum)
        bint valid_ord() const
        void reset()
        bint is_header() const
        bint is_footer() const
        bint is_index() const
        void set_header()
        void set_footer()
        uint64 calc_udm_offset(void* ud, ssize_t* p_udmidx, int* p_bitoff) const  # for structs: calculate the offset that corresponds
        void set_index_by_offset(void* ud, uint64 offset)  # for structs: calculate the index that corresponds 
        type_t get_kind(void* ud) const  # get the kind of type this place represents 
        bint fill_type_ref(til_type_ref_t* out, void* ud) const  # fill the type information for use in actions 
        tiplace_t& operator=(tiplace_t&)
        tiplace_t& operator=(tiplace_t&&)
    cdef cppclass TWidget:  # A TWidget represents any user-facing widget present in IDA. 
        pass
    cdef cppclass sync_source_t:  # ------------------------------------------------------------
        sync_source_t()
        sync_source_t(TWidget* _view)
        sync_source_t(char* _regname)
        bint operator==(sync_source_t& _o) const
        bint operator!=(sync_source_t& _o) const
        bint is_register() const
        bint is_widget() const
        TWidget* get_widget() const
        char* get_register() const
        sync_source_t(sync_source_t&)
        sync_source_t(sync_source_t&&)
    cdef cppclass synced_group_t:
        bint has_widget(TWidget* v) const
        bint has_register(char* r) const
        bint has(sync_source_t& ss) const
    cdef cppclass twinpos_t:  # ------------------------------------------------------------
        place_t* at  # location in view
        int x  # cursor x
        twinpos_t(place_t* t, int x0)
        twinpos_t(twinpos_t&)
        twinpos_t(twinpos_t&&)
    cdef cppclass twinline_t:  # A line in a text window
        place_t* at  # location in view
        qstring line  # line contents
        color_t prefix_color  # line prefix color
        bgcolor_t bg_color  # line background color
        bint is_default  # is this the default line of the current location?
        twinline_t(place_t* t, color_t pc, bgcolor_t bc)
    cdef cppclass linearray_t:  # The group of lines corresponding to a single place within a 
        linearray_t(void* _ud)
        int set_place(place_t* new_at)  # Position the array. This function must be called b
        void copy_from(linearray_t* src)  # Copy information from one linearray to another. On
        place_t* get_place() const  # Get the current place. If called before down(), th
        bgcolor_t get_bg_color() const  # Get current background color. (the same behavior a
        bgcolor_t get_pfx_color() const  # Get current prefix color. (the same behavior as wi
        int get_dlnnum() const  # Get default line number. (the same behavior as wit
        int get_linecnt() const  # Get number of lines for the current place. (the sa
        void* userdata() const  # Get pointer to user data
        void set_userdata(void* userd)  # Change the user data
        bint beginning() const  # Are we at the beginning?
        bint ending() const  # Are we at the end?
        qstring* down()  # Get the next line going downwards. 'at' for the re
        qstring* up()  # Get the next line going upwards. 'at' for the retr
        void set_max_lines(int n)  # Set max number of lines to generate for a place. 0
        linearray_t(linearray_t&)
        linearray_t& operator=(linearray_t&)
    cdef cppclass lines_rendering_input_t:  # ------------------------------------------------------------
        int cb
        sections_lines_refs_t sections_lines  # references to the lines that are used for renderin
        synced_group_t* sync_group  # the 'synced' group 'widget' (see ui_get_lines_rend
    cdef cppclass line_rendering_output_entry_t:  # @ }
        twinline_t* line
        uint32 flags
        bgcolor_t bg_color  # 0x00000000: nothing 0xAABBGGRR: where AA is 0: BBG
        int cpx  # number of char to start from, valid if LROEF_CPS_R
        int nchars  # chars count, valid if LROEF_CPS_RANGE
        line_rendering_output_entry_t(twinline_t* _line, uint32 _flags, bgcolor_t _bg_color)
        line_rendering_output_entry_t(twinline_t* _line, int _cpx, int _nchars, uint32 _flags, bgcolor_t _bg_color)
        bint is_bg_color_empty() const
        bint is_bg_color_key() const
        bint is_bg_color_direct() const
        bint operator==(line_rendering_output_entry_t& r) const
        bint operator!=(line_rendering_output_entry_t& r) const
    cdef cppclass lines_rendering_output_t:  # ------------------------------------------------------------
        line_rendering_output_entries_refs_t entries
        uint32 flags
        void clear()
        bint operator==(lines_rendering_output_t& r) const
        bint operator!=(lines_rendering_output_t& r) const
        void swap(lines_rendering_output_t& r)
    cdef cppclass line_section_t:
        cpidx_t start
        cplen_t length
        bint contains(cpidx_t x) const
        bint is_open() const
        bint is_closed() const
        bint valid() const
        bint operator==(line_section_t& r) const
        bint operator!=(line_section_t& r) const
        line_section_t()
        line_section_t(line_section_t&)
        line_section_t(line_section_t&&)
    cdef cppclass tagged_line_section_t:  # ------------------------------------------------------------
        color_t tag
        tagged_line_section_t()
        bint operator==(tagged_line_section_t& r) const
        bint operator!=(tagged_line_section_t& r) const
        bint valid() const
        bint valid_in(qstring& in_) const
        bint substr(qstring* out, qstring& in_, tagged_line_section_t* end) const
    cdef cppclass tagged_line_sections_t:  # ------------------------------------------------------------
        tagged_line_section_t* first(color_t tag) const
        void sections_at(tagged_line_sections_t* out, cpidx_t x, color_t tag) const
        tagged_line_section_t* nearest_at(cpidx_t x, color_t tag) const  # For example, '// XREF: __loff_t/r _IO_FILE/r'  <on
        tagged_line_section_t* nearest_before(tagged_line_section_t& range, cpidx_t start, color_t tag) const  # For example, '// XREF: __loff_t/r _IO_FILE/r'  <on
        tagged_line_section_t* nearest_after(tagged_line_section_t& range, cpidx_t start, color_t tag) const
    cdef cppclass listing_location_t:  # Holds (live) data about a location being displayed in a list
        int cb
        int* loc
        qstring* text
        tagged_line_sections_t* tagged_sections
    cdef cppclass dirtree_t:  # @ }
        pass
    cdef cppclass chooser_item_attrs_t:  # Chooser item attributes
        int cb  # size of this structure. the callback must check th
        int flags
        bgcolor_t color  # item color
        chooser_item_attrs_t()
        void reset()
        bint operator==(chooser_item_attrs_t& other) const
        chooser_item_attrs_t(chooser_item_attrs_t&)
        chooser_item_attrs_t(chooser_item_attrs_t&&)
        chooser_item_attrs_t& operator=(chooser_item_attrs_t&)
        chooser_item_attrs_t& operator=(chooser_item_attrs_t&&)
    cdef cppclass chooser_row_info_t:  # Row data returned by get_chooser_rows().
        qstrvec_t texts  # texts, one per chooser column
        chooser_item_attrs_t attrs  # styling attributes
        int icon  # icon number
        bint operator==(chooser_row_info_t& other) const  # needed by pywraps
        bint operator!=(chooser_row_info_t& other) const
        chooser_row_info_t(chooser_row_info_t&)
        chooser_row_info_t(chooser_row_info_t&&)
        chooser_row_info_t& operator=(chooser_row_info_t&)
        chooser_row_info_t& operator=(chooser_row_info_t&&)
    cdef cppclass chooser_stdact_desc_t:
        int version  # to support the backward compatibility
        char* label  # see action_desc_t
        char* tooltip
        int icon
        chooser_stdact_desc_t(char* _label, char* _tooltip, int _icon)
        action_state_t ucb(action_update_ctx_t*)  # the update callback, see action_handler_t::update(
        chooser_stdact_desc_t& operator=(chooser_stdact_desc_t&)
    cdef cppclass chooser_base_t:  # Chooser object. #chooser
        int x0  # screen position,
        int y0
        int x1
        int y1
        int width  # (in chars)
        int height  # (in chars)
        char* title  # menu title (includes ptr to help). May have choose
        int columns  # number of columns
        int* widths  # column widths - low 16 bits of each value hold the
        char** header
        int icon  # default icon
        int deflt_col  # Column that will have focus.
        chooser_base_t(uint32 flags_, int columns_, int* widths_, char** header_, char* title_, uint16 flags2_)
        void call_destructor()  # called when the corresponding widget is destroyed.
        void* get_chooser_obj()  # get pointer to some custom data. 
        void* get_obj_id(size_t* len) const  # get the id of the chooser data. The choosers are t
        bint is_same(chooser_base_t* other) const  # do the current and the given objects hold the same
        bint can_ins() const  # is an operation allowed?
        bint can_del() const
        bint can_edit() const
        bint can_refresh() const
        bint popup_allowed(int stdact_idx) const  # is a standard action allowed?
        bint is_status_bar_hidden() const
        bint should_restore_geometry() const
        bint is_modal() const  # is choose modal?
        bint has_widget_lifecycle() const  # should chooser object be deleted when the widget g
        bint is_multi() const  # is multi-selection allowed?
        bint ask_item_attrs() const  # should chooser generate ui_get_chooser_item_attrs 
        bint is_force_default() const  # should selection of the already opened non-modal c
        uint get_builtin_number() const  # get number of the built-in chooser
        void set_ask_item_attrs(bint enable)  # enable or disable generation of ui_get_chooser_ite
        void check_version(uint32 ver) const  # check chooser version
        bint is_quick_filter_visible_initially() const  # should the quick filter be visible at startup?
        int get_quick_filter_initial_mode() const  # what mode should the quick filter initially be put
        bint has_dirtree() const  # does the chooser have the ability to show a tree v
        bint has_diff_capability() const  # does the chooser have the ability to participate i
        bint can_sort() const  # does chooser have sorting abilities?
        bint can_filter() const  # does chooser have filtering abilities?
        bint should_rename_trigger_edit() const  # should renaming trigger the 'edit' callback?
        bint is_dirtree_persisted() const  # is the chooser dirtree persisted?
        bint is_lazy_loaded() const  # is the chooser lazy-loaded?
        bint has_inode_to_index() const  # chooser_implement inode2index
        bint init()  # initialize the chooser and populate it. 
        size_t get_count() const  # get the number of elements in the chooser
        void get_row(qstrvec_t* out, int* out_icon, chooser_item_attrs_t* out_attrs, size_t n) const  # get a description of an element. 
        ea_t get_ea(size_t) const  # get the address of an element. When this function 
        void closed()  # The chooser window is closed.
    cdef cppclass renderer_pos_info_t:  # ------------------------------------------------------------
        int node  # the node, or -1 if the current renderer is not a g
        short cx  # the X coords of the character in the current line.
        short cy  # the Y coords of the character. When in graph mode:
        short sx  # the number of chars that are scrolled (flat mode o
        renderer_pos_info_t()  # Constructor
        bint operator==(renderer_pos_info_t& r) const
        bint operator!=(renderer_pos_info_t& r) const
    cdef cppclass selection_item_t:  # ------------------------------------------------------------
        pass
    cdef cppclass view_mouse_event_location_t:  # ------------------------------------------------------------
        ea_t ea  # flat view (rtype == ::TCCRT_FLAT)
        selection_item_t* item  # graph views (rtype != ::TCCRT_FLAT). nullptr if mo
    cdef cppclass view_mouse_event_t:  # Information about a mouse action within a view
        tcc_renderer_type_t rtype  # type of renderer that received the event
        uint32 x  # screen x coordinate
        uint32 y  # screen y coordinate
        location_t location  # location where event was generated
        view_event_state_t state  # contains information about what buttons are CURREN
        vme_button_t button  # represents which mouse button was responsible for 
        renderer_pos_info_t renderer_pos  # position where event was generated, relative to th
    cdef cppclass input_event_t:  # A representation of a user input
        int cb  # size marker
        input_event_kind_t kind  # the kind of event
        input_event_modifiers_t modifiers  # current keyboard (and mouse) modifiers
        TWidget* target  # the target widget
        void* source  # the source event, should it be required for detail
        input_event_shortcut_data_t shortcut
        input_event_keyboard_data_t keyboard
        input_event_mouse_data_t mouse
        input_event_t()
    cdef cppclass input_event_shortcut_data_t:
        char* action_name  # the action that will be triggered
    cdef cppclass input_event_keyboard_data_t:
        int key  # the key that was pressed to generate the event
    cdef cppclass input_event_mouse_data_t:
        int x  # the X position on the widget
        int y  # the Y position on the widget
        vme_button_t button  # the button that was pressed to generate the event
    cdef cppclass cli_t:  # Command line interpreter. Provides functionality for the com
        size_t size  # size of this structure
        int32 flags
        char* sname  # short name (displayed on the button)
        char* lname  # long name (displayed in the menu)
        char* hint  # hint for the input line
    cdef cppclass exec_request_t:  # Execute code in the main thread - to be used with execute_sy
        ssize_t code  # temporary location, used internally
        bint valid() const  # Can this request be executed?
        ssize_t execute()  # Callback to be executed. If this function raises a
        exec_request_t& operator=(exec_request_t&)
    cdef cppclass ui_request_t:  # ------------------------------------------------------------
        bint run()  # Run the UI request 
        ui_request_t& operator=(ui_request_t&)
    cdef cppclass ui_requests_t:  # List of UI requests. The ui_request_t is allocated by the ca
        ui_requests_t()
    cdef cppclass interactive_graph_t:  # @ }
        pass
    cdef cppclass screen_graph_selection_t
    cdef cppclass dirtree_selection_t
    cdef cppclass action_ctx_base_cur_sel_t:  # ------------------------------------------------------------
        twinpos_t from_  # start of selection
        twinpos_t to  # end of selection
        action_ctx_base_cur_sel_t()
        void reset()
    cdef cppclass action_ctx_base_t:  # ------------------------------------------------------------
        TWidget* widget
        twidget_type_t widget_type  # type of current widget
        qstring widget_title  # title of current widget
        chooser_base_t* chooser  # the underlying chooser_base_t (if 'widget' is a ch
        sizevec_t chooser_selection  # current chooser selection (0-based)
        char* action  # action name
        uint32 cur_flags  # Current address information. see
        ea_t cur_ea  # the current EA of the position in the view
        uval_t cur_value  # the possible address, or value the cursor is posit
        func_t* cur_func  # the current function
        func_t* cur_fchunk  # the current function chunk
        segment_t* cur_seg  # the current segment
        action_ctx_base_cur_sel_t cur_sel  # the currently selected range. also see #ACF_HAS_SE
        char* regname  # register name (if widget_type == BWN_CPUREGS and c
        TWidget* focus  # The focused widget in case it is not the 'form' it
        interactive_graph_t* graph  # the current graph (if in a graph view)
        screen_graph_selection_t* graph_selection  # the current graph selection (if in a graph view)
        selection_item_t* hovered  # the current item being hovered (if in a graph view
        dirtree_selection_t* dirtree_selection  # the current dirtree_t selection (if applicable)
        til_type_ref_t* type_ref  # a reference to the current type (if 'widget' is a 
        action_ctx_base_t()  # Constructor
        void reset()  # Invalidate all context info
        bint has_flag(uint32 flag) const  # Check if the given flag is set
    cdef cppclass action_handler_t:  # ------------------------------------------------------------
        int flags  # internal - for version management
        action_handler_t(int _f)  # Constructor
        int activate(action_activation_ctx_t* ctx)  # Activate an action. This function implements the c
        action_state_t update(action_update_ctx_t* ctx)  # Update an action. This is called when the context 
        action_handler_t& operator=(action_handler_t&)
    cdef cppclass action_desc_t:  # Describe an action to be registered (see register_action())
        int cb  # size of this structure
        char* name  # the internal name of the action; must be unique. a
        char* label  # the label of the action, possibly with an accelera
        action_handler_t* handler  # the action handler, for activating/updating. pleas
        void* owner  # either the plugin_t, or plugmod_t responsible for 
        char* shortcut  # an optional shortcut definition. E.g., "Ctrl+Enter
        char* tooltip  # an optional tooltip for the action
        int icon  # an optional icon ID to use
        int flags  # See
    cdef cppclass TPopupMenu:  # ------------------------------------------------------------
        pass
    cdef cppclass addon_info_t:  # Information about an installed add-on (e.g. a plugin)
        size_t cb  # size of this structure
        char* id  # product code, e.g. "com.hexrays.hexx86w". Must be 
        char* name  # descriptive name, e.g. "Hex-Rays x86 Decompiler (W
        char* producer  # e.g. "Hex-Rays SA"
        char* version  # version string, e.g. 1.5.110408
        char* url  # URL of the product http://www.hex-rays.com/decompi
        char* freeform  # any string, e.g. "Copyright (c) 2007-2025 Hex-Rays
        void* custom_data  # custom data (license ID etc). Can be nullptr. Not 
        size_t custom_size
        addon_info_t()  # Constructor
    cdef cppclass strarray_t:  # Map strings to integer values - see strarray()
        int code
        char* text
    cdef cppclass xrefblk_t:  # Structure to enumerate all xrefs. This structure provides a 
        ea_t from_  # the referencing address - filled by first_to(),nex
        ea_t to  # the referenced address - filled by first_from(), n
        bint iscode  # is code reference (::cref_t)? otherwise it is a da
        uchar type  # type of the last returned reference (::cref_t & ::
        bint user  # is user defined xref? otherwise defined by ida
        uchar _flags
        bint first_from(ea_t _from, int flags)  # Get first xref from the given address (store in #t
        bint next_from()  # Get next xref from address provided to first_from(
        bint first_to(ea_t _to, int flags)  # Get xref to given address (store in #from)
        bint next_to()  # Get next xref to address provided to first_to()
        bint next_from(ea_t _from, ea_t _to, int flags)  # Get xref from '_from' that comes after '_to'
        bint next_to(ea_t _from, ea_t _to, int flags)  # Get xref to '_to' that comes after '_from'
    cdef cppclass op_t:  # Operand of an instruction. This structure is filled by the a
        uchar n  # Number of operand (0,1,2). Initialized once at the
        optype_t type  # Type of operand (see
        char offb  # Offset of operand value from the instruction start
        char offo  # Same as #offb (some operands have 2 numeric values
        uchar flags
        op_dtype_t dtype  # Type of operand value (see This is the type of the
        uint16 reg  # number of register (::o_reg)
        uint16 phrase  # number of register phrase (::o_phrase,::o_displ). 
        uval_t value  # operand value (::o_imm) or outer displacement (::o
        ea_t addr  # virtual address pointed or used by the operand. (:
        ea_t specval  # This field may be used as you want.
        char specflag1  #  The following fields are used only in idp modules
        char specflag2
        char specflag3
        char specflag4
        void set_shown()  # Set operand to be shown
        void clr_shown()  # Set operand to hidden
        bint shown() const  # Is operand set to be shown?
        bint is_reg(int r) const  # Is register operand?
        bint is_imm(uval_t v) const  # Is immediate operand?
        op_t()  # @ }
        op_t(op_t&)
        op_t(op_t&&)
    cdef cppclass insn_t:
        ea_t cs  # Current segment base paragraph. Initialized by the
        ea_t ip  # Virtual address of the instruction (address within
        ea_t ea  # Linear address of the instruction. Initialized by 
        uint16 itype  # Internal code of instruction (only for canonical i
        uint16 size  # Size of instruction in bytes. The analyzer should 
        uint32 auxpref  # processor dependent field
        char segpref  # processor dependent field
        char insnpref  # processor dependent field
        int16 flags
        insn_t()
        bint is_canon_insn(processor_t& ph) const
        uint32 get_canon_feature(processor_t& ph) const
        char* get_canon_mnem(processor_t& ph) const
        bint is_macro() const  # Is a macro instruction?
        bint is_64bit() const
        uint8 get_next_byte()  #  The following functions return the next byte, 2 b
        uint16 get_next_word()
        uint32 get_next_dword()
        uint64 get_next_qword()
        bint create_op_data(ea_t ea_, int opoff, op_dtype_t dtype) const  # Convert to data using information about operand va
        bint create_op_data(ea_t ea_, op_t& op) const  # Convenient alias
        bint create_stkvar(op_t& x, adiff_t v, int flags_) const  # Create or modify a stack variable in the function 
        void add_cref(ea_t to, int opoff, cref_t type) const  # Add a code cross-reference from the instruction. 
        void add_dref(ea_t to, int opoff, dref_t type) const  # Add a data cross-reference from the instruction. S
        ea_t add_off_drefs(op_t& x, dref_t type, int outf) const  # Add xrefs for an operand of the instruction. This 
        insn_t(insn_t&)
        insn_t(insn_t&&)
    cdef cppclass outctx_base_t:  # ------------------------------------------------------------
        ea_helper_t& _eah
        ea_t insn_ea  # information for creating one line
        qstring outbuf  # buffer for the current output line once ready, it 
        ssize_t regname_idx  # to rename registers
        int suspop  # controls color for out_long()
        flags_t F32  # please use outctx_t::F instead
        uval_t* outvalues  # at least 2*UA_MAXOP elements
        int outvalue_getn_flags  # additional flags for print_operand()
        void* user_data  # pointer to be used by the processor module for any
        void* kern_data  # internal info used by the kernel
        qstrvec_t* lnar  # vector of output lines
        int lnar_maxsize  # max permitted size of lnar
        int default_lnnum  # index of the most important line in lnar
        qstring line_prefix  # usually segname:offset
        ssize_t prefix_len  # visible length of line_prefix
        int ctxflags  # various bits
        int ind0  # internal data used by the kernel
        ea_t cmt_ea  # indirectly referenced address (used to generate cm
        qstring cmtbuf  # indented comment
        char* cmtptr  # rest of indented comment
        color_t cmtcolor  # comment color
        bint only_main_line() const
        bint multiline() const
        bint force_code() const
        bint stack_view() const
        bint display_voids() const
        bint display_hidden() const
        void set_gen_xrefs(bint on)
        int get_xrefgen_state() const
        void set_gen_cmt(bint on)
        int get_cmtgen_state() const
        int get_binop_state() const
        void clr_gen_label()
        void set_gen_label()
        void set_gen_demangled_label()
        void set_comment_addr(ea_t ea)
        void set_dlbind_opnd()
        bint print_label_now() const
        int forbid_annotations()
        void restore_ctxflags(int saved_flags)
        outctx_base_t(ea_t ea, flags64_t flags, int _suspop)
        outctx_base_t& operator=(outctx_base_t&)
        size_t out_printf(char* format)  # Append a formatted string to the output string. 
        size_t nowarn_out_printf(char* format)
        flags64_t out_value(op_t& x, int outf)  # Output immediate value. Try to use this function t
        void out_symbol(char c)  # Output a character with #COLOR_SYMBOL color.
        void out_chars(char c, int n)  # Append a character multiple times
        void out_spaces(ssize_t len)  # Appends spaces to outbuf until its tag_strlen beco
        void add_spaces(qstring* buf, ssize_t len)
        void out_line(char* str, color_t color)  # Output a string with the specified color.
        void out_keyword(char* str)  # Output a string with #COLOR_KEYWORD color.
        void out_register(char* str)  # Output a character with #COLOR_REG color.
        void out_lvar(char* name, int width)  # Output local variable name with #COLOR_LOCNAME col
        void out_tagon(color_t tag)  # Output "turn color on" escape sequence
        void out_tagoff(color_t tag)  # Output "turn color off" escape sequence
        void out_addr_tag(ea_t ea)  # Output "address" escape sequence
        void out_colored_register_line(char* str)  # Output a colored line with register names in it. T
        void out_char(char c)  # Output one character. The character is output with
        void out_btoa(uval_t Word, char radix)  # Output a number with the specified base (binary, o
        void out_long(sval_t v, char radix)  #  Output a number with appropriate color. Low level
        bint out_name_expr(op_t& x, ea_t ea, adiff_t off)  # Output a name expression. 
        void close_comment()  # Generate the closing comment if if it required by 
        bint flush_outbuf(int indent)  # Move the contents of the output buffer to the line
        bint flush_buf(char* buf, int indent)  # Append contents of 'buf' to the line array. Behave
        int term_outctx(char* prefix)  # Finalize the output context. 
        bint gen_printf(int indent, char* format)  # printf-like function to add lines to the line arra
        bint gen_empty_line()  # Generate empty line. This function does nothing if
        bint gen_border_line(bint solid)  # Generate thin border line. This function does noth
        bint gen_cmt_line(char* format)  # Generate one non-indented comment line, colored wi
        bint gen_collapsed_line(char* format)  # Generate one non-indented comment line, colored wi
        bint gen_block_cmt(char* cmt, color_t color)  # Generate big non-indented comment lines. 
        void setup_outctx(char* prefix, int makeline_flags)  # --------------------------------------------------
        ssize_t retrieve_cmt()
        ssize_t retrieve_name(qstring*, color_t*)
        bint gen_xref_lines()
        void init_lines_array(qstrvec_t* answers, int maxsize)
        ssize_t get_stkvar(op_t& x, uval_t v, sval_t* vv, int* is_sp_based, tinfo_t* _frame)
        void gen_empty_line_without_annotations()
        flags64_t getF() const
    cdef cppclass outctx_t:  # ------------------------------------------------------------
        ea_t bin_ea  # Current binary format EA
        char bin_state  # =0 not generated,1-in process,2-finished
        int gl_bpsize  # binary line prefix size
        int bin_width
        insn_t insn  # valid only when ph.out_insn() is called
        qstring curlabel  # colorized and demangled label of the current addre
        printop_t* wif  # opinfo_t to use for out_value()
        procmod_t* procmod  # processor module and its description
        processor_t& ph
        asm_t& ash
        ea_t prefix_ea
        ea_t next_line_ea  # EA of next line (for prefix)
        flags64_t F
        outctx_t(procmod_t* p, processor_t& ph, asm_t& ash, ea_t ea, flags64_t flags, int _suspop, printop_t* _wif)
        void setup_outctx(char* prefix, int flags)
        int term_outctx(char* prefix)
        ssize_t retrieve_cmt()
        ssize_t retrieve_name(qstring*, color_t*)
        bint gen_xref_lines()
        void out_btoa(uval_t Word, char radix)
        void set_bin_state(int value)
        void out_mnem(int width, char* postfix)  # Output instruction mnemonic for 'insn' using infor
        void out_custom_mnem(char* mnem, int width, char* postfix)  # Output custom mnemonic for 'insn'. E.g. if it shou
        void out_mnemonic()  # Output instruction mnemonic using information in '
        bint out_one_operand(int n)  # Use this function to output an operand of an instr
        size_t get_immvals(uval_t* out, int i)  # Get the immediate values used at the specified add
        void out_immchar_cmts()  # Print all operand values as commented character co
        void gen_func_header(func_t* pfn)
        void gen_func_footer(func_t* pfn)
        void out_data(bint analyze_only)  # display data items and undefined bytes.
        bint out_specea(uchar segtype)  # generate declaration for item in a special segment
        void gen_header_extra()  # convenience functions for processor modules print 
        void gen_header(int flags, char* proc_name, char* proc_flavour)
        void out_fcref_names()  # Print addresses referenced *from* the specified ad
        outctx_t(outctx_t&)
        outctx_t& operator=(outctx_t&)
    cdef cppclass macro_constructor_t:  # Helper class for processor modules to build macro instructio
        size_t reserved
        bint construct_macro(insn_t* insn, bint enable)  # Construct a macro instruction. This function may b
        bint build_macro(insn_t* insn, bint may_go_forward)  # Try to extend the instruction. This function may m
        macro_constructor_t& operator=(macro_constructor_t&)
    cdef cppclass bitrange_t:  # ------------------------------------------------------------
        bitrange_t(uint16 bit_ofs, uint16 size_in_bits)  # Constructor
        void init(uint16 bit_ofs, uint16 size_in_bits)  # Initialize offset and size to given values
        void reset()  # Make the bitrange empty
        bint empty() const  # Is the bitrange empty?
        uint bitoff() const  # Get offset of 1st bit
        uint bitsize() const  # Get size of the value in bits
        uint bytesize() const  # Size of the value in bytes
        uint64 mask64() const  # Convert to mask of 64 bits
        bint has_common(bitrange_t& r) const  # Does have common bits with another bitrange?
        bint apply_mask(bitrange_t& subrange)  # Apply mask to a bitrange 
        void intersect(bitrange_t& r)  # Intersect two ranges
        void create_union(bitrange_t& r)  # Create union of 2 ranges including the hole betwee
        bint sub(bitrange_t& r)  # Subtract a bitrange
        void shift_down(uint cnt)  # Shift range down (left)
        void shift_up(uint cnt)  # Shift range up (right)
        bint extract(bytevec_t* dst, void* src, size_t src_size, bint is_mf) const  #  Extract a value from 'src' according to the bitra
        bint extract(void* dst, size_t dst_size, void* src, size_t src_size, bint is_mf) const
        bint inject(void* dst, size_t dst_size, void* src, size_t src_size, bint is_mf) const  #  Inject a value into 'dst' according to the bitran
        bint inject(void* dst, size_t dst_size, bytevec_t& src, bint is_mf) const
        bint operator==(bitrange_t& r) const  # @ }
        bint operator!=(bitrange_t& r) const  # @ }
        bint operator<(bitrange_t& r) const  # @ }
        bint operator>(bitrange_t& r) const  # @ }
        bint operator<=(bitrange_t& r) const  # @ }
        bint operator>=(bitrange_t& r) const  # @ }
        int compare(bitrange_t& r) const  # @ }
    cdef cppclass lexer_t:  # ------------------------------------------------------------
        pass
    cdef cppclass token_t
    cdef cppclass jvalue_t
    cdef cppclass cfgopt_t:  # ------------------------------------------------------------
        char* name
        void* ptr
        size_t mbroff  # offset of a structure member
        int flags
        size_t buf_size
        num_range_t num_range
        uint32 bit_flags
        params_t params
        void* mbroff_obj
        cfgopt_t(char* _n, char* _p, size_t _sz, bint _long)  # IDPOPT_STR
        cfgopt_t(char* _n, qstring* _p, bint _long)
        cfgopt_t(char* _n, int* _p)  # IDPOPT_NUM
        cfgopt_t(char* _n, uint* _p)
        cfgopt_t(char* _n, char* _p)
        cfgopt_t(char* _n, uchar* _p)
        cfgopt_t(char* _n, short* _p)
        cfgopt_t(char* _n, ushort* _p)
        cfgopt_t(char* _n, int* _p, int _min, int _max)  # IDPOPT_NUM + ranges
        cfgopt_t(char* _n, uint* _p, uint _min, uint _max)
        cfgopt_t(char* _n, char* _p, char _min, char _max)
        cfgopt_t(char* _n, uchar* _p, uchar _min, uchar _max)
        cfgopt_t(char* _n, short* _p, short _min, short _max)
        cfgopt_t(char* _n, ushort* _p, ushort _min, ushort _max)
        cfgopt_t(char* _n, bint* _p, bint _flags)  # IDPOPT_BIT
        cfgopt_t(char* _n, uchar* _p, uchar _flags)
        cfgopt_t(char* _n, ushort* _p, ushort _flags)
        cfgopt_t(char* _n, uint32* _p, uint32 _flags)
        cfgopt_t(char* _n, int64* _p)  # IDPOPT_I64
        cfgopt_t(char* _n, uint64* _p)
        cfgopt_t(char* _n, int64* _p, int64 _min, int64 _max)  # IDPOPT_I64 + ranges
        cfgopt_t(char* _n, uint64* _p, uint64 _min, uint64 _max)
        cfgopt_t(char* _n, jvalue_t* _p)  # IDPOPT_JVL
        int type() const
        int qualifier() const
        bint is_mbroff() const
        bint get_number(int64* out, lexer_t* lx, token_t& _t, int range_bit, int usign_bit) const
        char* apply(int vtype, void* vdata, void* obj) const
        char* apply(lexer_t* lx, int vtype, void* vdata, void* obj) const
    cdef cppclass num_range_t:
        int64 minval
        int64 maxval
        num_range_t(int64 _min, int64 _max)
        num_range_t(num_range_t&)
        num_range_t(num_range_t&&)
    cdef cppclass params_t:
        int64 p1
        int64 p2
        params_t(int64 _p1, int64 _p2)
        params_t(params_t&)
        params_t(params_t&&)
    cdef cppclass cfgopt_set_t:  # ------------------------------------------------------------
        cfgopt_t* opts
        size_t nopts
        void* obj
    cdef cppclass cfgopt_set_vec_t:
        pass
    cdef cppclass regval_t
    cdef cppclass stkpnts_t
    cdef cppclass call_stack_t
    cdef cppclass reg_finder_t
    cdef cppclass merge_data_t
    cdef cppclass idasgn_t
    cdef cppclass bytes_t:  # ------------------------------------------------------------
        uchar len
        uchar* bytes
    cdef cppclass instruc_t:  # ------------------------------------------------------------
        char* name  # instruction name
        uint32 feature  # combination of
    cdef cppclass asm_t:  # ============================================================
        uint32 flag
        uint16 uflag  # user defined flags (local only for IDP) you may de
        char* name  # Assembler name (displayed in menus)
        help_t help  # Help screen number, 0 - no help
        char** header  # array of automatically generated header lines they
        char* origin  # org directive
        char* end  # end directive
        char* cmnt  # comment string (see also cmnt2)
        char ascsep  # string literal delimiter
        char accsep  # char constant delimiter
        char* esccodes  # special chars that cannot appear as is in string a
        char* a_ascii  # string literal directive
        char* a_byte  # byte directive
        char* a_word  # word directive
        char* a_dword  # nullptr if not allowed
        char* a_qword  # nullptr if not allowed
        char* a_oword  # nullptr if not allowed
        char* a_float  # float;  4bytes; nullptr if not allowed
        char* a_double  # double; 8bytes; nullptr if not allowed
        char* a_tbyte  # long double;    nullptr if not allowed
        char* a_packreal  # packed decimal real nullptr if not allowed
        char* a_dups  # array keyword. the following sequences may appear:
        char* a_bss  # uninitialized data directive should include '%s' f
        char* a_equ  # 'equ' Used if AS_UNEQU is set
        char* a_seg  # 'seg ' prefix (example: push seg seg001)
        char* a_curip  # current IP (instruction pointer) symbol in assembl
        char* a_public  # "public" name keyword. nullptr-use default, ""-do 
        char* a_weak  # "weak"   name keyword. nullptr-use default, ""-do 
        char* a_extrn  # "extern" name keyword
        char* a_comdef  # "comm" (communal variable)
        char* a_align  # "align" keyword
        char lbrace  # left brace used in complex expressions
        char rbrace  # right brace used in complex expressions
        char* a_mod  # %  mod     assembler time operation
        char* a_band  #  & bit and assembler time operation
        char* a_bor  # |  bit or  assembler time operation
        char* a_xor  # ^  bit xor assembler time operation
        char* a_bnot  # ~  bit not assembler time operation
        char* a_shl  #  < < shift left assembler time operation
        char* a_shr  # >> shift right assembler time operation
        char* a_sizeof_fmt  # size of type (format string)
        uint32 flag2
        char* cmnt2  # comment close string (usually nullptr) this is use
        char* low8  # low8 operation, should contain %s for the operand
        char* high8  # high8
        char* low16  # low16
        char* high16  # high16
        char* a_include_fmt  # the include directive (format string)
        char* a_vstruc_fmt  # if a named item is a structure and displayed in th
        char* a_rva  # 'rva' keyword for image based offsets (see #REFINF
        char* a_yword  # 32-byte (256-bit) data; nullptr if not allowed req
        char* a_zword  # 64-byte (512-bit) data; nullptr if not allowed req
    cdef cppclass proc_def_t:  # forward declarations for notification helpers
        pass
    cdef cppclass elf_loader_t
    cdef cppclass reader_t
    cdef cppclass extlang_t
    cdef cppclass qflow_chart_t
    cdef cppclass libfunc_t
    cdef cppclass fixup_data_t
    cdef cppclass idd_opinfo_t
    cdef cppclass event_listener_t:
        size_t listener_flags  # reserved
        event_listener_t& operator=(event_listener_t&)
        event_listener_t()
        event_listener_t(event_listener_t&)
    cdef cppclass processor_t:  # ============================================================
        int32 version  # Expected kernel version, should be #IDP_INTERFACE_
        int32 id  # one of
        uint32 flag  # an ORed combination of
        uint32 flag2  # an ORed combination of
        int32 cnbits  # Number of bits in a byte for code segments (usuall
        int32 dnbits  # Number of bits in a byte for non-code segments (us
        char** psnames  # short processor names (nullptr terminated). Each n
        char** plnames  # long processor names (nullptr terminated). No rest
        asm_t** assemblers  # pointer to array of target assembler definitions. 
        char** reg_names  # array of register names
        int32 regs_num  # number of registers
        int32 reg_first_sreg  # number of first segment register
        int32 reg_last_sreg  # number of last segment register
        int32 segreg_size  # size of a segment register in bytes
        int32 reg_code_sreg  # number of CS register
        int32 reg_data_sreg  # number of DS register
        bytes_t* codestart  # Array of typical code start sequences. This array 
        bytes_t* retcodes  # Array of 'return' instruction opcodes. This array 
        int32 instruc_start  # icode of the first instruction
        int32 instruc_end  # icode of the last instruction + 1
        instruc_t* instruc  # Array of instructions
        size_t tbyte_size  # Size of long double (tbyte) for this processor (me
        int32 icode_return  # Icode of return instruction. It is ok to give any 
        void* unused_slot  # Reserved, currently equals to nullptr
        bint has_idp_opts() const
        bint has_segregs() const
        bint use32() const
        bint use64() const
        bint ti() const
        bint stkup() const
        bint use_tbyte() const
        bint use_mappings() const
        bint has_code16_bit() const
        bint supports_macros() const
        bint supports_calcrel() const
        bint calcrel_in_bits() const
        int get_default_segm_bitness(bint is_64bit_app) const  # Get default segment bitness 
        int cbsize()  #  Number of 8bit bytes required to hold one byte of
        int dbsize()
        int get_proc_index()  # @ }
        ssize_t notify(event_t event_code)
        ssize_t init(char* idp_modname)  # Notification helpers, should be used instead of di
        ssize_t term()
        ssize_t newprc(int pnum, bint keep_cfg)
        ssize_t newasm(int asmnum)
        ssize_t asm_installed(int asmnum)
        ssize_t newfile(char* fname)
        ssize_t oldfile(char* fname)
        ssize_t newbinary(char* filename, int fileoff, ea_t basepara, ea_t binoff, uint64 nbytes)
        ssize_t endbinary(bint ok)
        ssize_t creating_segm(segment_t* seg)
        ssize_t assemble(uchar* _bin, ea_t ea, ea_t cs, ea_t ip, bint _use32, char* line)
        ssize_t ana_insn(insn_t* out)
        ssize_t emu_insn(insn_t& insn)
        ssize_t out_header(outctx_t& ctx)
        ssize_t out_footer(outctx_t& ctx)
        ssize_t out_segstart(outctx_t& ctx, segment_t* seg)
        ssize_t out_segend(outctx_t& ctx, segment_t* seg)
        ssize_t out_assumes(outctx_t& ctx)
        ssize_t out_insn(outctx_t& ctx)
        ssize_t out_mnem(outctx_t& ctx)
        ssize_t out_operand(outctx_t& ctx, op_t& op)
        ssize_t out_data(outctx_t& ctx, bint analyze_only)
        ssize_t out_label(outctx_t& ctx, char* colored_name)
        ssize_t out_special_item(outctx_t& ctx, uchar segtype)
        ssize_t gen_stkvar_def(outctx_t& ctx, udm_t* mptr, sval_t v, tid_t tid)
        ssize_t gen_regvar_def(outctx_t& ctx, regvar_t* v)
        ssize_t gen_src_file_lnnum(outctx_t& ctx, char* file, size_t lnnum)
        ssize_t rename(ea_t ea, char* new_name, int flags)
        ssize_t may_show_sreg(ea_t current_ea)
        ssize_t coagulate(ea_t start_ea)
        void auto_queue_empty(int type)
        ssize_t func_bounds(int* possible_return_code, func_t* pfn, ea_t max_func_end_ea)
        ssize_t may_be_func(insn_t& insn, int state)
        ssize_t is_sane_insn(insn_t& insn, int no_crefs)
        ssize_t cmp_operands(op_t& op1, op_t& op2)
        ssize_t is_jump_func(func_t* pfn, ea_t* jump_target, ea_t* func_pointer)
        ssize_t is_basic_block_end(insn_t& insn, bint call_insn_stops_block)
        ssize_t getreg(uval_t* rv, int regnum)
        ssize_t undefine(ea_t ea)
        ssize_t moving_segm(segment_t* seg, ea_t to, int flags)
        ssize_t is_sp_based(insn_t& insn, op_t& x)
        ssize_t is_far_jump(int icode)
        ssize_t is_call_insn(insn_t& insn)
        ssize_t is_ret_insn(insn_t& insn, uchar iri_flags)
        ssize_t is_align_insn(ea_t ea)
        ssize_t is_addr_insn(int* type, insn_t& insn)
        ssize_t can_have_type(op_t& op)
        ssize_t get_stkvar_scale_factor()
        ssize_t demangle_name(int32* res, qstring* out, char* name, uint32 disable_mask, int demreq)
        ssize_t create_flat_group(ea_t image_base, int bitness, sel_t dataseg_sel)
        ssize_t is_alloca_probe(ea_t ea)
        ssize_t get_reg_name(qstring* buf, int reg, size_t width, int reghi)
        ssize_t gen_asm_or_lst(bint starting, FILE* fp, bint is_asm, int flags, void* outline)
        ssize_t gen_map_file(int* nlines, FILE* fp)
        ssize_t get_autocmt(qstring* buf, insn_t& insn)
        ssize_t loader_elf_machine(linput_t* li, int machine_type, char** p_procname, proc_def_t** p_pd, elf_loader_t* ldr, reader_t* reader)
        ssize_t is_indirect_jump(insn_t& insn)
        ssize_t verify_noreturn(func_t* pfn)
        ssize_t verify_sp(func_t* pfn)
        ssize_t create_func_frame(func_t* pfn)
        ssize_t get_frame_retsize(int* retsize, func_t* pfn)
        ssize_t analyze_prolog(ea_t fct_ea)
        ssize_t calc_spdelta(sval_t* spdelta, insn_t& ins)
        ssize_t calcrel(bytevec_t* out_relbits, size_t* out_consumed, ea_t ea)
        ssize_t get_reg_accesses(reg_accesses_t* accvec, insn_t& insn, int flags)
        ssize_t is_control_flow_guard(int* p_reg, insn_t* insn)
        ssize_t find_reg_value(uval_t* out, insn_t& insn, int reg)
        ssize_t find_op_value(uval_t* out, insn_t& insn, int op)
        ssize_t treat_hindering_item(ea_t hindering_item_ea, flags64_t new_item_flags, ea_t new_item_ea, asize_t new_item_length)
        ssize_t extract_address(ea_t* out_ea, ea_t screen_ea, char* string, size_t x)
        ssize_t str2reg(char* regname)
        ssize_t is_switch(switch_info_t* si, insn_t& insn)
        ssize_t create_switch_xrefs(ea_t jumpea, switch_info_t& si)
        ssize_t calc_switch_cases(void* casevec, eavec_t* targets, ea_t insn_ea, switch_info_t& si)
        ssize_t get_bg_color(bgcolor_t* color, ea_t ea)
        ssize_t validate_flirt_func(ea_t start_ea, char* funcname)
        ssize_t get_operand_string(qstring* buf, insn_t& insn, int opnum)
        ssize_t add_cref(ea_t from_, ea_t to, cref_t type)
        ssize_t add_dref(ea_t from_, ea_t to, dref_t type)
        ssize_t del_cref(ea_t from_, ea_t to, bint expand)
        ssize_t del_dref(ea_t from_, ea_t to)
        ssize_t coagulate_dref(ea_t from_, ea_t to, bint may_define, ea_t* code_ea)
        char* set_idp_options(char* keyword, int vtype, void* value, bint idb_loaded)
        ssize_t set_proc_options(char* options, int confidence)
        ssize_t adjust_libfunc_ea(idasgn_t& sig, libfunc_t& libfun, ea_t* ea)
        fpvalue_error_t realcvt(void* m, fpvalue_t* e, uint16 swt)
        bint delay_slot_insn(ea_t* ea, bint* bexec, bint* fexec)
        ssize_t adjust_refinfo(refinfo_t* ri, ea_t ea, int n, fixup_data_t& fd)
        ssize_t is_cond_insn(insn_t& insn)
        ssize_t set_code16_mode(ea_t ea, bint code16)
        bint get_code16_mode(ea_t ea)
        ssize_t calc_step_over(ea_t* target, ea_t ip)
        ssize_t get_macro_insn_head(ea_t* head, ea_t ip)
        ssize_t get_dbr_opnum(int* opnum, insn_t& insn)
        ssize_t calc_next_eas(eavec_t* res, insn_t& insn, bint over)
        char* get_reg_info(char* regname, bitrange_t* bitrange)
        ssize_t setup_til()
        ssize_t max_ptr_size()
        ssize_t calc_cdecl_purged_bytes(ea_t ea)
        ssize_t equal_reglocs(argloc_t& a1, argloc_t& a2)
        ssize_t _decorate_name(qstring* outbuf, char* name, bint mangle, callcnv_t cc, tinfo_t& type)
        ssize_t _calc_retloc(argloc_t* retloc, tinfo_t& rettype, callcnv_t cc)
        ssize_t _calc_varglocs(func_type_data_t* ftd, regobjs_t* regs, relobj_t* stkargs, int nfixed)
        ssize_t _calc_arglocs(func_type_data_t* fti)
        ssize_t use_stkarg_type(ea_t ea, funcarg_t& arg)
        ssize_t use_regarg_type(int* idx, ea_t ea, void* rargs)
        ssize_t use_arg_types(ea_t ea, func_type_data_t* fti, void* rargs)
        ssize_t calc_purged_bytes(int* p_purged_bytes, func_type_data_t& fti)
        ssize_t get_cc_regs(callregs_t* regs, callcnv_t cc)
        ssize_t get_simd_types(void* out, simd_info_t* simd_attrs, argloc_t* argloc, bint create_tifs)
        ssize_t arg_addrs_ready(ea_t caller, int n, tinfo_t& tif, ea_t* addrs)
        ssize_t adjust_argloc(argloc_t* argloc, tinfo_t* type, int size)
        ssize_t lower_func_type(intvec_t* argnums, func_type_data_t* fti)
        ssize_t get_abi_info(qstrvec_t* abi_names, qstrvec_t* abi_opts, comp_t comp)
        ssize_t arch_changed()
        ssize_t create_merge_handlers(merge_data_t* md)
        ssize_t privrange_changed(range_t& old_privrange, adiff_t delta, qstring* errbuf)
        ssize_t cvt64_supval(nodeidx_t node, uchar tag, nodeidx_t idx, uchar* data, size_t datlen, qstring* errbuf)
        ssize_t cvt64_hashval(nodeidx_t node, uchar tag, char* name, uchar* data, size_t datlen, qstring* errbuf)
        reg_finder_t* get_regfinder()
        int get_stkvar_scale()  # Get the stack variable scaling factor. Useful for 
        bint is_canon_insn(uint16 itype) const  # Does the given value specify a valid instruction f
        char* get_canon_mnem(uint16 itype) const  # Get the instruction name
        uint32 get_canon_feature(uint16 itype) const  # Get the instruction features (combination of
        void ensure_processor()
        size_t sizeof_ldbl() const
        bint is_funcarg_off(func_t* pfn, uval_t frameoff) const
        sval_t lvar_off(func_t* pfn, uval_t frameoff) const
        bint is_lumina_usable() const
    cdef cppclass modctx_t:
        processor_t& ph
        asm_t& ash
        ea_helper_t& _eah
        modctx_t()
        modctx_t& operator=(modctx_t&)
        modctx_t& operator=(modctx_t&&)
        modctx_t(modctx_t&)
        modctx_t(modctx_t&&)
    cdef cppclass procmod_t:  # Each processor module subclasses this class and reacts to HT
        size_t procmod_flags
        procmod_t()
        procmod_t(procmod_t&)
        op_t* make_op_reg(op_t* op, int reg, int8 dtype) const  # The helper methods for
        op_t* make_op_imm(op_t* op, uval_t val, int8 dtype) const
        op_t* make_op_displ(op_t* op, int base_reg, uval_t displ, int8 dtype) const
        op_t* make_op_phrase(op_t* op, int base_reg, int index_reg, int8 dtype) const  # This method puts the index register into the VALUE
    cdef cppclass plugmod_t:
        size_t owner  # internal info used by the kernel
        bint run(size_t arg)  # Invoke the plugin.
        bint hook_event_listener(hook_type_t hook_type, event_listener_t* cb, int hkcb_flags)  # Helper function to hook event listeners.
        plugmod_t& operator=(plugmod_t&)
    cdef cppclass reg_info_t:  # Get register number and size from register name
        int reg  # register number
        int size  # register size
        bint operator==(reg_info_t& r) const
        bint operator!=(reg_info_t& r) const
        bint operator<(reg_info_t& r) const
        bint operator>(reg_info_t& r) const
        bint operator<=(reg_info_t& r) const
        bint operator>=(reg_info_t& r) const
        int compare(reg_info_t& r) const
    cdef cppclass reg_access_t:  # Information about a register accessed by an instruction.
        int regnum  # register number (only entire registers)
        bitrange_t range  # bitrange inside the register
        access_type_t access_type
        uchar opnum  # operand number
        bint have_common_bits(reg_access_t& r) const
        bint operator==(reg_access_t& r) const
        bint operator!=(reg_access_t& r) const
    cdef cppclass reg_accesses_t:
        pass
    cdef cppclass getname_info_t:  # Additional information for get_ea_name() function
        size_t cb  # size of this struct
        int32 inhibitor  # codes to inhibit parts of demangled name (see Usua
        int32 demform  # demangle only if
        int32 demcode  # out: return value of demangler
        getname_info_t()
        getname_info_t(getname_info_t&)
        getname_info_t(getname_info_t&&)
    cdef cppclass ea_name_t:  # ea, name pair
        ea_t ea
        qstring name
        ea_name_t()
        ea_name_t(ea_t _ea, qstring& _name)
    cdef cppclass til_bucket_t
    cdef cppclass til_stream_t
    cdef cppclass tinfo_changes_t
    cdef cppclass type_attr_t:  #  @ { Extended type attributes.
        qstring key  # one symbol keys are reserved to be used by the ker
        bytevec_t value  # attribute bytes
        bint operator<(type_attr_t& r) const
        bint operator>=(type_attr_t& r) const
    cdef cppclass til_t:  # ------------------------------------------------------------
        char* name  # short file name (without path and extension)
        char* desc  # human readable til description
        int nbases  # number of base tils
        til_t** base  # tils that our til is based on
        uint32 flags
        compiler_info_t cc  # information about the target compiler
        til_bucket_t* syms  # symbols
        til_bucket_t* types  # types
        til_bucket_t* macros  # macros
        int nrefs  # number of references to the til
        int nstreams  # number of extra streams
        til_stream_t** streams  # symbol stream storage
        bint is_dirty() const  # @ } Has the til been modified? (#TIL_MOD)
        void set_dirty()  # Mark the til as modified (#TIL_MOD)
        til_t* find_base(char* n)  # Find the base til with the provided name 
    cdef cppclass rrel_t:  # Register-relative argument location
        sval_t off  # displacement from the address pointed by the regis
        int reg  # register index (into {ph,processor_t,reg_names})
    cdef cppclass custloc_desc_t:  # Description of a custom argloc. Custom arglocs can be added 
        size_t cbsize  # size of this structure
        char* name  # name of the custom argloc type. must be unique
    cdef cppclass argloc_t:  # Describes an argument location. A typical argument is stored
        argloc_t()
        argloc_t(argloc_t& r)
        argloc_t& operator=(argloc_t& r)
        void swap(argloc_t& r)  # Assign this == r and r == this
        char* dstr() const
        argloc_type_t atype() const
        bint is_reg1() const
        bint is_reg2() const
        bint is_reg() const
        bint is_rrel() const
        bint is_ea() const
        bint is_stkoff() const
        bint is_scattered() const
        bint has_reg() const
        bint has_stkoff() const
        bint is_mixed_scattered() const
        bint in_stack() const
        bint is_fragmented() const
        bint is_custom() const
        bint is_badloc() const
        int reg1() const  # Get the register info. Use when atype() == ::ALOC_
        int regoff() const  # Get offset from the beginning of the register in b
        int reg2() const  # Get info for the second register. Use when atype()
        uint32 get_reginfo() const  # Get all register info. Use when atype() == ::ALOC_
        sval_t stkoff() const  # Get the stack offset. Use if atype() == ::ALOC_STA
        ea_t get_ea() const  # Get the global address. Use when atype() == ::ALOC
        scattered_aloc_t& scattered()  # Get scattered argument info. Use when atype() == :
        scattered_aloc_t& scattered() const
        rrel_t& get_rrel()  # Get register-relative info. Use when atype() == ::
        rrel_t& get_rrel() const
        void* get_custom() const  # Get custom argloc info. Use if atype() == ::ALOC_C
        biggest_t get_biggest() const  # Get largest element in internal union
        void _set_badloc()  # be careful with these functions, they do not clean
        void _set_reg1(int reg, int off)
        void _set_reg2(int _reg1, int _reg2)
        void _set_stkoff(sval_t off)
        void _set_ea(ea_t _ea)
        bint _consume_rrel(rrel_t* p)  # Use consume_rrel()
        bint _consume_scattered(scattered_aloc_t* p)  # Use consume_scattered()
        void _set_custom(argloc_type_t ct, void* pdata)  # Set custom argument location (careful - this funct
        void _set_biggest(argloc_type_t ct, biggest_t data)  # Set biggest element in internal union (careful - t
        void set_reg1(int reg, int off)  # Set register location
        void set_reg2(int _reg1, int _reg2)  # Set secondary register location
        void set_stkoff(sval_t off)  # Set stack offset location
        void set_ea(ea_t _ea)  # Set static ea location
        void consume_rrel(rrel_t* p)  # Set register-relative location - can't be nullptr
        void consume_scattered(scattered_aloc_t* p)  # Set distributed argument location
        void set_badloc()  # Set to invalid location
        sval_t calc_offset() const  # Calculate offset that can be used to compare 2 sim
        bint advance(int delta)  # Move the location to point 'delta' bytes further
        void align_reg_high(size_t size, size_t _slotsize)  # Set register offset to align it to the upper part 
        void align_stkoff_high(size_t size, size_t _slotsize)  # Set stack offset to align to the upper part of _SL
        bint operator==(argloc_t& r) const
        bint operator!=(argloc_t& r) const
        bint operator<(argloc_t& r) const
        bint operator>(argloc_t& r) const
        bint operator<=(argloc_t& r) const
        bint operator>=(argloc_t& r) const
        int compare(argloc_t& r) const
    cdef cppclass argpart_t:  # Subsection of an argument location
        ushort off  # offset from the beginning of the argument
        ushort size  # the number of bytes
        argpart_t(argloc_t& a)
        argpart_t()
        argpart_t& copy_from(argloc_t& a)
        bint bad_offset() const  # Does this argpart have a valid offset?
        bint bad_size() const  # Does this argpart have a valid size?
        bint operator<(argpart_t& r) const  # Compare two argparts, based on their offset
        void swap(argpart_t& r)  # Assign this = r and r = this
        argpart_t(argpart_t&)
        argpart_t(argpart_t&&)
        argpart_t& operator=(argpart_t&)
        argpart_t& operator=(argpart_t&&)
    cdef cppclass scattered_aloc_t:  # Used to manage arguments that are described by multiple loca
        pass
    cdef cppclass aloc_visitor_t:  # Visit all argument locations. The callback will not receive 
        int visit_location(argloc_t& v, int off, int size)
        aloc_visitor_t& operator=(aloc_visitor_t&)
    cdef cppclass const_aloc_visitor_t:  # Same as ::aloc_visitor_t, but may not modify the argloc
        int visit_location(argloc_t& v, int off, int size)
        const_aloc_visitor_t& operator=(const_aloc_visitor_t&)
    cdef cppclass stkarg_area_info_t:
        size_t cb
        sval_t stkarg_offset  # Offset from the SP to the first stack argument (ca
        sval_t shadow_size  # Size of the shadow area. explanations at: https://
        sval_t linkage_area  # Size of the linkage area. explanations at: https:/
        stkarg_area_info_t()
        stkarg_area_info_t(callcnv_t cc)
        bint get_info(callcnv_t cc)
    cdef cppclass custom_callcnv_t:  # ------------------------------------------------------------
        int cbsize
        uint64 flags
        qstring name  # the name is used as a keyword in the function prot
        uint32 abibits  # abibits to be used for the calling convention
        bint is_vararg() const
        bint is_purging() const
        bint is_usercall() const
        bint validate_func(func_type_data_t& fti, qstring* reterr) const  # Validate a function prototype. This function is us
        bint calc_retloc(func_type_data_t* fti) const  # Calculate the location of the return value. This f
        bint calc_arglocs(func_type_data_t* fti) const  # Calculate the argument locations. This function mu
        ssize_t find_varargs(func_type_data_t* fti, ea_t call_ea, mblock_t* blk) const  # Discover variadic arguments. This function is call
        bint calc_varglocs(func_type_data_t* fti, regobjs_t* regs, relobj_t* stkargs, int nfixed) const  # Calculate the argument locations for a variadic fu
        bint get_cc_regs(callregs_t* out) const  # Retrieve generic information about call registers
        bint get_stkarg_area_info(stkarg_area_info_t* out) const  # Retrieve generic information about stack arguments
        int calc_purged_bytes(func_type_data_t& fti, ea_t call_ea) const  # Calculate the number of purged bytes 
        bint decorate_name(qstring* outbuf, char* name, bint should_decorate, callcnv_t cc, tinfo_t& type) const  # Decorate a function name. Some compilers decorate 
        int lower_func_type(func_type_data_t* fti) const  # Lower a function type. See lower_type() for more e
        custom_callcnv_t()
        custom_callcnv_t(char* _name, uint64 f, uint32 _abibits)
        custom_callcnv_t& operator=(custom_callcnv_t&)
    cdef cppclass mblock_t
    cdef cppclass callregs_t:  # Register allocation calling convention. (allocation policy, 
        argreg_policy_t policy  # argument policy
        int nregs  # max number of registers that can be used in a call
        intvec_t gpregs  # array of gp registers (general purpose)
        intvec_t fpregs  # array of fp registers (floating point)
        callregs_t()  # Constructor
        callregs_t(callcnv_t cc)  # Constructor - initialize with the given request (s
        void swap(callregs_t& r)  # swap two instances
        bint init_regs(callcnv_t cc)  # Init policy & registers for given CC.
        bint by_slots() const  # policy-specific options
        void set(argreg_policy_t _policy, int* gprs, int* fprs)  # Init policy & registers (arrays are -1-terminated)
        void append_registers(reg_kind_t kind, int first_reg, int last_reg)
        void set_registers(reg_kind_t kind, int first_reg, int last_reg)
        void reset()  # Set policy and registers to invalid values
        int regcount(callcnv_t cc)  # Get max number of registers may be used in a funct
        int findreg(intvec_t& regs, int r)  # return index of register, -1 else
        bint reginds(int* gp_ind, int* fp_ind, int r) const  # Get register indexes within GP/FP arrays. (-1 -> i
    cdef cppclass tinfo_t:  # Primary mechanism for managing type information
        tinfo_t()  # Constructor
        tinfo_t(type_t decl_type)  # Constructor - can only be used to initialize simpl
        tinfo_t(char* decl, til_t* til, int pt_flags)  # Constructor - will attempt to parse the provided C
        tinfo_t(tinfo_t& r)  # Constructor
        tinfo_t& operator=(tinfo_t& r)  # Copy contents of given tinfo into this one
        void clear()  # Clear contents of this tinfo, and remove from the 
        void swap(tinfo_t& r)  # Assign this = r and r = this
        bint get_named_type(til_t* til, char* name, type_t decl_type, bint resolve, bint try_ordinal)  # Create a tinfo_t object for an existing named type
        bint get_named_type(char* name, type_t decl_type, bint resolve, bint try_ordinal)
        bint get_numbered_type(til_t* til, uint32 ordinal, type_t decl_type, bint resolve)  # Create a tinfo_t object for an existing ordinal ty
        bint get_numbered_type(uint32 ordinal, type_t decl_type, bint resolve)
        bint detach()  # Detach tinfo_t from the underlying type. After cal
        bint serialize(qtype* type, qtype* fields, qtype* fldcmts, int sudt_flags) const  # Serialize tinfo_t object into a type string.
        bint deserialize(til_t* til, type_t** ptype, p_list** pfields, p_list** pfldcmts, char* cmt)  # Deserialize a type string into a tinfo_t object
        bint deserialize(til_t* til, qtype* ptype, qtype* pfields, qtype* pfldcmts, char* cmt)
        bint is_correct() const  # Is the type object correct?. It is possible to cre
        type_t get_realtype(bint full) const  # Get the resolved base type. Deserialization option
        type_t get_decltype() const  # Get declared type (without resolving type referenc
        bint empty() const  # Was tinfo_t initialized with some type info or not
        bint present() const  # Is the type really present? (not a reference to a 
        size_t get_size(uint32* p_effalign, int gts_code) const  # Get the type size in bytes. 
        size_t get_unpadded_size() const  # Get the type size in bytes without the final paddi
        uint32 get_alignment() const  # Get type alignment This function returns the effec
        type_sign_t get_sign() const  # Get type sign
        bint is_signed() const  # Is this a signed type?
        bint is_unsigned() const  # Is this an unsigned type?
        uchar get_declalign() const  # Get declared alignment of the type
        bint is_typeref() const  # Is this type a type reference?.
        bint has_details() const  # Does this type refer to a nontrivial type?
        bint get_type_name(qstring* out) const  # Does a type refer to a name?. If yes, fill the pro
        bint get_nice_type_name(qstring* out) const  # Get the beautified type name. Get the referenced n
        tinfo_code_t rename_type(char* name, int ntf_flags)  # Rename a type 
        bint get_final_type_name(qstring* out) const  # Use in the case of typedef chain (TYPE1 -> TYPE2 -
        bint get_next_type_name(qstring* out) const  # Use In the case of typedef chain (TYPE1 -> TYPE2 -
        tid_t get_tid() const  # Get the type tid Each type in the local type libra
        tid_t force_tid()  # Get the type tid. Create if it does not exist yet.
        uint32 get_ordinal() const  # Get type ordinal (only if the type was created as 
        uint32 get_final_ordinal() const  # Get final type ordinal (0 if none)
        til_t* get_til() const  # Get the type library for tinfo_t
        bint is_from_subtil() const  # Was the named type found in some base type library
        bint is_forward_decl() const  # Is this a forward declaration?. Forward declaratio
        type_t get_forward_type() const  # Get type of a forward declaration. For a forward d
        bint is_forward_struct() const
        bint is_forward_union() const
        bint is_forward_enum() const
        bint is_typedef() const  # Is this a typedef?. This function will return true
        int get_type_cmt(qstring* out) const  # Get type comment 
        bint get_type_rptcmt(qstring* out) const  # Get type comment only if it is repeatable
        bint is_decl_const() const
        bint is_decl_volatile() const
        bint is_decl_void() const
        bint is_decl_partial() const
        bint is_decl_unknown() const
        bint is_decl_last() const
        bint is_decl_ptr() const
        bint is_decl_array() const
        bint is_decl_func() const
        bint is_decl_complex() const
        bint is_decl_typedef() const
        bint is_decl_sue() const
        bint is_decl_struct() const
        bint is_decl_union() const
        bint is_decl_udt() const
        bint is_decl_enum() const
        bint is_decl_bitfield() const
        bint is_decl_int128() const
        bint is_decl_int64() const
        bint is_decl_int32() const
        bint is_decl_int16() const
        bint is_decl_int() const
        bint is_decl_char() const
        bint is_decl_uint() const
        bint is_decl_uchar() const
        bint is_decl_uint16() const
        bint is_decl_uint32() const
        bint is_decl_uint64() const
        bint is_decl_uint128() const
        bint is_decl_ldouble() const
        bint is_decl_double() const
        bint is_decl_float() const
        bint is_decl_tbyte() const
        bint is_decl_floating() const
        bint is_decl_bool() const
        bint is_decl_paf() const
        bint is_well_defined() const
        bint is_const() const  # Probe the resolved type for various attributes:
        bint is_volatile() const
        bint is_void() const
        bint is_partial() const
        bint is_unknown() const
        bint is_ptr() const
        bint is_array() const
        bint is_func() const
        bint is_complex() const
        bint is_struct() const
        bint is_union() const
        bint is_udt() const
        bint is_enum() const
        bint is_sue() const
        bint is_bitfield() const
        bint is_int128() const
        bint is_int64() const
        bint is_int32() const
        bint is_int16() const
        bint is_int() const
        bint is_char() const
        bint is_uint() const
        bint is_uchar() const
        bint is_uint16() const
        bint is_uint32() const
        bint is_uint64() const
        bint is_uint128() const
        bint is_ldouble() const
        bint is_double() const
        bint is_float() const
        bint is_tbyte() const
        bint is_bool() const
        bint is_paf() const
        bint is_ptr_or_array() const
        bint is_integral() const
        bint is_ext_integral() const
        bint is_floating() const
        bint is_arithmetic() const
        bint is_ext_arithmetic() const
        bint is_scalar() const  # Does the type represent a single number?
        bint get_ptr_details(ptr_type_data_t* pi) const  # Get the pointer info.
        bint get_array_details(array_type_data_t* ai) const  # Get the array specific info
        bint get_enum_details(enum_type_data_t* ei) const  # Get the enum specific info
        bint get_bitfield_details(bitfield_type_data_t* bi) const  # Get the bitfield specific info
        bint get_udt_details(udt_type_data_t* udt, gtd_udt_t gtd) const  # Get the udt specific info
        bint get_func_details(func_type_data_t* fi, gtd_func_t gtd) const  # Get only the function specific info for this tinfo
        bint is_funcptr() const  # Is this pointer to a function?
        bint is_shifted_ptr() const  # Is a shifted pointer?
        bint is_varstruct() const  # Is a variable-size structure?
        bint is_varmember() const  # Can the type be of a variable struct member? This 
        int get_ptrarr_objsize() const  # ::BT_PTR & ::BT_ARRAY: get size of pointed object 
        tinfo_t get_ptrarr_object() const  # ::BT_PTR & ::BT_ARRAY: get the pointed object or a
        tinfo_t get_pointed_object() const  # ::BT_PTR: get type of pointed object. If the curre
        bint is_pvoid() const  # Is "void *"?. This function does not check the poi
        bint is_punknown() const  # Is "_UNKNOWN *"?. This function does not check the
        tinfo_t get_array_element() const  # ::BT_ARRAY: get type of array element. See also ge
        tinfo_t get_final_element() const  # repeat recursively: if an array, return the type o
        int get_array_nelems() const  # ::BT_ARRAY: get number of elements (-1 means error
        tinfo_t get_nth_arg(int n) const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get type of n-th 
        tinfo_t get_rettype() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get the function'
        int get_nargs() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Calculate number 
        callcnv_t get_cc() const  # ::BT_FUNC or ::BT_PTR ::BT_FUNC: Get calling conve
        bint is_user_cc() const
        bint is_vararg_cc() const
        bint is_purging_cc() const
        int calc_purged_bytes() const  # ::BT_FUNC: Calculate number of purged bytes
        bint is_high_func() const  # ::BT_FUNC: Is high level type?
        bint get_methods(udtmembervec_t* methods) const  # ::BT_COMPLEX: get a list of member functions decla
        bint get_bit_buckets(range64vec_t* buckets) const  # ::BT_STRUCT: get bit buckets Bit buckets are used 
        int find_udm(udm_t* udm, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find a udt member. - at 
        int find_udm(uint64 offset, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find an udt member at th
        int find_udm(char* name, int strmem_flags) const  # ::BTF_STRUCT,::BTF_UNION: Find an udt member by na
        int get_udm(udm_t* out, char* name) const  # Retrieve a structure/union member with the specifi
        int get_udm(udm_t* out, size_t index) const  # Retrieve a structure/union member with the specifi
        int get_udm_by_offset(udm_t* out, uint64 offset) const  # Retrieve a structure/union member with the specifi
        int get_udt_nmembers() const  # Get number of udt members. -1-error
        bint is_empty_udt() const  # Is an empty struct/union? (has no fields)
        bint is_small_udt() const  # Is a small udt? (can fit a register or a pair of r
        uint32 get_udt_taudt_bits() const  # Get udt_type_data_t::taudt_bits
        bint is_unaligned_struct() const  # Is an unaligned struct
        bint is_msstruct() const  # Is gcc msstruct attribute applied
        bint is_cpp_struct() const  # Is a c++ object, not simple pod type
        bint is_vftable() const  # Is a vftable type?
        bint is_fixed_struct() const  # Is a structure with fixed offsets?
        bint is_tuple() const  # Is a tuple?
        bint requires_qualifier(qstring* out, char* name, uint64 offset) const  # Requires full qualifier? (name is not unique) 
        bint append_covered(rangeset_t* out, uint64 offset) const  # Calculate set of covered bytes for the type 
        bint calc_gaps(rangeset_t* out) const  # Calculate set of padding bytes for the type 
        bint is_one_fpval() const  # Floating value or an object  consisting of one flo
        bint is_sse_type() const  # Is a SSE vector type?
        bint is_anonymous_udt() const  # Is an anonymous struct/union? We assume that types
        bint has_vftable() const  # Has a vftable?
        bint has_union() const  # Has a member of type "union"?
        size_t get_enum_nmembers() const  # Get number of enum members. 
        bint is_empty_enum() const  # Is an empty enum? (has no constants)
        type_t get_enum_base_type() const  # Get enum base type (convert enum to integer type) 
        bint is_bitmask_enum() const  # Is bitmask enum? 
        int get_enum_radix() const  # Get enum constant radix 
        tinfo_code_t get_enum_repr(value_repr_t* repr) const  # Set the representation of enum members. 
        int get_enum_width() const  # Get enum width 
        uint64 calc_enum_mask() const
        ssize_t get_edm(edm_t* out, char* name) const  # Get enum member by its name 
        tinfo_code_t get_edm(edm_t* edm, size_t idx) const  # Get enum member by its index 
        ssize_t get_edm_by_value(edm_t* out, uint64 value, bmask64_t bmask, uchar serial) const  # Get enum member by its value 
        tid_t get_edm_tid(size_t idx) const  # Get enum member TID 
        tinfo_t get_onemember_type() const  # For objects consisting of one member entirely: ret
        tinfo_t get_innermost_udm(uint64 bitoffset, size_t* out_index, uint64* out_bitoffset) const  # Get the innermost member at the given offset 
        tinfo_t get_innermost_member_type(uint64 bitoffset, uint64* out_bitoffset) const  # Get the innermost member type at the given offset 
        uint32 calc_score() const  # Calculate the type score (the higher - the nicer i
        bint print(qstring* out, char* name, int prtype_flags, int indent, int cmtindent, char* prefix, char* cmt) const  # Get a C-like string representation of the type. 
        char* dstr() const  # Function to facilitate debugging
        bint get_attrs(type_attrs_t* tav, bint all_attrs) const  # Get type attributes (all_attrs: include attributes
        bint get_attr(qstring& key, bytevec_t* bv, bint all_attrs) const  # Get a type attribute
        bint set_attrs(type_attrs_t* tav)  # Set type attributes. If necessary, a new typid wil
        bint set_attr(type_attr_t& ta, bint may_overwrite)  # Set a type attribute. If necessary, a new typid wi
        void del_attrs()  # Del all type attributes. typerefs cannot be modifi
        bint del_attr(qstring& key, bint make_copy)  # Del a type attribute. typerefs cannot be modified 
        bint create_simple_type(type_t decl_type)
        bint create_ptr(ptr_type_data_t& p, type_t decl_type)
        bint create_array(array_type_data_t& p, type_t decl_type)
        bint create_bitfield(bitfield_type_data_t& p, type_t decl_type)
        bint create_typedef(typedef_type_data_t& p, type_t decl_type, bint try_ordinal)
        bint create_ptr(tinfo_t& tif, uchar bps, type_t decl_type)  #  @ {
        bint create_array(tinfo_t& tif, uint32 nelems, uint32 base, type_t decl_type)
        void create_typedef(til_t* til, char* name, type_t decl_type, bint try_ordinal)
        void create_typedef(til_t* til, uint ord, type_t decl_type)
        bint create_bitfield(uchar nbytes, uchar width, bint is_unsigned, type_t decl_type)
        bint parse(char* decl, til_t* til, int pt_flags)  # Convenience function to parse a string with a type
        bint create_udt(bint is_union)  # Create an empty structure/union
        bint create_enum(bte_t bte)  # Create an empty enum
        bint create_udt(udt_type_data_t& p)  #  These functions consume 'p' (make it empty) @ {
        bint create_udt(udt_type_data_t& p, type_t decl_type)
        bint create_enum(enum_type_data_t& p, type_t decl_type)
        bint create_func(func_type_data_t& p, type_t decl_type)
        ssize_t get_udm_by_tid(udm_t* udm, tid_t tid)  # Retrive tinfo using type TID or struct/enum member
        ssize_t get_edm_by_tid(edm_t* edm, tid_t tid)
        bint get_type_by_tid(tid_t tid)
        ssize_t get_by_edm_name(char* mname, til_t* til)  # Retrieve enum tinfo using enum member name 
        tinfo_code_t set_named_type(til_t* til, char* name, int ntf_flags)  #  Store the type info in the type library as a name
        tinfo_code_t set_symbol_type(til_t* til, char* name, int ntf_flags)
        tinfo_code_t set_numbered_type(til_t* til, uint32 ord, int ntf_flags, char* name)
        tinfo_code_t save_type(int ntf_flags)
        tinfo_code_t copy_type(til_t* til, char* name, int ntf_flags)
        tinfo_code_t create_forward_decl(til_t* til, type_t decl_type, char* name, int ntf_flags)  # Create a forward declaration. decl_type: ::BTF_STR
        tinfo_t get_stock(stock_type_id_t id)  # Get stock type information. This function can be u
        bint convert_array_to_ptr()  # Convert an array into a pointer. type[] => type *
        bint remove_ptr_or_array()  # Replace the current type with the ptr obj or array
        uint64 read_bitfield_value(uint64 v, int bitoff) const  #  Helper functions to store/extract bitfield values
        uint64 write_bitfield_value(uint64 dst, uint64 v, int bitoff) const
        type_t get_modifiers() const  #  Work with type modifiers: const and volatile @ {
        void set_modifiers(type_t mod)
        void set_const()
        void set_volatile()
        void clr_decl_const_volatile()  # remove modifiers for trivial types, without resolv
        bint clr_const()  # remove modifiers from non-trivial types. for examp
        bint clr_volatile()
        bint clr_const_volatile()
        tinfo_code_t set_type_alignment(uchar declalign, uint etf_flags)  # Set type alignment
        bint set_declalign(uchar declalign)
        bint change_sign(type_sign_t sign)  # Change the type sign. Works only for the types tha
        bint calc_udt_aligns(int sudt_flags)  # Calculate the udt alignments using the field offse
        bint set_methods(udtmembervec_t& methods)  # ::BT_COMPLEX: set the list of member functions. Th
        tinfo_code_t set_type_cmt(char* cmt, bint is_regcmt, uint etf_flags)  # Set type comment This function works only for non-
        uint32 get_alias_target() const  # Get type alias If the type has no alias, return 0.
        bint is_aliased() const
        bint set_type_alias(uint32 dest_ord)  # Set type alias Redirects all references to source 
        tinfo_code_t set_udt_alignment(int sda, uint etf_flags)  # Set declared structure alignment (sda) This alignm
        tinfo_code_t set_udt_pack(int pack, uint etf_flags)  # Set structure packing. The value controls how litt
        tid_t get_udm_tid(size_t idx) const  # Get udt member TID 
        tinfo_code_t add_udm(udm_t& udm, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. 
        tinfo_code_t add_udm(char* name, tinfo_t& type, uint64 offset, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. The member's size wi
        tinfo_code_t add_udm(char* name, type_t type, uint64 offset, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. The member's type wi
        tinfo_code_t add_udm(char* name, char* type, uint64 offset, uint etf_flags, size_t times, ssize_t idx)  # Add a structure/union member. The member's type wi
        tinfo_code_t del_udm(size_t index, uint etf_flags)  # Delete a structure/union member.
        tinfo_code_t del_udms(size_t idx1, size_t idx2, uint etf_flags)  # Delete structure/union members in the range [idx1,
        tinfo_code_t rename_udm(size_t index, char* name, uint etf_flags)  # Rename a structure/union member. The new name must
        tinfo_code_t set_udm_type(size_t index, tinfo_t& tif, uint etf_flags, value_repr_t* repr)  # Set type of a structure/union member. 
        tinfo_code_t set_udm_cmt(size_t index, char* cmt, bint is_regcmt, uint etf_flags)  # Set a comment for a structure/union member. A memb
        tinfo_code_t set_udm_repr(size_t index, value_repr_t& repr, uint etf_flags)  # Set the representation of a structure/union member
        bint is_udm_by_til(size_t idx) const  # Was the member created due to the type system 
        tinfo_code_t set_udm_by_til(size_t idx, bint on, uint etf_flags)  # The member is created due to the type system 
        tinfo_code_t set_fixed_struct(bint on)  # Declare struct member offsets as fixed. For such s
        tinfo_code_t set_struct_size(size_t new_size)  # Explicitly specify the struct size. This function 
        tinfo_code_t expand_udt(size_t idx, adiff_t delta, uint etf_flags)  # Expand/shrink a structure by adding/removing a gap
        tinfo_code_t set_tuple(bint on)  # Declare struct as a tuple. Currently, tuples in ID
        bint get_func_frame(func_t* pfn)  # Create a tinfo_t object for the function frame 
        bint is_frame() const  # Is a function frame?
        ea_t get_frame_func() const  # Get function address for the frame
        ssize_t get_stkvar(sval_t* actval, insn_t& insn, op_t* x, sval_t v)  # Retrieve frame tinfo for a stack variable 
        tinfo_code_t set_enum_width(int nbytes, uint etf_flags)  # Set the width of enum base type 
        tinfo_code_t set_enum_sign(type_sign_t sign, uint etf_flags)  # Set enum sign 
        tinfo_code_t set_enum_is_bitmask(bitmask_cvt_stance_t stance, uint etf_flags)
        tinfo_code_t set_enum_repr(value_repr_t& repr, uint etf_flags)  # Set the representation of enum members. 
        tinfo_code_t set_enum_radix(int radix, bint sign, uint etf_flags)  # Set enum radix to display constants 
        tinfo_code_t add_edm(edm_t& edm, bmask64_t bmask, uint etf_flags, ssize_t idx)  # Add a new enum member (a new symbolic constant) 
        tinfo_code_t add_edm(char* name, uint64 value, bmask64_t bmask, uint etf_flags, ssize_t idx)  # Add a new enum member (a new symbolic constant) 
        tinfo_code_t del_edms(size_t idx1, size_t idx2, uint etf_flags)  # Delete enum members 
        tinfo_code_t del_edm(size_t idx, uint etf_flags)
        tinfo_code_t del_edm(char* name, uint etf_flags)  # Delete enum member by its name 
        tinfo_code_t del_edm_by_value(uint64 value, uint etf_flags, bmask64_t bmask, uchar serial)  # Delete enum member by its value 
        tinfo_code_t rename_edm(size_t idx, char* name, uint etf_flags)  # Rename a enum member 
        tinfo_code_t set_edm_cmt(size_t idx, char* cmt, uint etf_flags)  # Set a comment for an enum member. Such comments ar
        tinfo_code_t edit_edm(size_t idx, uint64 value, bmask64_t bmask, uint etf_flags)  # Change constant value and/or bitmask 
        tinfo_code_t rename_funcarg(size_t index, char* name, uint etf_flags)  # Rename a function argument. The new name must be u
        tinfo_code_t set_funcarg_type(size_t index, tinfo_t& tif, uint etf_flags)  # Set type of a function argument. 
        tinfo_code_t set_func_rettype(tinfo_t& tif, uint etf_flags)  # Set function return type . 
        tinfo_code_t del_funcargs(size_t idx1, size_t idx2, uint etf_flags)  # Delete function arguments 
        tinfo_code_t del_funcarg(size_t idx, uint etf_flags)
        tinfo_code_t add_funcarg(funcarg_t& farg, uint etf_flags, ssize_t idx)  # Add a function argument. 
        tinfo_code_t set_func_cc(callcnv_t cc, uint etf_flags)  # Set function calling convention
        tinfo_code_t set_funcarg_loc(size_t index, argloc_t& argloc, uint etf_flags)  # Set location of a function argument. 
        tinfo_code_t set_func_retloc(argloc_t& argloc, uint etf_flags)  # Set location of function return value. 
        bint operator==(tinfo_t& r) const
        bint operator!=(tinfo_t& r) const
        bint operator<(tinfo_t& r) const
        bint operator>(tinfo_t& r) const
        bint operator<=(tinfo_t& r) const
        bint operator>=(tinfo_t& r) const
        int compare(tinfo_t& r) const
        bint compare_with(tinfo_t& r, int tcflags) const  # @ } Compare two types, based on given flags (see
        bint equals_to(tinfo_t& r) const
        bint is_castable_to(tinfo_t& target) const
        bint is_manually_castable_to(tinfo_t& target) const
    cdef cppclass simd_info_t:  # ------------------------------------------------------------
        char* name  # name of SIMD type (nullptr-undefined)
        tinfo_t tif  # SIMD type (empty-undefined)
        uint16 size  # SIMD type size in bytes (0-undefined)
        type_t memtype  # member type BTF_INT8/16/32/64/128, BTF_UINT8/16/32
        simd_info_t(char* nm, uint16 sz, type_t memt)
        bint match_pattern(simd_info_t* pattern)
        simd_info_t(simd_info_t&)
        simd_info_t(simd_info_t&&)
        simd_info_t& operator=(simd_info_t&)
        simd_info_t& operator=(simd_info_t&&)
    cdef cppclass ptr_type_data_t:  # ------------------------------------------------------------
        tinfo_t obj_type  # pointed object type
        tinfo_t closure  # cannot have both closure and based_ptr_size
        tinfo_t parent  # Parent struct
        int32 delta  # Offset from the beginning of the parent struct
        uchar based_ptr_size
        uchar taptr_bits  # TAH bits
        ptr_type_data_t(tinfo_t c, uchar bps, tinfo_t p, int32 d)
        void swap(ptr_type_data_t& r)
        bint operator==(ptr_type_data_t& r) const
        bint operator!=(ptr_type_data_t& r) const
        bint is_code_ptr() const
        bint is_shifted() const
        ptr_type_data_t(ptr_type_data_t&)
        ptr_type_data_t(ptr_type_data_t&&)
        ptr_type_data_t& operator=(ptr_type_data_t&)
        ptr_type_data_t& operator=(ptr_type_data_t&&)
    cdef cppclass array_type_data_t:  # ------------------------------------------------------------
        tinfo_t elem_type  # element type
        uint32 base  # array base
        uint32 nelems  # number of elements
        array_type_data_t(size_t b, size_t n)
        void swap(array_type_data_t& r)
        array_type_data_t(array_type_data_t&)
        array_type_data_t(array_type_data_t&&)
        array_type_data_t& operator=(array_type_data_t&)
        array_type_data_t& operator=(array_type_data_t&&)
    cdef cppclass funcarg_t:  # ------------------------------------------------------------
        argloc_t argloc  # argument location
        qstring name  # argument name (may be empty)
        qstring cmt  # argument comment (may be empty)
        tinfo_t type  # argument type
        uint32 flags
        funcarg_t()  # @ }
        funcarg_t(char* _name, tinfo_t& _type, argloc_t& _argloc)  # Create a function argument, with the specified nam
        funcarg_t(char* _name, type_t _type, argloc_t& _argloc)  # Create a function argument, with the specified nam
        funcarg_t(char* _name, char* _type, argloc_t& _argloc)  # Create a function argument, with the specified nam
        bint operator==(funcarg_t& r) const
        bint operator!=(funcarg_t& r) const
        funcarg_t(funcarg_t&)
        funcarg_t(funcarg_t&&)
        funcarg_t& operator=(funcarg_t&)
        funcarg_t& operator=(funcarg_t&&)
    cdef cppclass func_type_data_t:  # Function type information (see tinfo_t::get_func_details())
        int flags
        callcnv_t _new_callcnv  # Do not access directly, use get_cc/set_cc
        tinfo_t rettype  # return type
        argloc_t retloc  # return location
        uval_t stkargs  # size of stack arguments (not used in build_func_ty
        reginfovec_t spoiled  # spoiled register information. if spoiled register 
        cm_t _old_cc  # calling convention, legacy codes. do not access
        callcnv_t get_explicit_cc() const
        callcnv_t get_cc() const
        void set_cc(callcnv_t cc)
        void swap(func_type_data_t& r)
        bint is_high() const
        bint is_noret() const
        bint is_pure() const
        bint is_static() const
        bint is_virtual() const
        bint is_const() const
        bint is_ctor() const
        bint is_dtor() const
        int get_call_method() const
        bint is_vararg_cc() const
        bint is_golang_cc() const
        bint is_swift_cc() const
        bint is_user_cc() const
        callcnv_t guess_cc(int purged, int cc_flags) const  # Guess function calling convention use the followin
        bint dump(qstring* out, int praloc_bits) const  # Dump information that is not always visible in the
        ssize_t find_argument(char* name, size_t from_, size_t to) const  # find argument by name
        func_type_data_t(func_type_data_t&)
        func_type_data_t(func_type_data_t&&)
        func_type_data_t& operator=(func_type_data_t&)
        func_type_data_t& operator=(func_type_data_t&&)
        func_type_data_t()
    cdef cppclass edm_t:  # ------------------------------------------------------------
        qstring name
        qstring cmt  # repeatable comment
        uint64 value
        edm_t()
        edm_t(char* _name, uint64 _value, char* _cmt)  # Create an enumeration value with the specified nam
        bint empty() const  # a enum constant must at least have a name
        bint operator==(edm_t& r) const
        bint operator!=(edm_t& r) const
        void swap(edm_t& r)
        tid_t get_tid() const
        edm_t(edm_t&)
        edm_t(edm_t&&)
    cdef cppclass enum_type_data_t:  # Enum type information (see tinfo_t::get_enum_details())
        intvec_t group_sizes  # if present, specifies bitmask group sizes each non
        uint32 taenum_bits
        bte_t bte  # enum member sizes (shift amount) and style. do not
        enum_type_data_t(bte_t _bte)
        int get_enum_radix() const  # How the enum members should be printed in the enum
        bint is_number_signed() const
        void set_enum_radix(int radix, bint sign)  # Set radix to display constants 
        bint is_char() const
        bint is_dec() const
        bint is_hex() const
        bint is_oct() const
        bint is_bin() const
        bint is_udec() const
        bint is_shex() const
        bint is_soct() const
        bint is_sbin() const
        bint has_lzero() const
        void set_lzero(bint on)
        uint64 calc_mask() const
        bint store_64bit_values() const
        bint is_bf() const  # is bitmask or ordinary enum?
        int calc_nbytes() const  # get the width of enum in bytes
        bint set_nbytes(int nbytes)  # set enum width (nbytes)
        bint get_constant_group(size_t* group_start_index, size_t* group_size, size_t idx) const  # get group parameters for the constant, valid for b
        bint is_group_mask_at(size_t idx) const  # is the enum member at IDX a non-trivial group mask
        bint is_valid_group_sizes() const  # is valid group sizes
        ssize_t find_member(char* name, size_t from_, size_t to) const  # find member (constant or bmask) by name
        ssize_t find_member(uint64 value, uchar serial, size_t from_, size_t to, uint64 vmask) const  # find member (constant or bmask) by value
        void swap(enum_type_data_t& r)  # swap two instances
        void add_constant(char* name, uint64 value, char* cmt)  # add constant for regular enum
        tinfo_code_t get_value_repr(value_repr_t* repr) const  # get enum radix and other representation info 
        tinfo_code_t set_value_repr(value_repr_t& repr)  # set enum radix and other representation info 
        uchar get_serial(size_t index) const  # returns serial for the constant
        uchar get_max_serial(uint64 value) const  # return the maximum serial for the value
        enum_type_data_t(enum_type_data_t&)
        enum_type_data_t(enum_type_data_t&&)
    cdef cppclass typedef_type_data_t:  # ------------------------------------------------------------
        til_t* til  # type library to use when resolving
        char* name  # is_ordref=false: target type name. we do not own t
        uint32 ordinal  # is_ordref=true: type ordinal number
        bint is_ordref  # is reference by ordinal?
        bint resolve  # should resolve immediately?
        typedef_type_data_t(til_t* _til, char* _name, bint _resolve)
        typedef_type_data_t(til_t* _til, uint32 ord, bint _resolve)
        void swap(typedef_type_data_t& r)
        typedef_type_data_t(typedef_type_data_t&)
        typedef_type_data_t(typedef_type_data_t&&)
    cdef cppclass custom_data_type_info_t:  # ------------------------------------------------------------
        int16 dtid  # data type id
        int16 fid  # data format ids
        custom_data_type_info_t& operator=(custom_data_type_info_t&)
        custom_data_type_info_t& operator=(custom_data_type_info_t&&)
    cdef cppclass value_repr_t:  # Visual representation of a member of a complex type (struct/
        uint64 bits
        refinfo_t ri  # FRB_OFFSET
        int32 strtype  # FRB_STRLIT
        custom_data_type_info_t cd  # FRB_CUSTOM
        array_parameters_t ap  # FRB_TABFORM, AP_SIGNED is ignored, use FRB_SIGNED 
        void swap(value_repr_t& r)
        void clear()
        bint empty() const
        bint is_enum() const
        bint is_offset() const
        bint is_strlit() const
        bint is_custom() const
        bint is_stroff() const
        bint is_typref() const
        bint is_signed() const
        bint has_tabform() const
        bint has_lzeroes() const
        uint64 get_vtype() const
        void set_vtype(uint64 vt)
        void set_signed(bint on)
        void set_tabform(bint on)
        void set_lzeroes(bint on)
        void set_ap(array_parameters_t& _ap)
        void init_ap(array_parameters_t* _ap) const
        bint from_opinfo(flags64_t flags, aflags_t afl, opinfo_t* opinfo, array_parameters_t* _ap)
        size_t print(qstring* result, bint colored) const
        bint parse_value_repr(qstring& attr, type_t target_type)
        value_repr_t& operator=(value_repr_t&)
        value_repr_t& operator=(value_repr_t&&)
    cdef cppclass udm_t:  # ------------------------------------------------------------
        uint64 offset  # member offset in bits
        uint64 size  # size in bits
        qstring name  # member name
        qstring cmt  # member comment
        tinfo_t type  # member type
        value_repr_t repr  # radix, refinfo, strpath, custom_id, strtype
        int effalign  # effective field alignment (in bytes)
        uint32 tafld_bits  # TAH bits
        uchar fda  # field alignment (shift amount)
        udm_t()
        udm_t(char* _name, tinfo_t& _type, uint64 _offset)  # Create a structure/union member, with the specifie
        udm_t(char* _name, type_t _type, uint64 _offset)  # Create a structure/union member, with the specifie
        udm_t(char* _name, char* _type, uint64 _offset)  # Create a structure/union member, with the specifie
        bint empty() const  # a udt member must at least have a type
        bint is_bitfield() const
        bint is_zero_bitfield() const
        bint is_unaligned() const
        bint is_baseclass() const
        bint is_virtbase() const
        bint is_vftable() const
        bint is_method() const
        bint is_gap() const
        bint is_regcmt() const
        bint is_retaddr() const
        bint is_savregs() const
        bint is_special_member() const
        bint is_by_til() const
        void set_unaligned(bint on)
        void set_baseclass(bint on)
        void set_virtbase(bint on)
        void set_vftable(bint on)
        void set_method(bint on)
        void set_regcmt(bint on)
        void set_retaddr(bint on)
        void set_savregs(bint on)
        void set_by_til(bint on)
        void clr_unaligned()
        void clr_baseclass()
        void clr_virtbase()
        void clr_vftable()
        void clr_method()
        uint64 begin() const
        uint64 end() const
        bint operator<(udm_t& r) const
        bint operator==(udm_t& r) const
        bint compare_with(udm_t& r, int tcflags) const
        bint operator!=(udm_t& r) const
        void swap(udm_t& r)
        bint is_anonymous_udm() const  # the user cannot enter anonymous fields in ida (the
        void set_value_repr(value_repr_t& r)
        bint can_be_dtor() const
        bint can_rename() const
        udm_t(udm_t&)
        udm_t(udm_t&&)
        udm_t& operator=(udm_t&)
        udm_t& operator=(udm_t&&)
    cdef cppclass udtmembervec_t:
        udtmembervec_t(udtmembervec_t&)
        udtmembervec_t(udtmembervec_t&&)
    cdef cppclass udt_type_data_t:
        size_t total_size  # total structure size in bytes
        size_t unpadded_size  # unpadded structure size in bytes
        uint32 effalign  # effective structure alignment (in bytes)
        uint32 taudt_bits  # TA... and TAUDT... bits
        uchar version  # version of udt_type_data_t
        uchar sda  # declared structure alignment (shift amount+1). 0 -
        uchar pack  # #pragma pack() alignment (shift amount)
        bint is_union  # is union or struct?
        void swap(udt_type_data_t& r)
        bint is_unaligned() const
        bint is_msstruct() const
        bint is_cppobj() const
        bint is_vftable() const
        bint is_fixed() const
        bint is_tuple() const
        void set_vftable(bint on)
        void set_fixed(bint on)
        void set_tuple(bint on)
        bint is_last_baseclass(size_t idx)
        udm_t& add_member(char* _name, tinfo_t& _type, uint64 _offset)  # Add a new member to a structure or union. This fun
        ssize_t find_member(udm_t* pattern_udm, int strmem_flags) const  #  
        ssize_t find_member(char* name) const
        ssize_t find_member(uint64 bit_offset) const
        ssize_t get_best_fit_member(asize_t disp) const  # Get the member that is most likely referenced by t
        ssize_t get_best_fit_member(udm_t* out, asize_t disp) const  # Get the member that is most likely referenced by t
        udt_type_data_t()
        udt_type_data_t(udt_type_data_t&)
        udt_type_data_t(udt_type_data_t&&)
    cdef cppclass udm_visitor_t:  # ------------------------------------------------------------
        int visit_udm(tid_t tid, tinfo_t* tif, udt_type_data_t* udt, ssize_t idx)
        udm_visitor_t& operator=(udm_visitor_t&)
    cdef cppclass bitfield_type_data_t:  # ------------------------------------------------------------
        uchar nbytes  # enclosing type size (1,2,4,8 bytes)
        uchar width  # number of bits
        bint is_unsigned  # is bitfield unsigned?
        bitfield_type_data_t(uchar _nbytes, uchar _width, bint _is_unsigned)
        bint serialize(qtype* type, type_t mods) const
        bint operator==(bitfield_type_data_t& r) const
        bint operator!=(bitfield_type_data_t& r) const
        bint operator<(bitfield_type_data_t& r) const
        bint operator>(bitfield_type_data_t& r) const
        bint operator<=(bitfield_type_data_t& r) const
        bint operator>=(bitfield_type_data_t& r) const
        int compare(bitfield_type_data_t& r) const
        void swap(bitfield_type_data_t& r)
        bint is_valid_bitfield() const
        bitfield_type_data_t(bitfield_type_data_t&)
        bitfield_type_data_t(bitfield_type_data_t&&)
    cdef cppclass type_mods_t:  # Information about how to modify the current type, used by ::
        tinfo_t type  # current type
        qstring name  # current type name
        qstring cmt  # comment for current type
        int flags
        void clear()  # @ }
        void set_new_type(tinfo_t& t)  # The visit_type() function may optionally save the 
        void set_new_name(qstring& n)
        void set_new_cmt(qstring& c, bint rptcmt)
        bint has_type() const
        bint has_name() const
        bint has_cmt() const
        bint is_rptcmt() const
        bint has_info() const
        type_mods_t(type_mods_t&)
        type_mods_t(type_mods_t&&)
        type_mods_t& operator=(type_mods_t&)
        type_mods_t& operator=(type_mods_t&&)
    cdef cppclass tinfo_visitor_t:  # Visit all subtypes of a type. Derive your visitor from this 
        int state
        int level  # recursion level (internal use)
        tinfo_visitor_t(int s)
        int visit_type(type_mods_t* out, tinfo_t& tif, char* name, char* cmt)  # Visit a subtype. this function must be implemented
        void prune_now()  # To refuse to visit children of the current type, u
        int apply_to(tinfo_t& tif, type_mods_t* out, char* name, char* cmt)  # Call this function to initiate the traversal
        tinfo_visitor_t& operator=(tinfo_visitor_t&)
    cdef cppclass regobj_t:  # Object that represents a register
        int regidx  # index into dbg->registers
        int relocate  # 0-plain num, 1-must relocate
        bytevec_t value
        size_t size() const
    cdef cppclass regobjs_t:
        pass
    cdef cppclass argtinfo_helper_t:  # ------------------------------------------------------------
        size_t reserved
        bint set_op_tinfo(insn_t& insn, op_t& x, tinfo_t& tif, char* name)  # Set the operand type as specified
        bint is_stkarg_load(insn_t& insn, int* src, int* dst)  # Is the current insn a stkarg load?. if yes: - src:
        bint has_delay_slot(ea_t)  # The call instruction with a delay slot?.
        void use_arg_tinfos(ea_t caller, func_type_data_t* fti, funcargvec_t* rargs)  # This function is to be called by the processor mod
        argtinfo_helper_t& operator=(argtinfo_helper_t&)
    cdef cppclass lowertype_helper_t:  # ------------------------------------------------------------
        bint func_has_stkframe_hole(tinfo_t& candidate, func_type_data_t& candidate_data)
        int get_func_purged_bytes(tinfo_t& candidate, func_type_data_t& candidate_data)
        lowertype_helper_t& operator=(lowertype_helper_t&)
        lowertype_helper_t(lowertype_helper_t&)
        lowertype_helper_t()
    cdef cppclass ida_lowertype_helper_t:  # ------------------------------------------------------------
        ida_lowertype_helper_t(tinfo_t& _tif, ea_t _ea, int _pb)
        bint func_has_stkframe_hole(tinfo_t& candidate, func_type_data_t& candidate_data)
        int get_func_purged_bytes(tinfo_t& candidate, func_type_data_t&)
        ida_lowertype_helper_t(ida_lowertype_helper_t&)
        ida_lowertype_helper_t(ida_lowertype_helper_t&&)
        ida_lowertype_helper_t& operator=(ida_lowertype_helper_t&)
        ida_lowertype_helper_t& operator=(ida_lowertype_helper_t&&)
    cdef cppclass format_data_info_t:  # ------------------------------------------------------------
        int ptvf
        int radix  # number representation (8,10,16)
        int max_length  # max length of the formatted text (0 means no limit
        int arrbase  # for arrays: the first element of array to print
        int arrnelems  # for arrays: number of elements to print
        int margin  # length of one line (0 means to print everything on
        int indent  # how many spaces to use to indent nested structures
        format_data_info_t()
    cdef cppclass valinfo_t:  # Additional information about the output lines
        argloc_t loc
        qstring label
        tinfo_t type
        valinfo_t(argloc_t l, char* name, tinfo_t& tif)
        void swap(valinfo_t& r)
        valinfo_t(valinfo_t&)
        valinfo_t(valinfo_t&&)
        valinfo_t& operator=(valinfo_t&)
        valinfo_t& operator=(valinfo_t&&)
    cdef cppclass valstr_t:  # Text representation of a data value (value string). This str
        qstring oneline  # result if printed on one line in UTF-8 encoding
        size_t length  # length if printed on one line
        valstrs_t* members  # strings for members, each member separately
        valinfo_t* info  # additional info
        int props  # temporary properties, used internally
        valstr_t()
    cdef cppclass flatten_args_t:
        valstr_t* may_not_collapse
        int ptvf
        int max_length
        int margin
        int indent
    cdef cppclass valstrs_t:
        pass
    cdef cppclass text_sink_t:  # Flush formatted text
        int print(char* str)
        text_sink_t& operator=(text_sink_t&)
    cdef cppclass til_symbol_t:  # A symbol in a type library
        char* name  # symbol name
        til_t* til  # pointer to til
        til_symbol_t(char* n, til_t* t)
    cdef cppclass predicate_t:  # Helper class for choose_named_type(). Controls which types a
        bint should_display(til_t* til, char* name, type_t* type, p_list* fields)
        predicate_t& operator=(predicate_t&)
    cdef cppclass til_type_ref_t:  # ------------------------------------------------------------
        size_t cb
        tinfo_t tif  # type info, !empty() during runtime
        tif_cursor_t cursor  # 'pointer' inside a type
        uint32 ordinal  # cached value of tif.get_ordinal()
        bint is_writable  # can we modify the type? (either in a RW til, or wr
        bint is_detached  # type is not backed by a backend that will cause vi
        bint is_forward  # is the type a forward declaration?
        type_t kind  # one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENU
        ssize_t memidx  # index of the current BTF_STRUCT, BTF_UNION, BTF_EN
        size_t nmembers  # number of members in the BTF_STRUCT, BTF_UNION, BT
        udm_t udm  # BTF_STRUCT or BTF_UNION: the current member
        size_t total_size
        size_t unpadded_size
        uint64 last_udm_offset
        uint64 bucket_start  # bucket offset (equal to 'offset' except for bitfie
        int bf_bitoff  # for bitfields, bit offset from bucket_start
        uint64 offset  # the current offset (regardless if we have a define
        edm_t edm  # BTF_ENUM: the current enum member
        funcarg_t* fa  # BT_FUNC: the current argument, nullptr - ellipsis
        void clear()
        bint on_member() const
        bint is_typedef() const
        bint is_struct() const
        bint is_union() const
        bint is_enum() const
        bint is_func() const
        bint is_udt() const
        til_type_ref_t(til_type_ref_t&)
        til_type_ref_t(til_type_ref_t&&)
        til_type_ref_t& operator=(til_type_ref_t&)
        til_type_ref_t& operator=(til_type_ref_t&&)
        til_type_ref_t()

    # =========================================================================
    # Functions
    # =========================================================================
    int isascii(int _c)
    int isalnum(int _c)
    int isalpha(int _c)
    int isblank(int _c)
    int iscntrl(int _c)
    int isdigit(int _c)
    int isgraph(int _c)
    int islower(int _c)
    int isprint(int _c)
    int ispunct(int _c)
    int isspace(int _c)
    int isupper(int _c)
    int isxdigit(int _c)
    int toascii(int _c)
    int tolower(int _c)
    int toupper(int _c)
    int digittoint(int _c)
    int ishexnumber(int _c)
    int isideogram(int _c)
    int isnumber(int _c)
    int isphonogram(int _c)
    int isrune(int _c)
    int isspecial(int _c)
    int __sputc(int _c, FILE* _p)
    int __darwin_check_fd_set(int _a, void* _b)
    void __darwin_fd_set(int _fd, fd_set*const _p)
    void __darwin_fd_clr(int _fd, fd_set*const _p)
    int64 make_int64(uint32 ll, int32 hh)
    uint64 make_uint64(uint32 ll, int32 hh)
    uint32 low(uint64& x)
    uint32 high(uint64& x)
    int64 llong_scan(char* buf, int radix, char** end)
    uint64 swap64(uint64)
    int64 qatoll(char* nptr)
    void qexit(int code)  # Call qatexit functions, shut down UI and kernel, and exit. 
    bint test_bit(uchar* bitmap, size_t bit)  # ---------------------------------------------------------...
    void set_bit(uchar* bitmap, size_t bit)  # Set 'bit' in 'bitmap'
    void clear_bit(uchar* bitmap, size_t bit)  # Clear 'bit' in 'bitmap'
    void set_bits(uchar* bitmap, size_t low, size_t high)  # Set bits between [low, high) in 'bitmap'
    void clear_bits(uchar* bitmap, size_t low, size_t high)  # Clear bits between [low, high) in 'bitmap'
    void set_all_bits(uchar* bitmap, size_t nbits)  # Set first 'nbits' of 'bitmap'
    void clear_all_bits(uchar* bitmap, size_t nbits)  # Clear first 'nbits' of 'bitmap'
    int log2ceil(uint64 d64)  # calculate ceil(log2(d64)) or floor(log2(d64)), it...
    int log2floor(uint64 d64)
    int bitcount(uint64 x)  # count the number of non-zero bits (the population count)
    int bitcountr_zero(uint64 x)  # count the number of consecutive trailing zero bits (line...
    uint32 round_up_power2(uint32 x)  # round up or down to a power of 2
    uint32 round_down_power2(uint32 x)
    uval_t last(uval_t off, asize_t s)  # max offset of the interval (assume s != 0)
    bint overlap(uval_t off1, asize_t s1, uval_t off2, asize_t s2)  # Do (off1,s1) and (off2,s2) overlap?
    bint includes(uval_t off1, asize_t s1, uval_t off2, asize_t s2)  # Does (off1,s1) include (off2,s2)?
    bint contains(uval_t off1, asize_t s1, uval_t off)  # Does (off1,s1) contain off?
    uint64 extend_sign(uint64 v, int nbytes, bint sign_extend)  # ---------------------------------------------------------...
    int readbytes(int h, uint32* res, int size, bint mf)  # ---------------------------------------------------------...
    int writebytes(int h, uint32 l, int size, bint mf)  # Write at most 4 bytes to file. 
    int read2bytes(int h, uint16* res, bint mf)  # Read a 2 byte entity from a file. 
    uint32 swap32(uint32 x)
    ushort swap16(ushort x)
    void swap_value(void* dst, void* src, int size)  # Swap endianness of a given value in memory. 
    void reloc_value(void* value, int size, adiff_t delta, bint mf)
    uval_t rotate_left(uval_t x, int count, size_t bits, size_t offset)  # Rotate left - can be used to rotate a value to the right...
    void* qalloc_or_throw(size_t size)  # qalloc() 'size' bytes, and throw a "not enough memory"...
    void* qrealloc_or_throw(void* ptr, size_t size)  # qrealloc() 'ptr' by 'size', and throw a "not enough...
    void* qvector_reserve(void* vec, void* old, size_t cnt, size_t elsize)  # Change capacity of given qvector. 
    size_t qstrlen(char* s)  # ---------------------------------------------------------...
    int qstrcmp(char* s1, char* s2)  #  Lexical comparison of strings. 
    int qstrncmp(char* s1, char* s2, size_t len)  #  Lexical comparison of string prefixes. 
    char* qstrstr(char* s1, char* s2)  #  Find a string within another string. 
    char* qstrchr(char* s1, char c)  #  Find a character within a string. 
    char* qstrrchr(char* s1, char c)  #  Find a last occurrence of a character within a string. 
    uint32 calc_crc32(uint32 crc, void* buf, size_t len)  # Calculate CRC32 (polynom 0xEDB88320, zlib compatible). 
    bint base64_encode(qstring* output, void* input, size_t size)  # Encode base64
    bint base64_decode(bytevec_t* output, char* input, size_t size)  # Decode base64
    bint replace_tabs(qstring* out, char* str, int tabsize)  # Convert tabulations to spaces 
    char* str2user(char* dst, char* src, size_t dstsize)  #  String C-style conversions (convert \ n to a newline...
    char* user2str(char* dst, char* src, size_t dstsize)
    char back_char(char** p)
    void qstr2user(qstring* dst, char* src, int nsyms)
    void user2qstr(qstring* dst, qstring& src)
    bint is_utf8_head(char in_)  # Does this byte correspond to the head of a UTF-8 byte...
    bint is_utf8_tail(char in_)  # Does this byte correspond to the tail of a UTF-8 byte sequence? 
    bint is_valid_utf8(char* in_)  # Does byte sequence consist of valid UTF-8-encoded codepoints? 
    bint utf8_utf16(qwstring* out, char* in_, int nsyms)  # UTF-8 -> UTF-16 
    bint utf16_utf8(qstring* out, wchar16_t* in_, int nsyms)  # UTF-16 -> UTF-8 
    bint is_lead_surrogate(wchar32_t wch)
    bint is_tail_surrogate(wchar32_t wch)
    wchar32_t utf16_surrogates_to_cp(wchar16_t lead_surrogate, wchar16_t tail_surrogate)
    bint idb_utf8(qstring* out, char* in_, int nsyms, int flags)  # IDB default C string encoding -> UTF-8 
    bint change_codepage(qstring*, char*, int, int)
    wchar16_t utf8_wchar16(uchar b0, uchar b1)  # ---------------------------------------------------------...
    wchar32_t utf8_wchar32(uchar b0, uchar b1, uchar b2, uchar b3)  # ---------------------------------------------------------...
    wchar32_t get_utf8_char(char** pptr)  # Read one UTF-8 character from string. if error, return BADCP
    bint prev_utf8_char(wchar32_t* out_cp, char** p, char* begin)  # Get the UTF-8 character from string, before 'p'. 
    size_t skip_utf8(char** putf8, size_t n)  # Advance by n codepoints into the UTF-8 buffer. Each bad...
    ssize_t put_utf8_char(char* out, wchar32_t cp)  # Encode the codepoint into a UTF-8 byte sequence, and add...
    bint is_cp_graphical(wchar32_t cp)  # Is the provided codepoint graphical?
    size_t qustrlen(char* utf8)  # Get number of codepoints in UTF-8 string. Any 'bad' byte...
    bint qustrncpy(char* dst, char* utf8, size_t dstsize)  # A safer strncpy - makes sure that there is a terminating...
    bint is_cvt64()  # ---------------------------------------------------------...
    ssize_t convert_encoding(bytevec_t* out, char* fromcode, char* tocode, uchar* indata, ssize_t insize, int flags)  # Convert data from encoding fromcode into tocode. 
    size_t parse_command_line(qstrvec_t* args, channel_redirs_t* redirs, char* cmdline, int flags)  # Parse a space separated string (escaping with backslash...
    char** expand_argv(int* p_argc, int argc, char** argv)  # Copy and expand command line arguments. For ' '...
    void free_argv(int argc, char** argv)  # Free 'argc' elements of 'argv'
    bint quote_cmdline_arg(qstring* arg)  # Quote a command line argument if it contains escape...
    bint parse_plugin_options(plugin_options_t* opts, char* optstring)  # Parse plugin options from IDA command line specified by...
    void build_plugin_options(qstring* out, plugin_options_t& opts, char* optname)  # Build the plugin options, suitable for IDA command line...
    bint parse_dbgopts(instant_dbgopts_t* ido, char* r_switch)  # Parse the -r command line switch (for instant...
    void* launch_process(launch_process_params_t& lpp, qstring* errbuf)
    int term_process(void* handle)  # Forcibly terminate a running process. 
    int qwait_timed(int* status, int child, int flags, int timeout_ms)  # Wait for state changes in a child process (UNIX only)....
    int qwait(int* status, int child, int flags)
    int check_process_exit(void* handle, int* exit_code, int msecs)  # Check whether process has terminated or not. 
    tty_control_t is_control_tty(int fd)  # Check if the current process is the owner of the TTY...
    void qdetach_tty()  # If the current terminal is the controlling terminal of...
    void qcontrol_tty()  # Make the current terminal the controlling terminal of...
    bint is_main_thread()  # Are we running in the main thread?
    bint qsetenv(char* varname, char* value)  # Thread safe function to work with the environment
    bint qgetenv(char* varname, qstring* buf)
    int qpipe_create(qhandle_t* handles)  # Create a pipe. 
    ssize_t qpipe_read(qhandle_t handle, void* buf, size_t size)  # Read from a pipe.
    bint qpipe_read_n(qhandle_t handle, bytevec_t* out_bytes, size_t n)  # Read a specific amount of bytes from a pipe. 
    ssize_t qpipe_write(qhandle_t handle, void* buf, size_t size)  # Write to a pipe.
    int qpipe_close(qhandle_t handle)  # Close a pipe.
    void* pipe_process(qhandle_t* read_handle, qhandle_t* write_handle, launch_process_params_t* lpp, qstring* errbuf)  # Launch a process and establish 2-way comminucation with...
    int qwait_for_handles(int* idx, qhandle_t* handles, int n, uint32 write_bitmask, int timeout_ms)  # Wait for file/socket/pipe handles. 
    bint get_login_name(qstring* out)  # Get the user name for the current desktop session 
    int get_physical_core_count()  # Get the total CPU physical core count 
    int get_logical_core_count()  # Get the total CPU logical core count 
    int get_available_core_count()  # Get the number of logical CPU cores available to the...
    FILE* qfopen(char* file, char* mode)  #  The following functions work just like their...
    ssize_t qfread(FILE* fp, void* buf, size_t n)
    ssize_t qfwrite(FILE* fp, void* buf, size_t n)
    int qftell(FILE* fp)
    int qfseek(FILE* fp, int offset, int whence)
    int qfclose(FILE* fp)
    int qflush(FILE* fp)
    int qfputc(int chr, FILE* fp)
    int qfgetc(FILE* fp)
    char* qfgets(char* s, size_t len, FILE* fp)
    int qfputs(char* s, FILE* fp)
    FILE* qtmpfile()
    int qunlink(char* fname)
    int qaccess(char* fname, int mode)
    char* qgets(char* line, size_t linesize)
    uint64 qfsize(FILE* fp)
    int qfprintf(FILE* fp, char* format)
    int qprintf(char* format)
    int qeprintf(char* format)
    int qfscanf(FILE* fp, char* format)
    ssize_t qgetline(qstring* buf, FILE* fp)  # Read line from file (the newline is removed from the...
    int qrename(char* oldfname, char* newfname)  # Rename a file: 'newname' may exist, and will be deleted
    int qmove(char* oldfname, char* newfname, uint32 flags)  # Move a file - more powerful version of qrename 
    char* qtmpdir(char* buf, size_t bufsize)  # Get temporary directory name Returns absolute path
    char* qtmpnam(char* buf, size_t bufsize)  # Get temporary file name. Returns absolute path (includes...
    int freadbytes(FILE* fp, void* res, int size, int mostfirst)  #  Add-ins for 2..32 byte read/writes. 
    int fwritebytes(FILE* fp, void* l, int size, int mostfirst)
    fpvalue_error_t ieee_realcvt(void* m, fpvalue_t* out, uint16 swt)  # Standard IEEE 754 floating point conversion function 
    void realtoasc(char* buf, size_t bufsize, fpvalue_t& x, uint mode)  # Helper functions. Better use members of fpvalue_t, they...
    fpvalue_error_t asctoreal(char** sss, fpvalue_t* out)
    void eltoe(sval_t l, fpvalue_t* vout)
    void eltoe64(int64 l, fpvalue_t* vout)
    void eltoe64u(uint64 l, fpvalue_t* vout)
    fpvalue_error_t eetol(sval_t* out, fpvalue_t& a, bint roundflg)
    fpvalue_error_t eetol64(int64* out, fpvalue_t& a, bint roundflg)
    fpvalue_error_t eetol64u(uint64* out, fpvalue_t& a, bint roundflg)
    fpvalue_error_t eldexp(fpvalue_t& a, int32 pwr2, fpvalue_t* zout)
    fpvalue_error_t eadd(fpvalue_t& a, fpvalue_t& b, fpvalue_t* zout, bint subflg)
    fpvalue_error_t emul(fpvalue_t& a, fpvalue_t& b, fpvalue_t* zout)
    fpvalue_error_t ediv(fpvalue_t& a, fpvalue_t& b, fpvalue_t* zout)
    int ecmp(fpvalue_t& a, fpvalue_t& b)
    fpvalue_kind_t get_fpvalue_kind(fpvalue_t& a, uint16 reserved)
    void ecleaz(uint16* x)
    void emovo(uint16* a, fpvalue_t* vout)
    void emovi(fpvalue_t& a, uint16* vout)  # Move eNI => eNE
    int eshift(uint16* x, int sc)  # Move eNE => eNI
    bint emdnorm(uint16* s, bint lost, bint subflg, int32 exp, int rndbase)  # Shift NI format up (+) or down Normalize and round off. 
    bint is_filetype_like_binary(filetype_t ft)  # Is unstructured input file?
    size_t getinf(inftag_t tag)  # Get program specific information (a scalar value) 
    ssize_t getinf_buf(inftag_t tag, void* buf, size_t bufsize)  # Get program specific information (a non-scalar value) 
    ssize_t getinf_str(qstring* buf, inftag_t tag)  # Get program specific information (a non-scalar value) 
    bint getinf_flag(inftag_t tag, uint32 flag)  # Get a flag value 
    bint setinf(inftag_t tag, ssize_t value)  # Set program specific information 
    bint setinf_buf(inftag_t tag, void* buf, size_t bufsize)  # Set program specific information 
    bint setinf_flag(inftag_t tag, uint32 flag, bint value)  # Set a flag value 
    bint delinf(inftag_t tag)  # Undefine a program specific information 
    ushort inf_get_version()  #  <INF _ACCESSORS>
    bint inf_set_version(ushort _v)
    ushort inf_get_genflags()
    bint inf_set_genflags(ushort _v)
    bint inf_is_auto_enabled()
    bint inf_set_auto_enabled(bint _v)
    bint inf_use_allasm()
    bint inf_set_use_allasm(bint _v)
    bint inf_loading_idc()
    bint inf_set_loading_idc(bint _v)
    bint inf_no_store_user_info()
    bint inf_set_no_store_user_info(bint _v)
    bint inf_readonly_idb()
    bint inf_set_readonly_idb(bint _v)
    bint inf_check_manual_ops()
    bint inf_set_check_manual_ops(bint _v)
    bint inf_allow_non_matched_ops()
    bint inf_set_allow_non_matched_ops(bint _v)
    bint inf_is_graph_view()
    bint inf_set_graph_view(bint _v)
    uint32 inf_get_lflags()
    bint inf_set_lflags(uint32 _v)
    bint inf_decode_fpp()
    bint inf_set_decode_fpp(bint _v)
    bint inf_is_32bit_or_higher()  # unfortunately the name inf_is_32bit was used in the past...
    bint inf_is_32bit_exactly()
    bint inf_set_32bit(bint _v)
    bint inf_is_16bit()
    bint inf_is_64bit()
    bint inf_set_64bit(bint _v)
    bint inf_is_ilp32()
    bint inf_set_ilp32(bint _v)
    bint inf_is_dll()
    bint inf_set_dll(bint _v)
    bint inf_is_flat_off32()
    bint inf_set_flat_off32(bint _v)
    bint inf_is_be()
    bint inf_set_be(bint _v)
    bint inf_is_wide_high_byte_first()
    bint inf_set_wide_high_byte_first(bint _v)
    bint inf_dbg_no_store_path()
    bint inf_set_dbg_no_store_path(bint _v)
    bint inf_is_snapshot()
    bint inf_set_snapshot(bint _v)
    bint inf_pack_idb()
    bint inf_set_pack_idb(bint _v)
    bint inf_compress_idb()
    bint inf_set_compress_idb(bint _v)
    bint inf_is_kernel_mode()
    bint inf_set_kernel_mode(bint _v)
    uint inf_get_app_bitness()
    void inf_set_app_bitness(uint bitness)
    uint32 inf_get_database_change_count()
    bint inf_set_database_change_count(uint32 _v)
    filetype_t inf_get_filetype()
    bint inf_set_filetype(filetype_t _v)
    ushort inf_get_ostype()
    bint inf_set_ostype(ushort _v)
    ushort inf_get_apptype()
    bint inf_set_apptype(ushort _v)
    uchar inf_get_asmtype()
    bint inf_set_asmtype(uchar _v)
    uchar inf_get_specsegs()
    bint inf_set_specsegs(uchar _v)
    uint32 inf_get_af()
    bint inf_set_af(uint32 _v)
    bint inf_trace_flow()
    bint inf_set_trace_flow(bint _v)
    bint inf_mark_code()
    bint inf_set_mark_code(bint _v)
    bint inf_create_jump_tables()
    bint inf_set_create_jump_tables(bint _v)
    bint inf_noflow_to_data()
    bint inf_set_noflow_to_data(bint _v)
    bint inf_create_all_xrefs()
    bint inf_set_create_all_xrefs(bint _v)
    bint inf_del_no_xref_insns()
    bint inf_set_del_no_xref_insns(bint _v)
    bint inf_create_func_from_ptr()
    bint inf_set_create_func_from_ptr(bint _v)
    bint inf_create_func_from_call()
    bint inf_set_create_func_from_call(bint _v)
    bint inf_create_func_tails()
    bint inf_set_create_func_tails(bint _v)
    bint inf_should_create_stkvars()
    bint inf_set_should_create_stkvars(bint _v)
    bint inf_propagate_stkargs()
    bint inf_set_propagate_stkargs(bint _v)
    bint inf_propagate_regargs()
    bint inf_set_propagate_regargs(bint _v)
    bint inf_should_trace_sp()
    bint inf_set_should_trace_sp(bint _v)
    bint inf_full_sp_ana()
    bint inf_set_full_sp_ana(bint _v)
    bint inf_noret_ana()
    bint inf_set_noret_ana(bint _v)
    bint inf_guess_func_type()
    bint inf_set_guess_func_type(bint _v)
    bint inf_truncate_on_del()
    bint inf_set_truncate_on_del(bint _v)
    bint inf_create_strlit_on_xref()
    bint inf_set_create_strlit_on_xref(bint _v)
    bint inf_check_unicode_strlits()
    bint inf_set_check_unicode_strlits(bint _v)
    bint inf_create_off_using_fixup()
    bint inf_set_create_off_using_fixup(bint _v)
    bint inf_create_off_on_dref()
    bint inf_set_create_off_on_dref(bint _v)
    bint inf_op_offset()
    bint inf_set_op_offset(bint _v)
    bint inf_data_offset()
    bint inf_set_data_offset(bint _v)
    bint inf_use_flirt()
    bint inf_set_use_flirt(bint _v)
    bint inf_append_sigcmt()
    bint inf_set_append_sigcmt(bint _v)
    bint inf_allow_sigmulti()
    bint inf_set_allow_sigmulti(bint _v)
    bint inf_hide_libfuncs()
    bint inf_set_hide_libfuncs(bint _v)
    bint inf_rename_jumpfunc()
    bint inf_set_rename_jumpfunc(bint _v)
    bint inf_rename_nullsub()
    bint inf_set_rename_nullsub(bint _v)
    bint inf_coagulate_data()
    bint inf_set_coagulate_data(bint _v)
    bint inf_coagulate_code()
    bint inf_set_coagulate_code(bint _v)
    bint inf_final_pass()
    bint inf_set_final_pass(bint _v)
    uint32 inf_get_af2()
    bint inf_set_af2(uint32 _v)
    bint inf_handle_eh()
    bint inf_set_handle_eh(bint _v)
    bint inf_handle_rtti()
    bint inf_set_handle_rtti(bint _v)
    bint inf_macros_enabled()
    bint inf_set_macros_enabled(bint _v)
    bint inf_merge_strlits()
    bint inf_set_merge_strlits(bint _v)
    uval_t inf_get_baseaddr()
    bint inf_set_baseaddr(uval_t _v)
    sel_t inf_get_start_ss()
    bint inf_set_start_ss(sel_t _v)
    sel_t inf_get_start_cs()
    bint inf_set_start_cs(sel_t _v)
    ea_t inf_get_start_ip()
    bint inf_set_start_ip(ea_t _v)
    ea_t inf_get_start_ea()
    bint inf_set_start_ea(ea_t _v)
    ea_t inf_get_start_sp()
    bint inf_set_start_sp(ea_t _v)
    ea_t inf_get_main()
    bint inf_set_main(ea_t _v)
    ea_t inf_get_min_ea()
    bint inf_set_min_ea(ea_t _v)
    ea_t inf_get_max_ea()
    bint inf_set_max_ea(ea_t _v)
    ea_t inf_get_omin_ea()
    bint inf_set_omin_ea(ea_t _v)
    ea_t inf_get_omax_ea()
    bint inf_set_omax_ea(ea_t _v)
    ea_t inf_get_lowoff()
    bint inf_set_lowoff(ea_t _v)
    ea_t inf_get_highoff()
    bint inf_set_highoff(ea_t _v)
    uval_t inf_get_maxref()
    bint inf_set_maxref(uval_t _v)
    sval_t inf_get_netdelta()
    bint inf_set_netdelta(sval_t _v)
    uchar inf_get_xrefnum()
    bint inf_set_xrefnum(uchar _v)
    uchar inf_get_type_xrefnum()
    bint inf_set_type_xrefnum(uchar _v)
    uchar inf_get_refcmtnum()
    bint inf_set_refcmtnum(uchar _v)
    uchar inf_get_xrefflag()
    bint inf_set_xrefflag(uchar _v)
    bint inf_show_xref_seg()
    bint inf_set_show_xref_seg(bint _v)
    bint inf_show_xref_tmarks()
    bint inf_set_show_xref_tmarks(bint _v)
    bint inf_show_xref_fncoff()
    bint inf_set_show_xref_fncoff(bint _v)
    bint inf_show_xref_val()
    bint inf_set_show_xref_val(bint _v)
    ushort inf_get_max_autoname_len()
    bint inf_set_max_autoname_len(ushort _v)
    char inf_get_nametype()
    bint inf_set_nametype(char _v)
    uint32 inf_get_short_demnames()
    bint inf_set_short_demnames(uint32 _v)
    uint32 inf_get_long_demnames()
    bint inf_set_long_demnames(uint32 _v)
    uchar inf_get_demnames()
    bint inf_set_demnames(uchar _v)
    uchar inf_get_listnames()
    bint inf_set_listnames(uchar _v)
    uchar inf_get_indent()
    bint inf_set_indent(uchar _v)
    uchar inf_get_cmt_indent()
    bint inf_set_cmt_indent(uchar _v)
    ushort inf_get_margin()
    bint inf_set_margin(ushort _v)
    ushort inf_get_lenxref()
    bint inf_set_lenxref(ushort _v)
    uint32 inf_get_outflags()
    bint inf_set_outflags(uint32 _v)
    bint inf_show_void()
    bint inf_set_show_void(bint _v)
    bint inf_show_auto()
    bint inf_set_show_auto(bint _v)
    bint inf_gen_null()
    bint inf_set_gen_null(bint _v)
    bint inf_show_line_pref()
    bint inf_set_show_line_pref(bint _v)
    bint inf_line_pref_with_seg()
    bint inf_set_line_pref_with_seg(bint _v)
    bint inf_gen_lzero()
    bint inf_set_gen_lzero(bint _v)
    bint inf_gen_org()
    bint inf_set_gen_org(bint _v)
    bint inf_gen_assume()
    bint inf_set_gen_assume(bint _v)
    bint inf_gen_tryblks()
    bint inf_set_gen_tryblks(bint _v)
    uchar inf_get_cmtflg()
    bint inf_set_cmtflg(uchar _v)
    bint inf_show_repeatables()
    bint inf_set_show_repeatables(bint _v)
    bint inf_show_all_comments()
    bint inf_set_show_all_comments(bint _v)
    bint inf_hide_comments()
    bint inf_set_hide_comments(bint _v)
    bint inf_show_src_linnum()
    bint inf_set_show_src_linnum(bint _v)
    bint inf_test_mode()
    bint inf_show_hidden_insns()
    bint inf_set_show_hidden_insns(bint _v)
    bint inf_show_hidden_funcs()
    bint inf_set_show_hidden_funcs(bint _v)
    bint inf_show_hidden_segms()
    bint inf_set_show_hidden_segms(bint _v)
    uchar inf_get_limiter()
    bint inf_set_limiter(uchar _v)
    bint inf_is_limiter_thin()
    bint inf_set_limiter_thin(bint _v)
    bint inf_is_limiter_thick()
    bint inf_set_limiter_thick(bint _v)
    bint inf_is_limiter_empty()
    bint inf_set_limiter_empty(bint _v)
    short inf_get_bin_prefix_size()
    bint inf_set_bin_prefix_size(short _v)
    uchar inf_get_prefflag()
    bint inf_set_prefflag(uchar _v)
    bint inf_prefix_show_segaddr()
    bint inf_set_prefix_show_segaddr(bint _v)
    bint inf_prefix_show_funcoff()
    bint inf_set_prefix_show_funcoff(bint _v)
    bint inf_prefix_show_stack()
    bint inf_set_prefix_show_stack(bint _v)
    bint inf_prefix_truncate_opcode_bytes()
    bint inf_set_prefix_truncate_opcode_bytes(bint _v)
    uchar inf_get_strlit_flags()
    bint inf_set_strlit_flags(uchar _v)
    bint inf_strlit_names()
    bint inf_set_strlit_names(bint _v)
    bint inf_strlit_name_bit()
    bint inf_set_strlit_name_bit(bint _v)
    bint inf_strlit_serial_names()
    bint inf_set_strlit_serial_names(bint _v)
    bint inf_unicode_strlits()
    bint inf_set_unicode_strlits(bint _v)
    bint inf_strlit_autocmt()
    bint inf_set_strlit_autocmt(bint _v)
    bint inf_strlit_savecase()
    bint inf_set_strlit_savecase(bint _v)
    uchar inf_get_strlit_break()
    bint inf_set_strlit_break(uchar _v)
    char inf_get_strlit_zeroes()
    bint inf_set_strlit_zeroes(char _v)
    int32 inf_get_strtype()
    bint inf_set_strtype(int32 _v)
    uval_t inf_get_strlit_sernum()
    bint inf_set_strlit_sernum(uval_t _v)
    uval_t inf_get_datatypes()
    bint inf_set_datatypes(uval_t _v)
    uint32 inf_get_abibits()
    bint inf_set_abibits(uint32 _v)
    bint inf_is_mem_aligned4()
    bint inf_set_mem_aligned4(bint _v)
    bint inf_pack_stkargs()
    bint inf_set_pack_stkargs(bint _v)
    bint inf_big_arg_align()
    bint inf_set_big_arg_align(bint _v)
    bint inf_stack_ldbl()
    bint inf_set_stack_ldbl(bint _v)
    bint inf_stack_varargs()
    bint inf_set_stack_varargs(bint _v)
    bint inf_is_hard_float()
    bint inf_set_hard_float(bint _v)
    bint inf_abi_set_by_user()
    bint inf_set_abi_set_by_user(bint _v)
    bint inf_use_gcc_layout()
    bint inf_set_use_gcc_layout(bint _v)
    bint inf_map_stkargs()
    bint inf_set_map_stkargs(bint _v)
    bint inf_huge_arg_align()
    bint inf_set_huge_arg_align(bint _v)
    uint32 inf_get_appcall_options()
    bint inf_set_appcall_options(uint32 _v)
    ea_t inf_get_privrange_start_ea()
    bint inf_set_privrange_start_ea(ea_t _v)
    ea_t inf_get_privrange_end_ea()
    bint inf_set_privrange_end_ea(ea_t _v)
    comp_t inf_get_cc_id()
    bint inf_set_cc_id(comp_t _v)
    cm_t inf_get_cc_cm()
    bint inf_set_cc_cm(cm_t _v)
    callcnv_t inf_get_callcnv()
    bint inf_set_callcnv(callcnv_t _v)
    uchar inf_get_cc_size_i()
    bint inf_set_cc_size_i(uchar _v)
    uchar inf_get_cc_size_b()
    bint inf_set_cc_size_b(uchar _v)
    uchar inf_get_cc_size_e()
    bint inf_set_cc_size_e(uchar _v)
    uchar inf_get_cc_defalign()
    bint inf_set_cc_defalign(uchar _v)
    uchar inf_get_cc_size_s()
    bint inf_set_cc_size_s(uchar _v)
    uchar inf_get_cc_size_l()
    bint inf_set_cc_size_l(uchar _v)
    uchar inf_get_cc_size_ll()
    bint inf_set_cc_size_ll(uchar _v)
    uchar inf_get_cc_size_ldbl()
    bint inf_set_cc_size_ldbl(uchar _v)
    bint inf_get_procname(char* buf, size_t bufsize)
    bint inf_set_procname(char* _v, size_t len)
    bint inf_get_strlit_pref(char* buf, size_t bufsize)
    bint inf_set_strlit_pref(char* _v, size_t len)
    bint inf_get_cc(compiler_info_t* out)
    bint inf_set_cc(compiler_info_t& _v)
    bint inf_get_privrange(range_t* out)
    bint inf_set_privrange(range_t& _v)
    ushort inf_get_af_low()  # Get/set low/high 16bit halves of inf.af
    void inf_set_af_low(ushort saf)
    ushort inf_get_af_high()
    void inf_set_af_high(ushort saf2)
    ushort inf_get_af2_low()  # Get/set low 16bit half of inf.af2
    void inf_set_af2_low(ushort saf)
    int inf_get_pack_mode()
    int inf_set_pack_mode(int pack_mode)
    void inf_inc_database_change_count(int cnt)
    uchar inf_get_demname_form()  # Get #DEMNAM_MASK bits of #demnames
    uval_t inf_postinc_strlit_sernum(uval_t cnt)
    bint inf_like_binary()
    int calc_default_idaplace_flags()  # Get default disassembly line options
    ea_t to_ea(sel_t reg_cs, uval_t reg_ip)  # ---------------------------------------------------------...
    bint register_post_event_visitor(hook_type_t hook_type, post_event_visitor_t* visitor, plugmod_t* owner)  # Register the post-event visitor. The kernel will not...
    bint unregister_post_event_visitor(hook_type_t hook_type, post_event_visitor_t* visitor)  # Unregister the post-event visitor. 
    ssize_t get_dbctx_id()  # Get the current database context ID 
    size_t get_dbctx_qty()  # Get number of database contexts 
    bint is_database_busy()  # Check if the database is busy (e.g. performing some...
    size_t validate_idb(uint32 vld_flags)  # Validate the database 
    bint move_privrange(ea_t new_privrange_start)  # Move privrange to the specified address 
    bint netnode_check(netnode*, char* name, size_t namlen, bint create)
    void netnode_kill(netnode*)
    bint netnode_start(netnode*)
    bint netnode_end(netnode*)
    bint netnode_next(netnode*)
    bint netnode_prev(netnode*)
    ssize_t netnode_get_name(nodeidx_t num, qstring* out)
    bint netnode_rename(nodeidx_t num, char* newname, size_t namlen)
    ssize_t netnode_valobj(nodeidx_t num, void* buf, size_t bufsize)
    ssize_t netnode_valstr(nodeidx_t num, char* buf, size_t bufsize)
    ssize_t netnode_qvalstr(nodeidx_t num, qstring* buf)
    bint netnode_set(nodeidx_t num, void* value, size_t length)
    bint netnode_delvalue(nodeidx_t num)
    nodeidx_t netnode_altval(nodeidx_t num, nodeidx_t alt, int tag)
    uchar netnode_charval(nodeidx_t num, nodeidx_t alt, int tag)
    nodeidx_t netnode_altval_idx8(nodeidx_t num, uchar alt, int tag)
    uchar netnode_charval_idx8(nodeidx_t num, uchar alt, int tag)
    ssize_t netnode_supval(nodeidx_t num, nodeidx_t alt, void* buf, size_t bufsize, int tag)
    ssize_t netnode_supstr(nodeidx_t num, nodeidx_t alt, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qsupstr(nodeidx_t num, qstring* buf, nodeidx_t alt, int tag)
    bint netnode_supset(nodeidx_t num, nodeidx_t alt, void* value, size_t length, int tag)
    bint netnode_supdel(nodeidx_t num, nodeidx_t alt, int tag)
    nodeidx_t netnode_lower_bound(nodeidx_t num, nodeidx_t cur, int tag)
    nodeidx_t netnode_supfirst(nodeidx_t num, int tag)
    nodeidx_t netnode_supnext(nodeidx_t num, nodeidx_t cur, int tag)
    nodeidx_t netnode_suplast(nodeidx_t num, int tag)
    nodeidx_t netnode_supprev(nodeidx_t num, nodeidx_t cur, int tag)
    ssize_t netnode_supval_idx8(nodeidx_t num, uchar alt, void* buf, size_t bufsize, int tag)
    ssize_t netnode_supstr_idx8(nodeidx_t num, uchar alt, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qsupstr_idx8(nodeidx_t num, qstring* buf, uchar alt, int tag)
    bint netnode_supset_idx8(nodeidx_t num, uchar alt, void* value, size_t length, int tag)
    bint netnode_supdel_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_lower_bound_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_supfirst_idx8(nodeidx_t num, int tag)
    nodeidx_t netnode_supnext_idx8(nodeidx_t num, uchar alt, int tag)
    nodeidx_t netnode_suplast_idx8(nodeidx_t num, int tag)
    nodeidx_t netnode_supprev_idx8(nodeidx_t num, uchar alt, int tag)
    bint netnode_supdel_all(nodeidx_t num, int tag)
    int netnode_supdel_range(nodeidx_t num, nodeidx_t idx1, nodeidx_t idx2, int tag)
    int netnode_supdel_range_idx8(nodeidx_t num, nodeidx_t idx1, nodeidx_t idx2, int tag)
    ssize_t netnode_hashval(nodeidx_t num, char* idx, void* buf, size_t bufsize, int tag)
    ssize_t netnode_hashstr(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashstr(nodeidx_t num, qstring* buf, char* idx, int tag)
    nodeidx_t netnode_hashval_long(nodeidx_t num, char* idx, int tag)
    bint netnode_hashset(nodeidx_t num, char* idx, void* value, size_t length, int tag)
    bint netnode_hashdel(nodeidx_t num, char* idx, int tag)
    ssize_t netnode_hashfirst(nodeidx_t num, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashfirst(nodeidx_t num, qstring* buf, int tag)
    ssize_t netnode_hashnext(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashnext(nodeidx_t num, qstring* buf, char* idx, int tag)
    ssize_t netnode_hashlast(nodeidx_t num, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashlast(nodeidx_t num, qstring* buf, int tag)
    ssize_t netnode_hashprev(nodeidx_t num, char* idx, char* buf, size_t bufsize, int tag)
    ssize_t netnode_qhashprev(nodeidx_t num, qstring* buf, char* idx, int tag)
    size_t netnode_blobsize(nodeidx_t num, nodeidx_t start, int tag)
    void* netnode_getblob(nodeidx_t num, void* buf, size_t* bufsize, nodeidx_t start, int tag)
    ssize_t netnode_qgetblob(nodeidx_t num, bytevec_t* buf, size_t elsize, nodeidx_t start, int tag)
    bint netnode_setblob(nodeidx_t num, void* buf, size_t size, nodeidx_t start, int tag)
    int netnode_delblob(nodeidx_t num, nodeidx_t start, int tag)
    bint netnode_inited()
    bint netnode_is_available()
    size_t netnode_copy(nodeidx_t num, nodeidx_t count, nodeidx_t target, bint move)
    size_t netnode_altshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_charshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_supshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    size_t netnode_blobshift(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, int tag)
    void netnode_altadjust2(nodeidx_t num, nodeidx_t from_, nodeidx_t to, nodeidx_t size, altadjust_visitor_t& av)
    bint netnode_exist(netnode& n)
    nodeidx_t ea2node(ea_t ea)  # Get netnode for the specified address.
    ea_t node2ea(nodeidx_t ndx)
    nodeidx_t end_ea2node(ea_t ea)
    netnode getnode(ea_t ea)
    tid_t get_strid(ea_t ea)  #  Returns the struct id of the struct type at the...
    ssize_t get_xrefpos(xrefpos_t* out, ea_t ea)
    void set_xrefpos(ea_t ea, xrefpos_t* in_)
    void del_xrefpos(ea_t ea)
    void set_aflags(ea_t ea, aflags_t flags)
    void upd_abits(ea_t ea, aflags_t clr_bits, aflags_t set_bits)
    void set_abits(ea_t ea, aflags_t bits)
    void clr_abits(ea_t ea, aflags_t bits)
    aflags_t get_aflags(ea_t ea)
    void del_aflags(ea_t ea)
    bint has_aflag_linnum(aflags_t flags)
    bint is_aflag_usersp(aflags_t flags)
    bint is_aflag_public_name(aflags_t flags)
    bint is_aflag_weak_name(aflags_t flags)
    bint is_aflag_hidden_item(aflags_t flags)
    bint is_aflag_manual_insn(aflags_t flags)
    bint is_aflag_hidden_border(aflags_t flags)
    bint is_aflag_zstroff(aflags_t flags)
    bint is_aflag__bnot0(aflags_t flags)
    bint is_aflag__bnot1(aflags_t flags)
    bint is_aflag_libitem(aflags_t flags)
    bint has_aflag_ti(aflags_t flags)
    bint has_aflag_ti0(aflags_t flags)
    bint has_aflag_ti1(aflags_t flags)
    bint has_aflag_lname(aflags_t flags)
    bint is_aflag_tilcmt(aflags_t flags)
    bint is_aflag_lzero0(aflags_t flags)
    bint is_aflag_lzero1(aflags_t flags)
    bint is_aflag_colored_item(aflags_t flags)
    bint is_aflag_terse_struc(aflags_t flags)
    bint is_aflag__invsign0(aflags_t flags)
    bint is_aflag__invsign1(aflags_t flags)
    bint is_aflag_noret(aflags_t flags)
    bint is_aflag_fixed_spd(aflags_t flags)
    bint is_aflag_align_flow(aflags_t flags)
    bint is_aflag_userti(aflags_t flags)
    bint is_aflag_retfp(aflags_t flags)
    bint uses_aflag_modsp(aflags_t flags)
    bint is_aflag_notcode(aflags_t flags)
    bint is_aflag_notproc(aflags_t flags)
    bint is_aflag_type_guessed_by_ida(aflags_t flags)
    bint is_aflag_func_guessed_by_hexrays(aflags_t flags)
    bint is_aflag_data_guessed_by_hexrays(aflags_t flags)
    bint is_aflag_type_determined_by_hexrays(aflags_t flags)
    bint is_aflag_type_guessed_by_hexrays(aflags_t flags)
    bint is_hidden_item(ea_t ea)
    void hide_item(ea_t ea)
    void unhide_item(ea_t ea)
    bint is_hidden_border(ea_t ea)
    void hide_border(ea_t ea)
    void unhide_border(ea_t ea)
    bint uses_modsp(ea_t ea)
    void set_usemodsp(ea_t ea)
    void clr_usemodsp(ea_t ea)
    bint is_zstroff(ea_t ea)
    void set_zstroff(ea_t ea)
    void clr_zstroff(ea_t ea)
    bint is__bnot0(ea_t ea)
    void set__bnot0(ea_t ea)
    void clr__bnot0(ea_t ea)
    bint is__bnot1(ea_t ea)
    void set__bnot1(ea_t ea)
    void clr__bnot1(ea_t ea)
    bint is_libitem(ea_t ea)
    void set_libitem(ea_t ea)
    void clr_libitem(ea_t ea)
    bint has_ti(ea_t ea)
    void set_has_ti(ea_t ea)
    void clr_has_ti(ea_t ea)
    bint has_ti0(ea_t ea)
    void set_has_ti0(ea_t ea)
    void clr_has_ti0(ea_t ea)
    bint has_ti1(ea_t ea)
    void set_has_ti1(ea_t ea)
    void clr_has_ti1(ea_t ea)
    bint has_lname(ea_t ea)
    void set_has_lname(ea_t ea)
    void clr_has_lname(ea_t ea)
    bint is_tilcmt(ea_t ea)
    void set_tilcmt(ea_t ea)
    void clr_tilcmt(ea_t ea)
    bint is_usersp(ea_t ea)
    void set_usersp(ea_t ea)
    void clr_usersp(ea_t ea)
    bint is_lzero0(ea_t ea)
    void set_lzero0(ea_t ea)
    void clr_lzero0(ea_t ea)
    bint is_lzero1(ea_t ea)
    void set_lzero1(ea_t ea)
    void clr_lzero1(ea_t ea)
    bint is_colored_item(ea_t ea)
    void set_colored_item(ea_t ea)
    void clr_colored_item(ea_t ea)
    bint is_terse_struc(ea_t ea)
    void set_terse_struc(ea_t ea)
    void clr_terse_struc(ea_t ea)
    bint is__invsign0(ea_t ea)
    void set__invsign0(ea_t ea)
    void clr__invsign0(ea_t ea)
    bint is__invsign1(ea_t ea)
    void set__invsign1(ea_t ea)
    void clr__invsign1(ea_t ea)
    bint is_noret(ea_t ea)
    void set_noret(ea_t ea)
    void clr_noret(ea_t ea)
    bint is_fixed_spd(ea_t ea)
    void set_fixed_spd(ea_t ea)
    void clr_fixed_spd(ea_t ea)
    bint is_align_flow(ea_t ea)
    void set_align_flow(ea_t ea)
    void clr_align_flow(ea_t ea)
    bint is_userti(ea_t ea)
    void set_userti(ea_t ea)
    void clr_userti(ea_t ea)
    bint is_retfp(ea_t ea)
    void set_retfp(ea_t ea)
    void clr_retfp(ea_t ea)
    bint is_notproc(ea_t ea)
    void set_notproc(ea_t ea)
    void clr_notproc(ea_t ea)
    bint is_type_guessed_by_ida(ea_t ea)
    bint is_func_guessed_by_hexrays(ea_t ea)
    bint is_data_guessed_by_hexrays(ea_t ea)
    bint is_type_determined_by_hexrays(ea_t ea)
    bint is_type_guessed_by_hexrays(ea_t ea)
    void set_type_guessed_by_ida(ea_t ea)
    void set_func_guessed_by_hexrays(ea_t ea)
    void set_data_guessed_by_hexrays(ea_t ea)
    void set_type_determined_by_hexrays(ea_t ea)
    void set_notcode(ea_t ea)  # Mark address so that it cannot be converted to instruction
    void clr_notcode(ea_t ea)  # Clear not-code mark
    bint is_notcode(ea_t ea)  # Is the address marked as not-code?
    void set_visible_item(ea_t ea, bint visible)  # Change visibility of item at given ea
    bint is_visible_item(ea_t ea)  # Test visibility of item at given ea
    bint is_finally_visible_item(ea_t ea)  # Is instruction visible?
    void set_source_linnum(ea_t ea, uval_t lnnum)  #  They are sometimes present in object files. @ {
    uval_t get_source_linnum(ea_t ea)
    void del_source_linnum(ea_t ea)
    ea_t get_absbase(ea_t ea)  #  These functions may be used if necessary (despite of...
    void set_absbase(ea_t ea, ea_t x)
    void del_absbase(ea_t ea)
    ea_t get_ind_purged(ea_t ea)  #  Number of bytes purged from the stack when a function...
    void set_ind_purged(ea_t ea, ea_t x)
    void del_ind_purged(ea_t ea)
    uint32 get_str_type(ea_t ea)  #  Use higher level function get_opinfo(). @ {
    void set_str_type(ea_t ea, uint32 x)
    void del_str_type(ea_t ea)
    uchar get_str_type_code(int32 strtype)  #  See
    char get_str_term1(int32 strtype)
    char get_str_term2(int32 strtype)
    uchar get_str_encoding_idx(int32 strtype)  # if the second termination character is ' \ 0', then it...
    int32 set_str_encoding_idx(int32 strtype, int encoding_idx)  # Set index of the string encoding in the string type
    int32 make_str_type(uchar type_code, int encoding_idx, uchar term1, uchar term2)  # Get string type for a string in the given encoding
    bint is_pascal(int32 strtype)
    size_t get_str_type_prefix_length(int32 strtype)
    uint32 get_alignment(ea_t ea)  #  (should be power of 2) These functions may be used if...
    void set_alignment(ea_t ea, uint32 x)
    void del_alignment(ea_t ea)
    void set_item_color(ea_t ea, bgcolor_t color)  #  @ {
    bgcolor_t get_item_color(ea_t ea)
    bint del_item_color(ea_t ea)
    ssize_t get_array_parameters(array_parameters_t* out, ea_t ea)
    void set_array_parameters(ea_t ea, array_parameters_t* in_)
    void del_array_parameters(ea_t ea)
    ssize_t get_switch_info(switch_info_t* out, ea_t ea)  #  See ::switch_info_t, xref.hpp for related functions @ {
    void set_switch_info(ea_t ea, switch_info_t& in_)
    void del_switch_info(ea_t ea)
    ea_t get_switch_parent(ea_t ea)  #  Address which holds the switch info (::switch_info_t)....
    void set_switch_parent(ea_t ea, ea_t x)
    void del_switch_parent(ea_t ea)
    int get_custom_data_type_ids(custom_data_type_ids_t* cdis, ea_t ea)
    void set_custom_data_type_ids(ea_t ea, custom_data_type_ids_t* cdis)
    void del_custom_data_type_ids(ea_t ea)
    bint is_reftype_target_optional(reftype_t type)  # Can the target be calculated using operand value?
    reftype_t get_reftype_by_size(size_t size)  # Get REF_... constant from size Supported sizes:...
    int register_custom_refinfo(custom_refinfo_handler_t* crh)  # Register a new custom refinfo type.
    bint unregister_custom_refinfo(int crid)  # Unregister a new custom refinfo type.
    int find_custom_refinfo(char* name)  # Get id of a custom refinfo type.
    custom_refinfo_handler_t* get_custom_refinfo(int crid)  # Get definition of a registered custom refinfo type.
    custom_refinfo_handler_t* get_custom_refinfo_handler(refinfo_t& ri)  # Get refinfo handler
    void get_refinfo_descs(refinfo_desc_vec_t* descs)
    bint set_refinfo_ex(ea_t ea, int n, refinfo_t* ri)  #  n may be 0, 1, 2, #OPND_MASK. #OPND_OUTER may be used...
    bint set_refinfo(ea_t ea, int n, reftype_t type, ea_t target, ea_t base, adiff_t tdelta)
    bint get_refinfo(refinfo_t* ri, ea_t ea, int n)
    bint del_refinfo(ea_t ea, int n)
    void write_struc_path(ea_t ea, int idx, tid_t* path, int plen, adiff_t delta)  # ---------------------------------------------------------...
    int read_struc_path(tid_t* path, adiff_t* delta, ea_t ea, int idx)
    bint get_tinfo(tinfo_t* tif, ea_t ea)  #  Work with function/data types These functions may be...
    bint set_tinfo(ea_t ea, tinfo_t* tif)
    void del_tinfo(ea_t ea)
    bint get_op_tinfo(tinfo_t* tif, ea_t ea, int n)  #  These functions may be used if necessary (despite of...
    bint set_op_tinfo(ea_t ea, int n, tinfo_t* tif)
    void del_op_tinfo(ea_t ea, int n)
    ssize_t get_root_filename(char* buf, size_t bufsize)  # ---------------------------------------------------------...
    ssize_t dbg_get_input_path(char* buf, size_t bufsize)  # Get debugger input file name/path (see #LFLG_DBG_NOPATH)
    ssize_t get_input_file_path(char* buf, size_t bufsize)  # Get full path of the input file
    void set_root_filename(char* file)  # Set full path of the input file
    size_t retrieve_input_file_size()  # Get size of input file in bytes
    uint32 retrieve_input_file_crc32()  # Get input file crc32 stored in the database. it can be...
    bint retrieve_input_file_md5(uchar* hash)  # Get input file md5
    bint retrieve_input_file_sha256(uchar* hash)  # Get input file sha256
    ssize_t get_asm_inc_file(qstring* buf)  # Get name of the include file
    bint set_asm_inc_file(char* file)  # Set name of the include file
    ea_t get_imagebase()  # Get image base address
    void set_imagebase(ea_t base)  # Set image base address
    netnode get_ids_modnode()  # Get ids modnode
    void set_ids_modnode(netnode id)  # Set ids modnode
    ssize_t get_archive_path(qstring* out)  # Get archive file path from which input file was extracted
    bint set_archive_path(char* file)  # Set archive file path from which input file was extracted
    ssize_t get_loader_format_name(qstring* out)  # Get file format name for loader modules
    void set_loader_format_name(char* name)  # Set file format name for loader modules
    ssize_t get_initial_ida_version(qstring* out)  # Get version of ida which created the database (string...
    ssize_t get_ida_notepad_text(qstring* out)  # Get notepad text
    void set_ida_notepad_text(char* text, size_t size)  # Set notepad text
    ssize_t get_srcdbg_paths(qstring* out)  # Get source debug paths
    void set_srcdbg_paths(char* paths)  # Set source debug paths
    ssize_t get_srcdbg_undesired_paths(qstring* out)  # Get user-closed source files
    void set_srcdbg_undesired_paths(char* paths)  # Set user-closed source files
    ushort get_initial_idb_version()  # Get initial version of the database (numeric format like 700)
    size_t get_elapsed_secs()  # Get seconds database stayed open
    size_t get_idb_nopens()  # Get number of times the database is opened
    int get_encoding_qty()  # Get total number of encodings (counted from 0)
    char* get_encoding_name(int idx)  # Get encoding name for specific index (1-based). 
    int add_encoding(char* encname)  # Add a new encoding (e.g. "UTF-8"). If it's already in...
    bint del_encoding(int idx)  # Delete an encoding The encoding is not actually removed...
    bint rename_encoding(int idx, char* encname)  # Change name for an encoding The number of bytes per unit...
    int get_encoding_bpu(int idx)  # Get the amount of bytes per unit (e.g., 2 for UTF-16, 4...
    int get_encoding_bpu_by_name(char* encname)  # Get the amount of bytes per unit for the given encoding 
    int get_strtype_bpu(int32 strtype)  # ---------------------------------------------------------...
    int get_default_encoding_idx(int bpu)  # Get default encoding index for a specific string type. 
    bint set_default_encoding_idx(int bpu, int idx)  # Set default encoding for a string type 
    char* encoding_from_strtype(int32 strtype)  # Get encoding name for this strtype 
    int get_outfile_encoding_idx()  # Get the index of the encoding used when producing files 
    bint set_outfile_encoding_idx(int idx)  # set encoding to be used when producing files 
    uint get_import_module_qty()  # Get number of import modules
    bint get_import_module_name(qstring* buf, int mod_index)  # Get import module name. 
    void delete_imports()  # Delete all imported modules information
    int validate_idb_names(bint do_repair)  # Check consistency of name records, return number of bad ones
    void set_gotea(ea_t gotea)  # ---------------------------------------------------------...
    ea_t get_gotea()  # ---------------------------------------------------------...
    bint is_visible_segm(segment_t* s)  # See #SFL_HIDDEN
    bint is_finally_visible_segm(segment_t* s)  # See #SFL_HIDDEN, #SCF_SHHID_SEGM
    void set_visible_segm(segment_t* s, bint visible)  # See #SFL_HIDDEN
    bint is_spec_segm(uchar seg_type)  # Has segment a special type?. (#SEG_XTRN, #SEG_GRP,...
    bint is_spec_ea(ea_t ea)  # Does the address belong to a segment with a special...
    void lock_segm(segment_t* segm, bint lock)  # Lock segment pointer Locked pointers are guaranteed to...
    bint is_segm_locked(segment_t* segm)  # Is a segment pointer locked?
    bint getn_selector(sel_t* sel, ea_t* base, int n)  # Get description of selector (0..get_selector_qty()-1)
    size_t get_selector_qty()  # Get number of defined selectors
    sel_t setup_selector(ea_t segbase)  # Allocate a selector for a segment if necessary. You must...
    sel_t allocate_selector(ea_t segbase)  # Allocate a selector for a segment unconditionally. You...
    sel_t find_free_selector()  # Find first unused selector. 
    int set_selector(sel_t selector, ea_t paragraph)  # Set mapping of selector to a paragraph. You should call...
    void del_selector(sel_t selector)  # Delete mapping of a selector. Be wary of deleting...
    ea_t sel2para(sel_t selector)  # Get mapping of a selector. 
    ea_t sel2ea(sel_t selector)  # Get mapping of a selector as a linear address. 
    sel_t find_selector(ea_t base)  # Find a selector that has mapping to the specified paragraph. 
    segment_t* get_segm_by_sel(sel_t selector)  # Get pointer to segment structure. This function finds a...
    bint add_segm_ex(segment_t* s, char* name, char* sclass, int flags)  # Add a new segment. If a segment already exists at the...
    bint add_segm(ea_t para, ea_t start, ea_t end, char* name, char* sclass, int flags)  # Add a new segment, second form. Segment alignment is set...
    bint del_segm(ea_t ea, int flags)  # Delete a segment. 
    int get_segm_qty()  # Get number of segments
    segment_t* getseg(ea_t ea)  # Get pointer to segment by linear address. 
    segment_t* getnseg(int n)  # Get pointer to segment by its number. 
    int get_segm_num(ea_t ea)  # Get number of segment by address. 
    segment_t* get_next_seg(ea_t ea)  # Get pointer to the next segment
    segment_t* get_prev_seg(ea_t ea)  # Get pointer to the previous segment
    segment_t* get_first_seg()  # Get pointer to the first segment
    segment_t* get_last_seg()  # Get pointer to the last segment
    segment_t* get_segm_by_name(char* name)  # Get pointer to segment by its name. If there are several...
    bint set_segm_end(ea_t ea, ea_t newend, int flags)  # Set segment end address. The next segment is shrinked to...
    bint set_segm_start(ea_t ea, ea_t newstart, int flags)  # Set segment start address. The previous segment is...
    bint move_segm_start(ea_t ea, ea_t newstart, int mode)  # Move segment start. The main difference between this...
    char* move_segm_strerror(move_segm_code_t code)  # Return string describing error MOVE_SEGM_... code
    move_segm_code_t move_segm(segment_t* s, ea_t to, int flags)  # This function moves all information to the new address....
    move_segm_code_t rebase_program(adiff_t delta, int flags)  # Rebase the whole program by 'delta' bytes. 
    int change_segment_status(segment_t* s, bint is_deb_segm)  # Convert a debugger segment to a regular segment and vice...
    bint take_memory_snapshot(int type)  # Take a memory snapshot of the running process. 
    bint is_miniidb()  # Is the database a miniidb created by the debugger?. 
    bint set_segm_base(segment_t* s, ea_t newbase)  # Internal function
    int set_group_selector(sel_t grp, sel_t sel)  # Create a new group of segments (used OMF files). 
    sel_t get_group_selector(sel_t grpsel)  # Get common selector for a group of segments. 
    bint add_segment_translation(ea_t segstart, ea_t mappedseg)  # Add segment translation. 
    bint set_segment_translations(ea_t segstart, eavec_t& transmap)  # Set new translation list. 
    void del_segment_translations(ea_t segstart)  # Delete the translation list 
    ssize_t get_segment_translations(eavec_t* transmap, ea_t segstart)  # Get segment translation list. 
    ssize_t get_segment_cmt(qstring* buf, segment_t* s, bint repeatable)  # Get segment comment. 
    void set_segment_cmt(segment_t* s, char* cmt, bint repeatable)  # Set segment comment. 
    int set_segm_name(segment_t* s, char* name, int flags)  # Rename segment. The new name is validated (see...
    ssize_t get_segm_name(qstring* buf, segment_t* s, int flags)  # Get true segment name by pointer to segment. 
    ssize_t get_visible_segm_name(qstring* buf, segment_t* s)  # Get segment name by pointer to segment. 
    ssize_t get_segm_expr(qstring* buf, ea_t from_, sel_t sel)  # Get colored segment name expression in the form (segname...
    ssize_t get_segm_class(qstring* buf, segment_t* s)  # Get segment class. Segment class is arbitrary text (max...
    int set_segm_class(segment_t* s, char* sclass, int flags)  # Set segment class. 
    uchar segtype(ea_t ea)  # Get segment type. 
    char* get_segment_alignment(uchar align)  # Get text representation of segment alignment code. 
    char* get_segment_combination(uchar comb)  # Get text representation of segment combination code. 
    ea_t get_segm_para(segment_t* s)  # Get segment base paragraph. Segment base paragraph may...
    ea_t get_segm_base(segment_t* s)  # Get segment base linear address. Segment base linear...
    bint set_segm_addressing(segment_t* s, size_t bitness)  # Change segment addressing mode (16, 32, 64 bits). You...
    bint is_debugger_segm(ea_t ea)  # Does the address belong to a debug segment?
    bint is_ephemeral_segm(ea_t ea)  # Does the address belong to an ephemeral segment?
    ea_t correct_address(ea_t ea, ea_t from_, ea_t to, ea_t size, bint skip_check)  # ---------------------------------------------------------...
    bint update_segm(segment_t* s)  # ---------------------------------------------------------...
    adiff_t segm_adjust_diff(segment_t* s, adiff_t delta)  # Truncate and sign extend a delta depending on the segment
    ea_t segm_adjust_ea(segment_t* s, ea_t ea)  # Truncate an address depending on the segment
    bint requires_color_esc(char c)  # Is the given char a color escape character?
    void tag_addr(qstring* buf, ea_t ea, bint ins)  # Insert an address mark into a string. 
    char* tag_advance(char* line, int cnt)  # Move pointer to a 'line' to 'cnt' positions right. Take...
    char* tag_skipcodes(char* line)  # Move the pointer past all color codes. 
    char* tag_skipcode(char* line)  # Skip one color code. This function should be used if you...
    ssize_t tag_strlen(char* line)  # Calculate length of a colored string This function...
    ssize_t tag_remove(qstring* buf, char* str, int init_level)  # Remove color escape sequences from a string. 
    color_t calc_prefix_color(ea_t ea)  # Get prefix color for line at 'ea' 
    bgcolor_t calc_bg_color(ea_t ea)  # Get background color for line at 'ea' 
    bint add_sourcefile(ea_t ea1, ea_t ea2, char* filename)  # Mark a range of address as belonging to a source file....
    char* get_sourcefile(ea_t ea, range_t* bounds)  # Get name of source file occupying the given address. 
    bint del_sourcefile(ea_t ea)  # Delete information about the source file. 
    bint install_user_defined_prefix(size_t prefix_len, user_defined_prefix_t* udp, void* owner)  # User-defined line-prefixes are displayed just after the...
    bint add_extra_line(ea_t ea, bint isprev, char* format)  # Add anterior/posterior non-comment line(s). 
    bint add_extra_cmt(ea_t ea, bint isprev, char* format)  # Add anterior/posterior comment line(s). 
    bint add_pgm_cmt(char* format)  # Add anterior comment line(s) at the start of program. 
    int generate_disassembly(qstrvec_t* out, int* lnnum, ea_t ea, int maxsize, int flags)  # Generate disassembly (many lines) and put them into a...
    bint generate_disasm_line(qstring* buf, ea_t ea, int flags)  # Generate one line of disassembly This function discards...
    int get_last_pfxlen()  # Get length of the line prefix that was used for the last...
    char* closing_comment()  # Get pointer to the sequence of characters denoting...
    int get_first_free_extra_cmtidx(ea_t ea, int start)
    bint update_extra_cmt(ea_t ea, int what, char* str)
    bint del_extra_cmt(ea_t ea, int what)
    ssize_t get_extra_cmt(qstring* buf, ea_t ea, int what)
    void delete_extra_cmts(ea_t ea, int what)
    ea_t align_down_to_stack(ea_t newea)
    ea_t align_up_to_stack(ea_t ea1, ea_t ea2)
    error_t enable_flags(ea_t start_ea, ea_t end_ea, storage_type_t stt)  # ---------------------------------------------------------...
    error_t disable_flags(ea_t start_ea, ea_t end_ea)  # Deallocate flags for address range. Exit with an error...
    error_t change_storage_type(ea_t start_ea, ea_t end_ea, storage_type_t stt)  # Change flag storage type for address range. 
    ea_t next_addr(ea_t ea)  # Get next address in the program (i.e. next address which...
    ea_t prev_addr(ea_t ea)  # Get previous address in the program. 
    ea_t next_chunk(ea_t ea)  # Get the first address of next contiguous chunk in the program. 
    ea_t prev_chunk(ea_t ea)  # Get the last address of previous contiguous chunk in the...
    ea_t chunk_start(ea_t ea)  # Get start of the contiguous address block containing 'ea'. 
    asize_t chunk_size(ea_t ea)  # Get size of the contiguous address block containing 'ea'. 
    ea_t find_free_chunk(ea_t start, asize_t size, asize_t alignment)  # Search for a hole in the addressing space of the program. 
    ea_t next_unknown(ea_t ea, ea_t maxea)  # Similar to next_that(), but will find the next address...
    ea_t prev_unknown(ea_t ea, ea_t minea)  # Similar to prev_that(), but will find the previous...
    ea_t prev_head(ea_t ea, ea_t minea)  # Get start of previous defined item. 
    ea_t next_head(ea_t ea, ea_t maxea)  # Get start of next defined item. 
    ea_t prev_not_tail(ea_t ea)  # Get address of previous non-tail byte. 
    ea_t next_not_tail(ea_t ea)  # Get address of next non-tail byte. 
    ea_t adjust_visea(ea_t ea)  # Adjust the address and get the nearest visible address....
    ea_t prev_visea(ea_t ea)  # Get previous visible address. 
    ea_t next_visea(ea_t ea)  # Get next visible address. 
    bint is_first_visea(ea_t ea)  # Is an address the first visible address?
    bint is_last_visea(ea_t ea)  # Is an address the last visible address?
    bint is_visible_finally(ea_t ea)  # Is the address visible on the screen (not hidden)?
    ea_t get_item_head(ea_t ea)  # Get the start address of the item at 'ea'. If there is...
    ea_t get_item_end(ea_t ea)  # Get the end address of the item at 'ea'. The returned...
    ea_t calc_max_item_end(ea_t ea, int how)  # Calculate maximal reasonable end address of a new item....
    asize_t get_item_size(ea_t ea)  # Get size of item (instruction/data) in bytes. Unexplored...
    bint is_mapped(ea_t ea)  # Is the specified address 'ea' present in the program?
    flags64_t get_flags_ex(ea_t ea, int how)  # Get flags for the specified address, extended form
    flags64_t get_flags32(ea_t ea)  # Get only 32 low bits of flags. This function returns the...
    flags64_t get_flags(ea_t ea)  # Get flags value for address 'ea'. The byte value is not...
    flags64_t get_full_flags(ea_t ea)  # Get full flags value for address 'ea'. This function...
    flags64_t get_item_flag(ea_t from_, int n, ea_t ea, bint appzero)  # Get flag of the item at 'ea' even if it is a tail byte...
    bint get_item_refinfo(refinfo_t* ri, ea_t ea, int n)  # ---------------------------------------------------------...
    bint has_value(flags64_t F)  # Do flags contain byte value?
    void del_value(ea_t ea)  # Delete byte value from flags. The corresponding byte...
    bint is_loaded(ea_t ea)  # Does the specified address have a byte value (is initialized?)
    int nbits(ea_t ea)  # Get number of bits in a byte at the given address. 
    int bytesize(ea_t ea)  # Get number of bytes required to store a byte at the given address
    uchar get_byte(ea_t ea)  # Get one byte (8-bit) of the program at 'ea'. This...
    uchar get_db_byte(ea_t ea)  # Get one byte (8-bit) of the program at 'ea' from the...
    ushort get_word(ea_t ea)  # Get one word (16-bit) of the program at 'ea'. This...
    uint32 get_dword(ea_t ea)  # Get one dword (32-bit) of the program at 'ea'. This...
    uint64 get_qword(ea_t ea)  # Get one qword (64-bit) of the program at 'ea'. This...
    uint64 get_wide_byte(ea_t ea)  # Get one wide byte of the program at 'ea'. Some...
    uint64 get_wide_word(ea_t ea)  # Get one wide word (2 'byte') of the program at 'ea'....
    uint64 get_wide_dword(ea_t ea)  # Get two wide words (4 'bytes') of the program at 'ea'....
    bint get_octet(uchar* out, octet_generator_t* ogen)
    uint32 get_16bit(ea_t ea)  # Get 16bits of the program at 'ea'. 
    uint32 get_32bit(ea_t ea)  # Get not more than 32bits of the program at 'ea'. 
    uint64 get_64bit(ea_t ea)  # Get not more than 64bits of the program at 'ea'. 
    bint get_data_value(uval_t* v, ea_t ea, asize_t size)  # Get the value at of the item at 'ea'. This function...
    uint64 get_original_byte(ea_t ea)  # Get original byte value (that was before patching). This...
    uint64 get_original_word(ea_t ea)  # Get original word value (that was before patching). This...
    uint64 get_original_dword(ea_t ea)  # Get original dword (that was before patching) This...
    uint64 get_original_qword(ea_t ea)  # Get original qword value (that was before patching) This...
    bint put_byte(ea_t ea, uint64 x)  # Set value of one byte of the program. This function...
    void put_word(ea_t ea, uint64 x)  # Set value of one word of the program. This function...
    void put_dword(ea_t ea, uint64 x)  # Set value of one dword of the program. This function...
    void put_qword(ea_t ea, uint64 x)  # Set value of one qword (8 bytes) of the program. This...
    bint patch_byte(ea_t ea, uint64 x)  # Patch a byte of the program. The original value of the...
    bint patch_word(ea_t ea, uint64 x)  # Patch a word of the program. The original value of the...
    bint patch_dword(ea_t ea, uint64 x)  # Patch a dword of the program. The original value of the...
    bint patch_qword(ea_t ea, uint64 x)  # Patch a qword of the program. The original value of the...
    bint revert_byte(ea_t ea)  # Revert patched byte 
    void add_byte(ea_t ea, uint32 value)  # Add a value to one byte of the program. This function...
    void add_word(ea_t ea, uint64 value)  # Add a value to one word of the program. This function...
    void add_dword(ea_t ea, uint64 value)  # Add a value to one dword of the program. This function...
    void add_qword(ea_t ea, uint64 value)  # Add a value to one qword of the program. This function...
    bint get_zero_ranges(rangeset_t* zranges, range_t* range)  # Return set of ranges with zero initialized bytes. The...
    ssize_t get_bytes(void* buf, ssize_t size, ea_t ea, int gmb_flags, void* mask)  # Get the specified number of bytes of the program into...
    void put_bytes(ea_t ea, void* buf, size_t size)  # Modify the specified number of bytes of the program....
    void patch_bytes(ea_t ea, void* buf, size_t size)  # Patch the specified number of bytes of the program....
    bint is_code(flags64_t F)  # Does flag denote start of an instruction?
    bint f_is_code(flags64_t F, void*)
    bint is_data(flags64_t F)  # Does flag denote start of data?
    bint f_is_data(flags64_t F, void*)
    bint is_tail(flags64_t F)  # Does flag denote tail byte?
    bint f_is_tail(flags64_t F, void*)
    bint is_not_tail(flags64_t F)
    bint f_is_not_tail(flags64_t F, void*)
    bint is_unknown(flags64_t F)  # Does flag denote unexplored byte?
    bint is_head(flags64_t F)  # Does flag denote start of instruction OR data?
    bint f_is_head(flags64_t F, void*)
    bint is_manual_insn(ea_t ea)  # Is the instruction overridden? 
    ssize_t get_manual_insn(qstring* buf, ea_t ea)  # Retrieve the user-specified string for the manual instruction. 
    void set_manual_insn(ea_t ea, char* manual_insn)  # Set manual instruction string. 
    bint is_flow(flags64_t F)  # Does the previous instruction exist and pass execution...
    bint has_extra_cmts(flags64_t F)  # Does the current byte have additional anterior or...
    bint f_has_extra_cmts(flags64_t f, void*)
    bint has_cmt(flags64_t F)  # Does the current byte have an indented comment?
    bint f_has_cmt(flags64_t f, void*)
    bint has_xref(flags64_t F)  # Does the current byte have cross-references to it?
    bint f_has_xref(flags64_t f, void*)
    bint has_name(flags64_t F)  # Does the current byte have non-trivial (non-dummy) name?
    bint f_has_name(flags64_t f, void*)
    bint has_dummy_name(flags64_t F)  # Does the current byte have dummy (auto-generated, with...
    bint f_has_dummy_name(flags64_t f, void*)
    bint has_auto_name(flags64_t F)  # Does the current byte have auto-generated (no special...
    bint has_any_name(flags64_t F)  # Does the current byte have any name?
    bint has_user_name(flags64_t F)  # Does the current byte have user-specified name?
    bint f_has_user_name(flags64_t F, void*)
    bint is_invsign(ea_t ea, flags64_t F, int n)  # Should sign of n-th operand inverted during output?....
    bint toggle_sign(ea_t ea, int n)  # Toggle sign of n-th operand. allowed values of n:...
    bint is_bnot(ea_t ea, flags64_t F, int n)  # Should we negate the operand?.  {a_bnot} should be...
    bint toggle_bnot(ea_t ea, int n)
    bint is_lzero(ea_t ea, int n)  # Display leading zeroes? Display leading zeroes in...
    bint set_lzero(ea_t ea, int n)  # Set toggle lzero bit. This function changes the display...
    bint clr_lzero(ea_t ea, int n)  # Clear toggle lzero bit. This function reset the display...
    bint toggle_lzero(ea_t ea, int n)  # Toggle lzero bit. 
    bint leading_zero_important(ea_t ea, int n)  # Check if leading zeroes are important
    int get_operand_type_shift(uint32 n)  # Get the shift in `flags64_t` for the nibble representing...
    flags64_t get_operand_flag(uint8 typebits, int n)  # Place operand `n`'s type flag in the right nibble of a...
    bint is_flag_for_operand(flags64_t F, uint8 typebits, int n)  # Check that the 64-bit flags set has the expected type...
    bint is_defarg0(flags64_t F)  # Is the first operand defined? Initially operand has no...
    bint is_defarg1(flags64_t F)  # Is the second operand defined? Initially operand has no...
    bint is_off0(flags64_t F)  # Is the first operand offset? (example: push offset xxx)
    bint is_off1(flags64_t F)  # Is the second operand offset? (example: mov ax, offset xxx)
    bint is_char0(flags64_t F)  # Is the first operand character constant? (example: push 'a')
    bint is_char1(flags64_t F)  # Is the second operand character constant? (example: mov al, 'a')
    bint is_seg0(flags64_t F)  # Is the first operand segment selector? (example: push seg seg001)
    bint is_seg1(flags64_t F)  # Is the second operand segment selector? (example: mov...
    bint is_enum0(flags64_t F)  # Is the first operand a symbolic constant (enum member)?
    bint is_enum1(flags64_t F)  # Is the second operand a symbolic constant (enum member)?
    bint is_stroff0(flags64_t F)  # Is the first operand an offset within a struct?
    bint is_stroff1(flags64_t F)  # Is the second operand an offset within a struct?
    bint is_stkvar0(flags64_t F)  # Is the first operand a stack variable?
    bint is_stkvar1(flags64_t F)  # Is the second operand a stack variable?
    bint is_float0(flags64_t F)  # Is the first operand a floating point number?
    bint is_float1(flags64_t F)  # Is the second operand a floating point number?
    bint is_custfmt0(flags64_t F)  # Does the first operand use a custom data representation?
    bint is_custfmt1(flags64_t F)  # Does the second operand use a custom data representation?
    bint is_numop0(flags64_t F)  # Is the first operand a number (i.e. binary, octal,...
    bint is_numop1(flags64_t F)  # Is the second operand a number (i.e. binary, octal,...
    flags64_t get_optype_flags0(flags64_t F)  # Get flags for first operand
    flags64_t get_optype_flags1(flags64_t F)  # Get flags for second operand
    bint is_defarg(flags64_t F, int n)  #  For the following functions, 'n' may be: - zero based...
    bint is_off(flags64_t F, int n)
    bint is_char(flags64_t F, int n)
    bint is_seg(flags64_t F, int n)
    bint is_enum(flags64_t F, int n)
    bint is_manual(flags64_t F, int n)
    bint is_stroff(flags64_t F, int n)
    bint is_stkvar(flags64_t F, int n)
    bint is_fltnum(flags64_t F, int n)
    bint is_custfmt(flags64_t F, int n)
    bint is_numop(flags64_t F, int n)
    bint is_suspop(ea_t ea, flags64_t F, int n)
    bint op_adds_xrefs(flags64_t F, int n)  # Should processor module create xrefs from the operand?....
    bint set_op_type(ea_t ea, flags64_t type, int n)  # (internal function) change representation of operand(s). 
    bint op_seg(ea_t ea, int n)  # Set operand representation to be 'segment'. If applied...
    bint op_enum(ea_t ea, int n, tid_t id, uchar serial)  # Set operand representation to be enum type If applied to...
    tid_t get_enum_id(uchar* serial, ea_t ea, int n)  # Get enum id of 'enum' operand. 
    bint op_stroff(insn_t& insn, int n, tid_t* path, int path_len, adiff_t delta)  # Set operand representation to be 'struct offset'. 
    bint op_based_stroff(insn_t& insn, int n, adiff_t opval, ea_t base)  # Set operand representation to be 'struct offset' if the...
    int get_stroff_path(tid_t* path, adiff_t* delta, ea_t ea, int n)  # Get struct path of operand. 
    bint op_stkvar(ea_t ea, int n)  # Set operand representation to be 'stack variable'....
    bint set_forced_operand(ea_t ea, int n, char* op)  # Set forced operand. 
    ssize_t get_forced_operand(qstring* buf, ea_t ea, int n)  # Get forced operand. 
    bint is_forced_operand(ea_t ea, int n)  # Is operand manually defined?. 
    flags64_t combine_flags(flags64_t F)  # ---------------------------------------------------------...
    flags64_t char_flag()  # ---------------------------------------------------------...
    flags64_t off_flag()
    flags64_t enum_flag()
    flags64_t stroff_flag()
    flags64_t stkvar_flag()
    flags64_t flt_flag()
    flags64_t custfmt_flag()
    flags64_t seg_flag()
    flags64_t num_flag()
    flags64_t hex_flag()  # Get number flag of the base, regardless of current...
    flags64_t dec_flag()
    flags64_t oct_flag()
    flags64_t bin_flag()
    bint op_chr(ea_t ea, int n)  #  The following functions set operand representation. If...
    bint op_num(ea_t ea, int n)
    bint op_hex(ea_t ea, int n)
    bint op_dec(ea_t ea, int n)
    bint op_oct(ea_t ea, int n)
    bint op_bin(ea_t ea, int n)
    bint op_flt(ea_t ea, int n)
    bint op_custfmt(ea_t ea, int n, int fid)  # Set custom data format for operand (fid-custom data format id)
    bint clr_op_type(ea_t ea, int n)  # Remove operand representation information. (set operand...
    int get_default_radix()  # Get default base of number for the current processor. 
    int get_radix(flags64_t F, int n)  # Get radix of the operand, in: flags. If the operand is...
    flags64_t code_flag()  #  @ {
    flags64_t byte_flag()
    flags64_t word_flag()
    flags64_t dword_flag()
    flags64_t qword_flag()
    flags64_t oword_flag()
    flags64_t yword_flag()
    flags64_t zword_flag()
    flags64_t tbyte_flag()
    flags64_t strlit_flag()
    flags64_t stru_flag()
    flags64_t cust_flag()
    flags64_t align_flag()
    flags64_t float_flag()
    flags64_t double_flag()
    flags64_t packreal_flag()
    bint is_byte(flags64_t F)
    bint is_word(flags64_t F)
    bint is_dword(flags64_t F)
    bint is_qword(flags64_t F)
    bint is_oword(flags64_t F)
    bint is_yword(flags64_t F)
    bint is_zword(flags64_t F)
    bint is_tbyte(flags64_t F)
    bint is_float(flags64_t F)
    bint is_double(flags64_t F)
    bint is_pack_real(flags64_t F)
    bint is_strlit(flags64_t F)
    bint is_struct(flags64_t F)
    bint is_align(flags64_t F)
    bint is_custom(flags64_t F)
    bint f_is_byte(flags64_t F, void*)
    bint f_is_word(flags64_t F, void*)
    bint f_is_dword(flags64_t F, void*)
    bint f_is_qword(flags64_t F, void*)
    bint f_is_oword(flags64_t F, void*)
    bint f_is_yword(flags64_t F, void*)
    bint f_is_tbyte(flags64_t F, void*)
    bint f_is_float(flags64_t F, void*)
    bint f_is_double(flags64_t F, void*)
    bint f_is_pack_real(flags64_t F, void*)
    bint f_is_strlit(flags64_t F, void*)
    bint f_is_struct(flags64_t F, void*)
    bint f_is_align(flags64_t F, void*)
    bint f_is_custom(flags64_t F, void*)
    bint is_same_data_type(flags64_t F1, flags64_t F2)  # Do the given flags specify the same data type?
    flags64_t get_flags_by_size(size_t size)  # Get flags from size (in bytes). Supported sizes: 1, 2,...
    bint create_data(ea_t ea, flags64_t dataflag, asize_t size, tid_t tid)  # Convert to data (byte, word, dword, etc). This function...
    flags64_t calc_dflags(flags64_t f, bint force)
    bint create_byte(ea_t ea, asize_t length, bint force)  # Convert to byte
    bint create_word(ea_t ea, asize_t length, bint force)  # Convert to word
    bint create_dword(ea_t ea, asize_t length, bint force)  # Convert to dword
    bint create_qword(ea_t ea, asize_t length, bint force)  # Convert to quadword
    bint create_oword(ea_t ea, asize_t length, bint force)  # Convert to octaword/xmm word
    bint create_yword(ea_t ea, asize_t length, bint force)  # Convert to ymm word
    bint create_zword(ea_t ea, asize_t length, bint force)  # Convert to zmm word
    bint create_tbyte(ea_t ea, asize_t length, bint force)  # Convert to tbyte
    bint create_float(ea_t ea, asize_t length, bint force)  # Convert to float
    bint create_double(ea_t ea, asize_t length, bint force)  # Convert to double
    bint create_packed_real(ea_t ea, asize_t length, bint force)  # Convert to packed decimal real
    bint create_struct(ea_t ea, asize_t length, tid_t tid, bint force)  # Convert to struct
    bint create_custdata(ea_t ea, asize_t length, int dtid, int fid, bint force)  # Convert to custom data type
    bint create_align(ea_t ea, asize_t length, int alignment)  # Create an alignment item. 
    int calc_min_align(asize_t length)  # Calculate the minimal possible alignment exponent. 
    int calc_max_align(ea_t endea)  # Calculate the maximal possible alignment exponent. 
    int calc_def_align(ea_t ea, int mina, int maxa)  # Calculate the default alignment exponent. 
    bint create_16bit_data(ea_t ea, asize_t length)  # Convert to 16-bit quantity (take the byte size into account)
    bint create_32bit_data(ea_t ea, asize_t length)  # Convert to 32-bit quantity (take the byte size into account)
    size_t get_max_strlit_length(ea_t ea, int32 strtype, int options)  # Determine maximum length of string literal. If the...
    ssize_t get_strlit_contents(qstring* utf8, ea_t ea, size_t len, int32 type, size_t* maxcps, int flags)  # Get contents of string literal, as UTF-8-encoded...
    bint create_strlit(ea_t start, size_t len, int32 strtype)  # Convert to string literal and give a meaningful name....
    bint print_strlit_type(qstring* out, int32 strtype, qstring* out_tooltip, int flags)  # Get string type information: the string type name...
    opinfo_t* get_opinfo(opinfo_t* buf, ea_t ea, int n, flags64_t flags)  # Get additional information about an operand representation. 
    bint set_opinfo(ea_t ea, int n, flags64_t flag, opinfo_t* ti, bint suppress_events)  # Set additional information about an operand...
    asize_t get_data_elsize(ea_t ea, flags64_t F, opinfo_t* ti)  # Get size of data type specified in flags 'F'.  If flags...
    asize_t get_full_data_elsize(ea_t ea, flags64_t F, opinfo_t* ti)  # Get full size of data type specified in flags 'F'. takes...
    int is_varsize_item(ea_t ea, flags64_t F, opinfo_t* ti, asize_t* itemsize)  # Is the item at 'ea' variable size?. 
    asize_t get_possible_item_varsize(ea_t ea, tinfo_t& tif)  # Return the possible size of the item at EA of type TIF...
    bint can_define_item(ea_t ea, asize_t length, flags64_t flags)  # Can define item (instruction/data) of the specified...
    bint has_immd(flags64_t F)  # Has immediate value?
    bint is_func(flags64_t F)  # Is function start?
    bint set_immd(ea_t ea)  # Set 'has immediate operand' flag. Returns true if the...
    int register_custom_data_type(data_type_t* dtinfo)  # Register a new data type. 
    bint unregister_custom_data_type(int dtid)  # Unregister a data type. When the idb is closed, all...
    int register_custom_data_format(data_format_t* dtform)  # Register a new data format. 
    bint unregister_custom_data_format(int dfid)  # Unregister a data format. 
    data_type_t* get_custom_data_type(int dtid)  # Get definition of a registered custom data type. 
    data_format_t* get_custom_data_format(int dfid)  # Get definition of a registered custom data format. 
    bint attach_custom_data_format(int dtid, int dfid)  # Attach the data format to the data type. 
    bint detach_custom_data_format(int dtid, int dfid)  # Detach the data format from the data type. Unregistering...
    bint is_attached_custom_data_format(int dtid, int dfid)  # Is the custom data format attached to the custom data type? 
    int get_custom_data_types(intvec_t* out, asize_t min_size, asize_t max_size)  # Get list of registered custom data type ids. 
    int get_custom_data_formats(intvec_t* out, int dtid)  # Get list of attached custom data formats for the...
    int find_custom_data_type(char* name)  # Get id of a custom data type. 
    int find_custom_data_format(char* name)  # Get id of a custom data format. 
    bint set_cmt(ea_t ea, char* comm, bint rptble)  # Set an indented comment. 
    ssize_t get_cmt(qstring* buf, ea_t ea, bint rptble)  # Get an indented comment. 
    bint append_cmt(ea_t ea, char* str, bint rptble)  # Append to an indented comment. Creates a new comment if...
    ssize_t get_predef_insn_cmt(qstring* buf, insn_t& ins)  # Get predefined comment. 
    ea_t find_byte(ea_t sEA, asize_t size, uchar value, int bin_search_flags)  # ---------------------------------------------------------...
    ea_t find_byter(ea_t sEA, asize_t size, uchar value, int bin_search_flags)  # Find reverse a byte with the specified value (only 8-bit...
    bint parse_binpat_str(compiled_binpat_vec_t* out, ea_t ea, char* in_, int radix, int strlits_encoding, qstring* errbuf)  # Convert user-specified binary string to internal...
    ea_t bin_search(ea_t start_ea, ea_t end_ea, compiled_binpat_vec_t& data, int flags, size_t* out_matched_idx)  # Search for a pattern in the program. 
    ea_t next_inited(ea_t ea, ea_t maxea)  # Find the next initialized address
    ea_t prev_inited(ea_t ea, ea_t minea)  # Find the previous initialized address
    bint equal_bytes(ea_t ea, uchar* image, uchar* mask, size_t len, int bin_search_flags)  # Compare 'len' bytes of the program starting from 'ea'...
    bint bytes_match_for_bin_search(uchar c1, uchar c2, uchar* mask, int i, int bin_search_flags)  # Compare two bytes. This helper function is used for...
    ea_t find_binary(ea_t startea, ea_t endea, char* ubinstr, int radix, int sflag, int strlits_encoding)
    bint update_hidden_range(hidden_range_t* ha)  # Update hidden range information in the database. You...
    bint add_hidden_range(ea_t ea1, ea_t ea2, char* description, char* header, char* footer, bgcolor_t color)  # Mark a range of addresses as hidden. The range will be...
    hidden_range_t* get_hidden_range(ea_t ea)  # Get pointer to hidden range structure, in: linear address. 
    hidden_range_t* getn_hidden_range(int n)  # Get pointer to hidden range structure, in: number of...
    int get_hidden_range_qty()  # Get number of hidden ranges
    int get_hidden_range_num(ea_t ea)  # Get number of a hidden range. 
    hidden_range_t* get_prev_hidden_range(ea_t ea)  # Get pointer to previous hidden range. 
    hidden_range_t* get_next_hidden_range(ea_t ea)  # Get pointer to next hidden range. 
    hidden_range_t* get_first_hidden_range()  # Get pointer to the first hidden range. 
    hidden_range_t* get_last_hidden_range()  # Get pointer to the last hidden range. 
    bint del_hidden_range(ea_t ea)  # Delete hidden range. 
    bint add_mapping(ea_t from_, ea_t to, asize_t size)  # Add memory mapping range. 
    void del_mapping(ea_t ea)  # Delete memory mapping range. 
    ea_t use_mapping(ea_t ea)  # Translate address according to current mappings. 
    size_t get_mappings_qty()  # Get number of mappings.
    bint get_mapping(ea_t* from_, ea_t* to, asize_t* size, size_t n)  # Get memory mapping range by its number. 
    ssize_t get_hex_string(char* buf, size_t bufsize, uchar* bytes, size_t len)  # byte array to hex string
    bint is_func_entry(func_t* pfn)  # Does function describe a function entry chunk?
    bint is_func_tail(func_t* pfn)  # Does function describe a function tail chunk?
    void lock_func_range(func_t* pfn, bint lock)  # Lock function pointer Locked pointers are guaranteed to...
    bint is_func_locked(func_t* pfn)  # Is the function pointer locked?
    func_t* get_func(ea_t ea)  # ---------------------------------------------------------...
    int get_func_chunknum(func_t* pfn, ea_t ea)  # Get the containing tail chunk of 'ea'. 
    bint func_contains(func_t* pfn, ea_t ea)  # Does the given function contain the given address?
    bint is_same_func(ea_t ea1, ea_t ea2)  # Do two addresses belong to the same function?
    func_t* getn_func(size_t n)  # Get pointer to function structure by number. 
    size_t get_func_qty()  # Get total number of functions in the program
    int get_func_num(ea_t ea)  # Get ordinal number of a function. 
    func_t* get_prev_func(ea_t ea)  # Get pointer to the previous function. 
    func_t* get_next_func(ea_t ea)  # Get pointer to the next function. 
    ea_t get_func_ranges(rangeset_t* ranges, func_t* pfn)  # Get function ranges. 
    ssize_t get_func_cmt(qstring* buf, func_t* pfn, bint repeatable)  # Get function comment. 
    bint set_func_cmt(func_t* pfn, char* cmt, bint repeatable)  # Set function comment. This function works with function...
    bint update_func(func_t* pfn)  # Update information about a function in the database...
    bint add_func_ex(func_t* pfn)  # Add a new function. If the fn->end_ea is #BADADDR, then...
    bint add_func(ea_t ea1, ea_t ea2)  # Add a new function. If the function end address is...
    bint del_func(ea_t ea)  # Delete a function. 
    int set_func_start(ea_t ea, ea_t newstart)  # Move function chunk start address. 
    bint set_func_end(ea_t ea, ea_t newend)  # Move function chunk end address. 
    void reanalyze_function(func_t* pfn, ea_t ea1, ea_t ea2, bint analyze_parents)  # Reanalyze a function. This function plans to analyzes...
    int find_func_bounds(func_t* nfn, int flags)  # Determine the boundaries of a new function. This...
    ssize_t get_func_name(qstring* out, ea_t ea)  # Get function name. 
    asize_t calc_func_size(func_t* pfn)  # Calculate function size. This function takes into...
    int get_func_bitness(func_t* pfn)  # Get function bitness (which is equal to the function...
    int get_func_bits(func_t* pfn)  # Get number of bits in the function addressing
    int get_func_bytes(func_t* pfn)  # Get number of bytes in the function addressing
    bint is_visible_func(func_t* pfn)  # Is the function visible (not hidden)?
    bint is_finally_visible_func(func_t* pfn)  # Is the function visible (event after considering...
    void set_visible_func(func_t* pfn, bint visible)  # Set visibility of function
    int set_func_name_if_jumpfunc(func_t* pfn, char* oldname)  # Give a meaningful name to function if it consists of...
    ea_t calc_thunk_func_target(func_t* pfn, ea_t* fptr)  # Calculate target of a thunk function. 
    bint func_does_return(ea_t callee)  # Does the function return?. To calculate the answer,...
    bint reanalyze_noret_flag(ea_t ea)  # Plan to reanalyze noret flag. This function does not...
    bint set_noret_insn(ea_t insn_ea, bint noret)  # Signal a non-returning instruction. This function can be...
    func_t* get_fchunk(ea_t ea)  # ---------------------------------------------------------...
    func_t* getn_fchunk(int n)  # Get pointer to function chunk structure by number. 
    size_t get_fchunk_qty()  # Get total number of function chunks in the program
    int get_fchunk_num(ea_t ea)  # Get ordinal number of a function chunk in the global...
    func_t* get_prev_fchunk(ea_t ea)  # Get pointer to the previous function chunk in the global list. 
    func_t* get_next_fchunk(ea_t ea)  # Get pointer to the next function chunk in the global list. 
    bint append_func_tail(func_t* pfn, ea_t ea1, ea_t ea2)  # Append a new tail chunk to the function definition. If...
    bint remove_func_tail(func_t* pfn, ea_t tail_ea)  # Remove a function tail. If the tail belongs only to one...
    bint set_tail_owner(func_t* fnt, ea_t new_owner)  # Set a new owner of a function tail. The new owner...
    bint func_tail_iterator_set(func_tail_iterator_t* fti, func_t* pfn, ea_t ea)
    bint func_tail_iterator_set_ea(func_tail_iterator_t* fti, ea_t ea)
    bint func_parent_iterator_set(func_parent_iterator_t* fpi, func_t* pfn)
    bint func_item_iterator_decode_prev_insn(func_item_iterator_t* fii, insn_t* out)
    bint func_item_iterator_decode_preceding_insn(func_item_iterator_t* fii, eavec_t* visited, bint* p_farref, insn_t* out)
    bint f_any(flags64_t, void*)  # Helper function to accept any address
    ea_t get_prev_func_addr(func_t* pfn, ea_t ea)  #  Unlike func_item_iterator_t which always enumerates the...
    ea_t get_next_func_addr(func_t* pfn, ea_t ea)
    void read_regargs(func_t* pfn)  # ---------------------------------------------------------...
    void add_regarg(func_t* pfn, int reg, tinfo_t& tif, char* name)
    int plan_to_apply_idasgn(char* fname)  # Add a signature file to the list of planned signature files. 
    int apply_idasgn_to(char* signame, ea_t ea, bint is_startup)  # Apply a signature file to the specified address. 
    int get_idasgn_qty()  # Get number of signatures in the list of planned and...
    int get_current_idasgn()  # Get number of the the current signature. 
    int calc_idasgn_state(int n)  # Get state of a signature in the list of planned signatures 
    int del_idasgn(int n)  # Remove signature from the list of planned signatures. 
    int32 get_idasgn_desc(qstring* signame, qstring* optlibs, int n)  # Get information about a signature in the list. 
    ssize_t get_idasgn_title(qstring* buf, char* name)  # Get full description of the signature by its short name. 
    void determine_rtl()  # Determine compiler/vendor using the startup signatures....
    bint apply_startup_sig(ea_t ea, char* startup)  # Apply a startup signature file to the specified address.  
    int try_to_add_libfunc(ea_t ea)  # Apply the currently loaded signature file to the...
    ssize_t get_kernel_version(char* buf, size_t bufsize)  # Get IDA kernel version (in a string like "5.1").
    bint is_ida_library(char* path, size_t pathsize, void** handle)
    int l_compare(place_t* t1, place_t* t2)  # compare places and their lnnums
    int l_compare2(place_t* t1, place_t* t2, void* ud)
    bint l_equals(place_t* t1, place_t* t2, void* ud)
    bint is_tif_cursor_header(tif_cursor_t c)
    bint is_tif_cursor_footer(tif_cursor_t c)
    bint is_tif_cursor_index(tif_cursor_t c)
    int internal_register_place_class(place_t* tmplate, int flags, plugin_t* owner, int sdk_version)  # ---------------------------------------------------------...
    int register_place_class(place_t* tmplate, int flags, plugin_t* owner)  # ---------------------------------------------------------...
    place_t* get_place_class(int* out_flags, int* out_sdk_version, int id)  # ---------------------------------------------------------...
    place_t* get_place_class_template(int id)  # ---------------------------------------------------------...
    bint is_place_class_ea_capable(int id)  # ---------------------------------------------------------...
    int get_place_class_id(char* name)  # ---------------------------------------------------------...
    void request_refresh(uint64 mask, bint cnd)  # Request a refresh of a builtin window. 
    void clear_refresh_request(uint64 mask)
    bint is_refresh_requested(uint64 mask)  # Get a refresh request state 
    bint is_chooser_widget(twidget_type_t t)  # Does the given widget type specify a chooser widget?
    bint is_action_enabled(action_state_t s)  # Check if the given action state is one of AST_ENABLE*
    int execute_ui_requests(ui_requests_t* reqs)  # Execute a list of UI requests (::ui_execute_ui_requests_list). 
    bint cancel_exec_request(int req_id)  # Try to cancel an asynchronous exec request...
    synced_group_t* get_synced_group(TWidget* w)  # Get the group of widgets/registers this view is...
    bint jumpto(ea_t ea, int opnum, int uijmp_flags)  # Jump to the specified address (::ui_jumpto). 
    bint banner(int wait)  # Show a banner dialog box (::ui_banner). 
    bint is_msg_inited()  # Can we use msg() functions?
    void refresh_idaview()  # Refresh marked windows (::ui_refreshmarked)
    void refresh_idaview_anyway()  # Refresh all disassembly views (::ui_refresh), forces an...
    void analyzer_options()  # Allow the user to set analyzer options. (show a dialog...
    ea_t get_screen_ea()  # Get the address at the screen cursor (::ui_screenea)
    int get_opnum()  # Get current operand number, -1 means no operand (::ui_get_opnum)
    bint get_cursor(int* x, int* y)  # Get the cursor position on the screen (::ui_get_cursor). 
    bint get_output_cursor(int* x, int* y)  # Get coordinates of the output window's cursor...
    char* get_curline()  # Get current line from the disassemble window (::ui_get_curline). 
    void open_url(char* url)  # Open the given url (::ui_open_url)
    ea_t get_hexdump_ea(int hexdump_num)  # Get the current address in a hex view. 
    ushort get_key_code(char* keyname)  # Get keyboard key code by its name (::ui_get_key_code)
    ushort lookup_key_code(int key, int shift, bint is_qt)  # Get shortcut code previously created by ::ui_get_key_code. 
    void refresh_navband(bint force)  # Refresh navigation band if changed (::ui_refresh_navband). 
    bint refresh_chooser(char* title)  # Mark a non-modal custom chooser for a refresh...
    bint close_chooser(char* title)  # Close a non-modal chooser (::ui_close_chooser). 
    void install_command_interpreter(cli_t* cp)  # Install command line interpreter (::ui_install_cli)
    void remove_command_interpreter(cli_t* cp)  # Remove command line interpreter (::ui_install_cli)
    void gen_disasm_text(text_t& text, ea_t ea1, ea_t ea2, bint truncate_lines)  # Generate disassembly text for a range. 
    ssize_t execute_sync(exec_request_t& req, int reqf)  # Execute code in the main thread. 
    bint set_dock_pos(char* src_ctrl, char* dest_ctrl, int orient, int left, int top, int right, int bottom)  # Set the docking position of a widget (::ui_set_dock_pos). 
    int get_icon_id_by_name(char* icon_name)  # Retrieve the id of the icon by name (::ui_get_icon_id_by_name). 
    int load_custom_icon(char* file_name)  # Load an icon from a file (::ui_load_custom_icon_file)....
    void free_custom_icon(int icon_id)  # Free an icon loaded with load_custom_icon()...
    bint process_ui_action(char* name, int flags, void* param)  # Processes a UI action by name. 
    bint take_database_snapshot(snapshot_t* ss, qstring* err_msg)  # Take a database snapshot (::ui_take_database_snapshot). 
    bint register_action(action_desc_t& desc)  # Create a new action (::ui_register_action). After an...
    bint unregister_action(char* name)  # Delete a previously-registered action (::ui_unregister_action). 
    void get_registered_actions(qstrvec_t* out)  # Get a list of all currently-registered actions 
    bint create_toolbar(char* name, char* label, char* before, int flags)  # Create a toolbar with the given name, label and optional...
    bint delete_toolbar(char* name)  # Delete an existing toolbar 
    bint create_menu(char* name, char* label, char* menupath)  # Create a menu with the given name, label and optional...
    bint delete_menu(char* name)  # Delete an existing menu 
    bint attach_action_to_menu(char* menupath, char* name, int flags)  # Attach a previously-registered action to the menu...
    bint detach_action_from_menu(char* menupath, char* name)  # Detach an action from the menu (::ui_detach_action_from_menu). 
    bint attach_action_to_toolbar(char* toolbar_name, char* name)  # Attach an action to an existing toolbar...
    bint detach_action_from_toolbar(char* toolbar_name, char* name)  # Detach an action from the toolbar...
    bint register_and_attach_to_menu(char* menupath, char* name, char* label, char* shortcut, int flags, action_handler_t* handler, void* owner, int action_desc_t_flags)  # Helper. You are not encouraged to use this, as it mixes...
    void display_widget(TWidget* widget, uint32 options, char* dest_ctrl)  # Display a widget, dock it if not done before 
    void close_widget(TWidget* widget, int options)  # Close widget (::ui_close_widget, only gui version). 
    void activate_widget(TWidget* widget, bint take_focus)  # Activate widget (only gui version) (::ui_activate_widget). 
    TWidget* find_widget(char* caption)  # Find widget with the specified caption (only gui...
    TWidget* get_current_widget()  # Get a pointer to the current widget (::ui_get_current_widget).
    twidget_type_t get_widget_type(TWidget* widget)  # Get the type of the TWidget * (::ui_get_widget_type).
    bint get_widget_title(qstring* buf, TWidget* widget)  # Get the TWidget's title (::ui_get_widget_title).
    TWidget* create_custom_viewer(char* title, place_t* minplace, place_t* maxplace, place_t* curplace, int* rinfo, void* ud, int* cvhandlers, void* cvhandlers_ud, TWidget* parent)  # Create new ida viewer based on ::place_t...
    bint custom_viewer_jump(TWidget* v, int& loc, uint32 flags)
    bint ea_viewer_history_push_and_jump(TWidget* v, ea_t ea, int x, int y, int lnnum)  # Push current location in the history and jump to the...
    bint get_ea_viewer_history_info(int* nback, int* nfwd, TWidget* v)  # Get information about what's in the history...
    void refresh_custom_viewer(TWidget* custom_viewer)  # Refresh custom ida viewer (::ui_refresh_custom_viewer)
    void repaint_custom_viewer(TWidget* custom_viewer)  # Repaint the given widget immediately (::ui_repaint_qwidget)
    void destroy_custom_viewer(TWidget* custom_viewer)  # Destroy custom ida viewer
    place_t* get_custom_viewer_place(TWidget* custom_viewer, bint mouse, int* x, int* y)  # Get current place in a custom viewer...
    bint get_custom_viewer_location(int* out, TWidget* custom_viewer, bint mouse)
    bint is_idaq()  # Are we running inside IDA Qt?
    bint attach_action_to_popup(TWidget* widget, TPopupMenu* popup_handle, char* name, char* popuppath, int flags)  # Insert a previously-registered action into the widget's...
    bint detach_action_from_popup(TWidget* widget, char* name)  # Remove a previously-registered action, from the list of...
    bint attach_dynamic_action_to_popup(TWidget* unused, TPopupMenu* popup_handle, action_desc_t& desc, char* popuppath, int flags, qstring* buf)  # Create & insert an action into the widget's popup menu...
    bint update_action_label(char* name, char* label)  # Update an action's label (::ui_update_action_attr). 
    bint update_action_shortcut(char* name, char* shortcut)  # Update an action's shortcut (::ui_update_action_attr). 
    bint update_action_tooltip(char* name, char* tooltip)  # Update an action's tooltip (::ui_update_action_attr). 
    bint update_action_icon(char* name, int icon)  # Update an action's icon (::ui_update_action_attr). 
    bint update_action_state(char* name, action_state_t state)  # Update an action's state (::ui_update_action_attr). 
    bint update_action_checkable(char* name, bint checkable)  # Update an action's checkability (::ui_update_action_attr). 
    bint update_action_checked(char* name, bint checked)  # Update an action's checked state (::ui_update_action_attr). 
    bint update_action_visibility(char* name, bint visible)  # Update an action's visibility (::ui_update_action_attr). 
    bint get_action_label(qstring* label, char* name)  # Get an action's label (::ui_get_action_attr). 
    bint get_action_shortcut(qstring* shortcut, char* name)  # Get an action's shortcut (::ui_get_action_attr). 
    bint get_action_tooltip(qstring* tooltip, char* name)  # Get an action's tooltip (::ui_get_action_attr). 
    bint get_action_icon(char* name, int* icon)  # Get an action's icon (::ui_get_action_attr). 
    bint get_action_state(char* name, action_state_t* state)  # Get an action's state (::ui_get_action_attr). 
    bint get_action_checkable(char* name, bint* checkable)  # Get an action's checkability (::ui_get_action_attr). 
    bint get_action_checked(char* name, bint* checked)  # Get an action's checked state (::ui_get_action_attr). 
    bint get_action_visibility(char* name, bint* visibility)  # Get an action's visibility (::ui_get_action_attr). 
    void set_custom_viewer_handlers(TWidget* custom_viewer, int* cvh, void* cvh_ud)  # Set handlers for custom viewer events Any of these...
    void* set_custom_viewer_handler(TWidget* custom_viewer, custom_viewer_handler_id_t handler_id, void* handler_or_data)  # Set a handler for a custom viewer event...
    bint set_custom_viewer_qt_aware(TWidget* custom_viewer)  # Allow the given viewer to interpret Qt events...
    char* get_custom_viewer_curline(TWidget* custom_viewer, bint mouse)  # Get current line of custom viewer...
    int get_custom_viewer_place_xcoord(TWidget* custom_viewer, place_t* pline, place_t* pitem)  # Get the X position of the item, in the line 
    bint get_user_input_event(input_event_t* out)  # Get the current user input event (mouse button press,...
    bint get_output_curline(qstring* buf, bint mouse)  # Get current line of output window (::ui_get_output_curline). 
    bint get_output_selected_text(qstring* buf)  # Returns selected text from output window...
    TWidget* get_current_viewer()  # Get current ida viewer (idaview or custom viewer)...
    TWidget* get_last_widget(uint64 mask)  # Get last ida viewer (idaview or custom viewer)...
    bint prompt_function_prototype(qstring* errbuf, tinfo_t* out_tif, func_t* pfn, tinfo_t* tif, char* name)  # Open function prototype editor to edit function type and...
    bint parse_tagged_line_sections(tagged_line_sections_t* out, char* line)  # Collect tagged sections in a color-tagged line (produced...
    tcc_renderer_type_t get_view_renderer_type(TWidget* v)  # Get the type of renderer currently in use in the given...
    void set_view_renderer_type(TWidget* v, tcc_renderer_type_t rt)  # Set the type of renderer to use in a view...
    void set_custom_viewer_range(TWidget* custom_viewer, place_t* minplace, place_t* maxplace)  # Set position range for custom viewer...
    TWidget* create_empty_widget(char* title, int icon)  # Create an empty widget, serving as a container for...
    void msg_clear()  # Clear the "Output" window
    bint msg_save(qstring& path)  # Save the "Output" window contents into a file 
    void msg_get_lines(qstrvec_t* out, int count)  # Retrieve the last 'count' lines from the output window,...
    TWidget* get_active_modal_widget()  # Get the current, active modal TWidget instance. Note...
    int get_navband_pixel(bint* out_is_vertical, ea_t ea)  # Translate the provided ea_t, into its pixel position...
    ea_t get_navband_ea(int pixel)  # Translate the pixel position on the navigation band,...
    void* get_window_id(char* name)  # Get the system-specific window ID (GUI version only) 
    bint is_idaview(TWidget* v)  # Is the given custom view an idaview? (::ui_is_idaview)
    bint read_selection(TWidget* v, twinpos_t* p1, twinpos_t* p2)  # Get the selected range boundaries (::ui_read_selection). 
    bint read_range_selection(TWidget* v, ea_t* ea1, ea_t* ea2)  # Get the address range for the selected range boundaries,...
    void unmark_selection()  # Unmark selection (::ui_unmarksel)
    TWidget* create_code_viewer(TWidget* custview, int flags, TWidget* parent)  # Create a code viewer (::ui_create_code_viewer). A code...
    void* set_code_viewer_handler(TWidget* code_viewer, custom_viewer_handler_id_t handler_id, void* handler_or_data)  # Set a handler for a code viewer event...
    bint set_code_viewer_user_data(TWidget* code_viewer, void* ud)  # Set the user data on a code viewer...
    void* get_viewer_user_data(TWidget* viewer)  # Get the user data from a custom viewer...
    tcc_place_type_t get_viewer_place_type(TWidget* viewer)  # Get the type of ::place_t instances a viewer uses &...
    void set_code_viewer_line_handlers(TWidget* code_viewer, int* click_handler, int* popup_handler, int* dblclick_handler, int* drawicon_handler, int* linenum_handler)  # Set handlers for code viewer line events. Any of these...
    bint set_code_viewer_lines_icon_margin(TWidget* code_viewer, int margin)  # Set space allowed for icons in the margin of a code...
    bint set_code_viewer_lines_alignment(TWidget* code_viewer, int align)  # Set alignment for lines in a code viewer...
    bint set_code_viewer_lines_radix(TWidget* code_viewer, int radix)  # Set radix for values displayed in a code viewer...
    bint set_code_viewer_is_source(TWidget* code_viewer)  # Specify that the given code viewer is used to display...
    int get_tab_size(char* path)  # Get the size of a tab in spaces (::ui_get_tab_size). 
    void clr_cancelled()  # Clear "Cancelled" flag (::ui_clr_cancelled)
    void set_cancelled()  # Set "Cancelled" flag (::ui_set_cancelled)
    bint user_cancelled()  # Test the cancellation flag (::ui_test_cancelled). 
    bint ui_load_new_file(qstring* temp_file, qstring* filename, linput_t** pli, ushort neflags, int** ploaders)  # Display a load file dialog and load file (::ui_load_file). 
    bint ui_run_debugger(char* dbgopts, char* exename, int argc, char** argv)  # Load a debugger plugin and run the specified program...
    bint load_dbg_dbginfo(char* path, linput_t* li, ea_t base, bint verbose)  # Load debugging information from a file. 
    int add_idc_hotkey(char* hotkey, char* idcfunc)  # Add hotkey for IDC function (::ui_add_idckey). 
    bint get_highlight(qstring* out_str, TWidget* viewer, uint32* out_flags, uint32 flags)  # Get the highlighted identifier in the viewer...
    bint set_highlight(TWidget* viewer, char* str, int flags)  # Set the highlighted identifier in the viewer...
    TWidget* open_exports_window(ea_t ea)  # Open the exports window (::ui_open_builtin). 
    TWidget* open_imports_window(ea_t ea)  # Open the exports window (::ui_open_builtin). 
    TWidget* open_names_window(ea_t ea)  # Open the names window (::ui_open_builtin). 
    TWidget* open_funcs_window(ea_t ea)  # Open the 'Functions' window (::ui_open_builtin). 
    TWidget* open_strings_window(ea_t ea, ea_t selstart, ea_t selend)  # Open the 'Strings' window (::ui_open_builtin). 
    TWidget* open_segments_window(ea_t ea)  # Open the segments window (::ui_open_builtin). 
    TWidget* open_segregs_window(ea_t ea)  # Open the segment registers window (::ui_open_builtin). 
    TWidget* open_selectors_window()  # Open the selectors window (::ui_open_builtin). 
    TWidget* open_signatures_window()  # Open the signatures window (::ui_open_builtin). 
    TWidget* open_tils_window()  # Open the type libraries window (::ui_open_builtin). 
    TWidget* open_loctypes_window(int ordinal, tif_cursor_t* cursor)  # Open the local types window (::ui_open_builtin2). 
    TWidget* open_til_view_window(tinfo_t* tif, tif_cursor_t* cursor)  # Open the sub-til window (::ui_open_builtin2). 
    TWidget* open_calls_window(ea_t ea)  # Open the function calls window (::ui_open_builtin). 
    TWidget* open_problems_window(ea_t ea)  # Open the problems window (::ui_open_builtin). 
    TWidget* open_bpts_window(ea_t ea)  # Open the breakpoints window (::ui_open_builtin). 
    TWidget* open_threads_window()  # Open the threads window (::ui_open_builtin). 
    TWidget* open_modules_window()  # Open the modules window (::ui_open_builtin). 
    TWidget* open_trace_window()  # Open the tracing window (::ui_open_builtin). 
    TWidget* open_stack_window()  # Open the call stack window (::ui_open_builtin). 
    TWidget* open_xrefs_window(ea_t ea)  # Open the cross references window (::ui_open_builtin). 
    TWidget* open_frame_window(func_t* pfn, uval_t offset)  # Open the frame window for the given function...
    TWidget* open_navband_window(ea_t ea, int zoom)  # Open the navigation band window (::ui_open_builtin). 
    TWidget* open_disasm_window(char* window_title, rangevec_t* ranges)  # Open a disassembly view (::ui_open_builtin). 
    TWidget* open_hexdump_window(char* window_title)  # Open a hexdump view (::ui_open_builtin). 
    TWidget* open_notepad_window()  # Open the notepad window (::ui_open_builtin). 
    TWidget* open_bookmarks_window(TWidget* w)  # Open the bookmarks window (::ui_open_builtin). 
    bint sync_sources(sync_source_t& what, sync_source_t& with_, bint sync)  # [Un]synchronize sources 
    char* choose_idasgn()  # Choose a signature (::ui_choose, ::chtype_idasgn). 
    bint choose_til(qstring* buf)  # Choose a type library (::ui_choose, ::chtype_idatil). 
    ea_t choose_entry(char* title)  # Choose an entry point (::ui_choose, ::chtype_entry). 
    ea_t choose_name(char* title)  # Choose a name (::ui_choose, ::chtype_name). 
    ea_t choose_stkvar_xref(func_t* pfn, tid_t srkvar_tid)  # Choose an xref to a stack variable (::ui_choose, ::chtype_name). 
    ea_t choose_xref(ea_t to)  # Choose an xref to an address (::ui_choose, ::chtype_xref). 
    bint choose_enum(tinfo_t* out, char* title, uint32 default_ord)  # Choose an enum (::ui_choose, ::chtype_enum). 
    bint choose_enum_by_value(tinfo_t* out, char* title, uint32 default_ord, uint64 value, int nbytes, uchar* serial)  # Choose an enum, restricted by value & size (::ui_choose,...
    func_t* choose_func(char* title, ea_t default_ea)  # Choose a function (::ui_choose, ::chtype_func). 
    segment_t* choose_segm(char* title, ea_t default_ea)  # Choose a segment (::ui_choose, ::chtype_segm). 
    bint choose_struct(tinfo_t* out, char* title)  # Choose a structure (::ui_choose, ::chtype_struct). 
    sreg_range_t* choose_srcp(char* title)  # Choose a segment register change point (::ui_choose,...
    void* get_chooser_obj(char* chooser_caption)  # Get the underlying object of the specified chooser...
    bint get_chooser_data(qstrvec_t* out, char* chooser_caption, int n)  # Get the text corresponding to the index N in the chooser...
    bint get_chooser_rows(chooser_row_info_vec_t* out, char* chooser_caption, size_t what)  # Get the chooser contents corresponding to the rows...
    bint enable_chooser_item_attrs(char* chooser_caption, bint enable)  # Enable item-specific attributes for chooser items...
    void show_wait_box(char* format)  # Display a dialog box with "Please wait...". The behavior...
    void hide_wait_box()  # Hide the "Please wait dialog box"
    void replace_wait_box(char* format)  # Replace the label of "Please wait dialog box"
    void beep(beep_t beep_type)  # Issue a beeping sound (::ui_beep). 
    bint display_copyright_warning()  # Display copyright warning (::ui_copywarn). 
    void ask_for_feedback(char* format)  # Show a message box asking to send the input file to...
    bint ask_addr(ea_t* addr, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_seg(sel_t* sel, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_long(sval_t* value, char* format)  # Display a dialog box and wait for the user to input an...
    void error(char* format)  # Display error dialog box and exit. If you just want to...
    ssize_t warning(char* format)
    ssize_t info(char* format)
    void nomem(char* format)
    int msg(char* format)
    int ask_yn(int deflt, char* format)  # Display a dialog box and get choice from "Yes", "No", "Cancel". 
    int ask_buttons(char* Yes, char* No, char* Cancel, int deflt, char* format)  # Display a dialog box and get choice from maximum three...
    bint ask_str(qstring* str, int hist, char* format)
    bint ask_ident(qstring* str, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_ident2(qstring* str, char* format)  # Display a dialog box and wait for the user to input an...
    bint ask_text(qstring* answer, size_t max_size, char* defval, char* format)
    char* ask_file(bint for_saving, char* defval, char* format)
    int register_addon(addon_info_t* info)  # Register an add-on. Show its info in the About box. For...
    int addon_count()  # Get number of installed addons
    bint get_addon_info(char* id, addon_info_t* info)  # Get info about a registered addon with a given product...
    bint get_addon_info_idx(int index, addon_info_t* info)  # Get info about a registered addon with specific index....
    char* add_spaces(char* str, size_t bufsize, ssize_t len)  # Add space characters to the colored string so that its...
    char* trim(char* str)  # Remove trailing space characters from a string. 
    char* skip_spaces(char* ptr)  # Skip whitespaces in the string. 
    ssize_t qcleanline(qstring* buf, char cmt_char, uint32 flags)  # Performs some cleanup operations to a line.  
    char* strarray(strarray_t* array, size_t array_size, int code)  # Find a line with the specified code in the ::strarray_t...
    size_t ea2str(char* buf, size_t bufsize, ea_t ea)  # Convert linear address to UTF-8 string
    bint str2ea(ea_t* out, char* str, ea_t screen_ea)  # Convert string to linear address. Tries to interpret the...
    bint str2ea_ex(ea_t* out, char* str, ea_t screen_ea, int flags)  # Same as str2ea() but possibly with some steps skipped. 
    bint atoea(ea_t* out, char* str)  # Convert a number in C notation to an address. decimal:...
    void get_user_strlist_options(int* out)
    bint del_idc_hotkey(char* hotkey)
    void ida_checkmem(char* file, int line)
    char xrefchar(char xrtype)  # Get character describing the xref type. 
    bint add_cref(ea_t from_, ea_t to, cref_t type)  # Create a code cross-reference. 
    bint del_cref(ea_t from_, ea_t to, bint expand)  # Delete a code cross-reference. 
    bint add_dref(ea_t from_, ea_t to, dref_t type)  # Create a data cross-reference. 
    void del_dref(ea_t from_, ea_t to)  # Delete a data cross-reference. 
    bint xrefblk_t_first_from(xrefblk_t*, ea_t from_, int flags)  #  Should not be called directly! @ {
    bint xrefblk_t_next_from(xrefblk_t*)
    bint xrefblk_t_first_to(xrefblk_t*, ea_t to, int flags)
    bint xrefblk_t_next_to(xrefblk_t*)
    ea_t get_first_dref_from(ea_t from_)  # ---------------------------------------------------------...
    ea_t get_next_dref_from(ea_t from_, ea_t current)  # Get next data referenced from the specified address. 
    ea_t get_first_dref_to(ea_t to)  # Get address of instruction/data referencing to the...
    ea_t get_next_dref_to(ea_t to, ea_t current)  # Get address of instruction/data referencing to the...
    ea_t get_first_cref_from(ea_t from_)  # Get first instruction referenced from the specified...
    ea_t get_next_cref_from(ea_t from_, ea_t current)  # Get next instruction referenced from the specified instruction. 
    ea_t get_first_cref_to(ea_t to)  # Get first instruction referencing to the specified...
    ea_t get_next_cref_to(ea_t to, ea_t current)  # Get next instruction referencing to the specified instruction. 
    ea_t get_first_fcref_from(ea_t from_)  #  The following functions are similar to...
    ea_t get_next_fcref_from(ea_t from_, ea_t current)
    ea_t get_first_fcref_to(ea_t to)
    ea_t get_next_fcref_to(ea_t to, ea_t current)
    bint has_external_refs(func_t* pfn, ea_t ea)  # Does 'ea' have references from outside of 'pfn'?
    bint has_jump_or_flow_xref(ea_t ea)  # Are there jump or flow references to EA?
    bint create_switch_table(ea_t insn_ea, switch_info_t& si)  # Create switch table from the switch information. Usually...
    void create_switch_xrefs(ea_t insn_ea, switch_info_t& si)  # Create code xrefs for the switch table. This function...
    bint calc_switch_cases(casevec_t* casevec, eavec_t* targets, ea_t insn_ea, switch_info_t& si)  # Get detailed information about the switch table cases. 
    void delete_switch_table(ea_t jump_ea, switch_info_t& si)  # Delete information created by the call of...
    bint create_xrefs_from(ea_t ea)
    void delete_all_xrefs_from(ea_t ea, bint expand)
    uint8 insn_get_next_byte(insn_t* insn)
    uint16 insn_get_next_word(insn_t* insn)
    uint32 insn_get_next_dword(insn_t* insn)
    uint64 insn_get_next_qword(insn_t* insn)
    bint insn_create_op_data(insn_t& insn, ea_t ea, int opoff, op_dtype_t dtype)
    void insn_add_cref(insn_t& insn, ea_t to, int opoff, cref_t type)
    void insn_add_dref(insn_t& insn, ea_t to, int opoff, dref_t type)
    ea_t insn_add_off_drefs(insn_t& insn, op_t& x, dref_t type, int outf)
    bint insn_create_stkvar(insn_t& insn, op_t& x, adiff_t v, int flags)
    size_t get_immvals(uval_t* out, ea_t ea, int n, flags64_t F, insn_t* cache)  # Get immediate values at the specified address. This...
    size_t get_printable_immvals(uval_t* out, ea_t ea, int n, flags64_t F, insn_t* cache)  # Get immediate ready-to-print values at the specified address 
    int get_lookback()  # Number of instructions to look back. This variable is...
    ea_t calc_dataseg(insn_t& insn, int n, int rgnum)  # Get data segment for the instruction operand. 'opnum'...
    ea_t map_data_ea(insn_t& insn, ea_t addr, int opnum)  # Map a data address. 
    ea_t map_code_ea(insn_t& insn, ea_t addr, int opnum)  # Map a code address. This function takes into account the...
    ea_t map_ea(insn_t& insn, op_t& op, bint iscode)
    outctx_base_t* create_outctx(ea_t ea, flags64_t F, int suspop)  # ---------------------------------------------------------...
    bint print_insn_mnem(qstring* out, ea_t ea)  # Print instruction mnemonics. 
    bint format_charlit(qstring* out, uchar** ptr, size_t size, uint32 flags, int encidx)  # Format character literal. Try and format 'size' bytes...
    bint print_fpval(char* buf, size_t bufsize, void* v, int size)  # Print a floating point value. 
    flags64_t get_dtype_flag(op_dtype_t dtype)  # ---------------------------------------------------------...
    size_t get_dtype_size(op_dtype_t dtype)  # Get size of opt_::dtype field
    op_dtype_t get_dtype_by_size(asize_t size)  # Get op_t::dtype from size
    bint is_floating_dtype(op_dtype_t dtype)  # Is a floating type operand?
    int create_insn(ea_t ea, insn_t* out)  # ---------------------------------------------------------...
    int decode_insn(insn_t* out, ea_t ea)  # Analyze the specified address and fill 'out'. This...
    bint can_decode(ea_t ea)  # Can the bytes at address 'ea' be decoded as instruction? 
    bint print_operand(qstring* out, ea_t ea, int n, int getn_flags, printop_t* newtype)  # Generate text representation for operand #n. This...
    ea_t decode_prev_insn(insn_t* out, ea_t ea)  # Decode previous instruction if it exists, fill 'out'. 
    ea_t decode_preceding_insn(insn_t* out, ea_t ea, bint* p_farref)  # Decode preceding instruction in the execution flow....
    bint construct_macro(macro_constructor_t* _this, insn_t* insn, bint enable)  # Do not directly call this function, use macro_constructor_t
    int get_spoiled_reg(insn_t& insn, uint32* regs, size_t n)  # Does the instruction spoil any register from 'regs'?....
    bint parse_config_value(idc_value_t* out, lexer_t* lx, token_t& value)
    char* cfgopt_t__apply(cfgopt_t* _this, int vtype, void* vdata)
    char* cfgopt_t__apply2(cfgopt_t* _this, int vtype, void* vdata, void* obj)
    char* cfgopt_t__apply3(cfgopt_t* _this, lexer_t* lx, int vtype, void* vdata, void* obj)
    bint get_config_value(jvalue_t* out, char* key)  # Get json value from ida.cfg 
    bint has_cf_chg(uint32 feature, uint opnum)  # Does an instruction with the specified feature modify...
    bint has_cf_use(uint32 feature, uint opnum)  # Does an instruction with the specified feature use a...
    bint has_insn_feature(uint16 icode, uint32 bit)  # Does the specified instruction have the specified feature?
    bint is_call_insn(insn_t& insn)  # Is the instruction a "call"?
    bint is_ret_insn(insn_t& insn, uchar flags)  # @ }
    bint is_indirect_jump_insn(insn_t& insn)  # Is the instruction an indirect jump?
    bint is_basic_block_end(insn_t& insn, bint call_insn_stops_block)  # Is the instruction the end of a basic block?
    bint hook_event_listener(hook_type_t hook_type, event_listener_t* cb, void* owner, int hkcb_flags)  # Install an event listener. The installed listener will...
    bint unhook_event_listener(hook_type_t hook_type, event_listener_t* cb)  # Uninstall an event listener. 
    void remove_event_listener(event_listener_t* cb)  # remove all hooks in all databases for specified...
    processor_t* get_ph()  # The following two structures contain information about...
    asm_t* get_ash()
    ea_helper_t* get_eah()
    int str2reg(char* p)
    int is_align_insn(ea_t ea)  # If the instruction at 'ea' looks like an alignment...
    ssize_t get_reg_name(qstring* buf, int reg, size_t width, int reghi)  # Get text representation of a register. For most...
    bint parse_reg_name(reg_info_t* ri, char* regname)  # Get register info by name. 
    bint set_processor_type(char* procname, setproc_level_t level)  # Set target processor type. Once a processor module is...
    char* get_idp_name(char* buf, size_t bufsize)  # Get name of the current processor module. The name is...
    bint set_target_assembler(int asmnum)  # Set target assembler. 
    void* set_module_data(int* data_id, void* data_ptr)  # Register pointer to database specific module data. 
    void* clr_module_data(int data_id)  # Unregister pointer to database specific module data. 
    void* get_module_data(int data_id)  # Get pointer to the database specific module data. 
    bint set_name(ea_t ea, char* name, int flags)  # Set or delete name of an item at the specified address....
    bint force_name(ea_t ea, char* name, int flags)  # @ }
    bint del_global_name(ea_t ea)  #  
    bint del_local_name(ea_t ea)
    bint set_dummy_name(ea_t from_, ea_t ea)  # Give an autogenerated (dummy) name. Autogenerated names...
    bint make_name_auto(ea_t ea)  #  This bit affects value of has_user_name(),...
    bint make_name_user(ea_t ea)
    bint validate_name(qstring* name, nametype_t type, int flags)  # Validate a name. If SN_NOCHECK is specified, this...
    bint is_valid_cp(wchar32_t cp, nametype_t kind, void* data)  # Is the given codepoint acceptable in the given context?
    void set_cp_validity(ucdr_kind_t kind, wchar32_t cp, wchar32_t endcp, bint valid)  # Mark the given codepoint (or range) as acceptable or...
    bint get_cp_validity(ucdr_kind_t kind, wchar32_t cp, wchar32_t endcp)  # Is the given codepoint (or range) acceptable in the...
    bint is_ident_cp(wchar32_t cp)  # Can a character appear in a name? (present in...
    bint is_strlit_cp(wchar32_t cp, rangeset_crefvec_t* specific_ranges)  # Can a character appear in a string literal (present in...
    bint is_visible_cp(wchar32_t cp)  # Can a character be displayed in a name? (present in ::NameChars)
    bint is_ident(char* name)  # Is a valid name? (including ::MangleChars)
    bint is_uname(char* name)  # Is valid user-specified name? (valid name & !dummy prefix). 
    bint is_valid_typename(char* name)  # Is valid type name? 
    ea_t dummy_name_ea(char* name)  # Is dummy name? 
    ssize_t extract_name(qstring* out, char* line, int x)  # Extract a name or address from the specified string. 
    void hide_name(ea_t ea)  # Remove name from the list of names 
    void show_name(ea_t ea)  # Insert name to the list of names
    ea_t get_name_ea(ea_t from_, char* name)  # Get the address of a name. This function resolves a name...
    ea_t get_name_base_ea(ea_t from_, ea_t to)  # Get address of the name used in the expression for the address 
    int get_name_value(uval_t* value, ea_t from_, char* name)  # Get value of the name. This function knows about:...
    ssize_t get_ea_name(qstring* out, ea_t ea, int gtn_flags, getname_info_t* gtni)  # Get name at the specified address. 
    ssize_t get_name(qstring* out, ea_t ea, int gtn_flags)  # Convenience functions for get_ea_name returning ssize_t
    ssize_t get_visible_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_colored_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_short_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_long_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_colored_short_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_colored_long_name(qstring* out, ea_t ea, int gtn_flags)
    ssize_t get_demangled_name(qstring* out, ea_t ea, int32 inhibitor, int demform, int gtn_flags)
    ssize_t get_colored_demangled_name(qstring* out, ea_t ea, int32 inhibitor, int demform, int gtn_flags)
    int calc_gtn_flags(ea_t from_, ea_t ea)
    color_t get_name_color(ea_t from_, ea_t ea)  # Get name color. 
    ssize_t get_name_expr(qstring* out, ea_t from_, int n, ea_t ea, uval_t off, int flags)  # Convert address to name expression (name with a...
    ssize_t get_nice_colored_name(qstring* buf, ea_t ea, int flags)  # Get a nice colored name at the specified address. Ex: -...
    flags64_t append_struct_fields(qstring* out, adiff_t* disp, int n, tid_t* path, int plen, flags64_t flags, adiff_t delta, bint appzero)  # Append names of struct fields to a name if the name is a...
    int get_struct_operand(adiff_t* disp, adiff_t* delta, tid_t* path, ea_t ea, int n)  # Get offset within a structure if the operand refers to...
    bint is_public_name(ea_t ea)  #  @ {
    void make_name_public(ea_t ea)
    void make_name_non_public(ea_t ea)
    bint is_weak_name(ea_t ea)  #  @ {
    void make_name_weak(ea_t ea)
    void make_name_non_weak(ea_t ea)
    size_t get_nlist_size()  # Get number of names in the list
    size_t get_nlist_idx(ea_t ea)  # Get index of the name in the list 
    bint is_in_nlist(ea_t ea)  # Is the name included into the name list?
    ea_t get_nlist_ea(size_t idx)  # Get address from the list at 'idx'
    char* get_nlist_name(size_t idx)  # Get name using idx
    void rebuild_nlist()  # Rebuild the name list
    void reorder_dummy_names()  # Renumber dummy names
    int set_debug_names(ea_t* addrs, char** names, int qty)  #  Debug names exist during the debugging session. The...
    bint set_debug_name(ea_t ea, char* name)
    ssize_t get_debug_name(qstring* out, ea_t* ea_ptr, debug_name_how_t how)
    void del_debug_names(ea_t ea1, ea_t ea2)
    ea_t get_debug_name_ea(char* name)
    void get_debug_names(ea_name_vec_t* names, ea_t ea1, ea_t ea2)
    int32 demangle_name(qstring* out, char* name, uint32 disable_mask, demreq_type_t demreq)  # Demangle a name. 
    int32 detect_compiler_using_demangler(char* name)
    bint is_name_defined_locally(func_t* pfn, char* name, ignore_name_def_t ignore_name_def, ea_t ea1, ea_t ea2)  # Is the name defined locally in the specified function? 
    bint cleanup_name(qstring* out, ea_t ea, char* name, uint32 flags)  # Clean a name. This function removes punctuation marks...
    bint is_type_const(type_t t)  # ---------------------------------------------------------...
    bint is_type_volatile(type_t t)
    type_t get_base_type(type_t t)
    type_t get_type_flags(type_t t)
    type_t get_full_type(type_t t)
    bint is_typeid_last(type_t t)  # Is the type_t the last byte of type declaration? (there...
    bint is_type_partial(type_t t)  # Identifies an unknown or void type with a known size (see
    bint is_type_void(type_t t)
    bint is_type_unknown(type_t t)
    bint is_type_ptr(type_t t)
    bint is_type_complex(type_t t)
    bint is_type_func(type_t t)
    bint is_type_array(type_t t)
    bint is_type_typedef(type_t t)
    bint is_type_sue(type_t t)
    bint is_type_struct(type_t t)
    bint is_type_union(type_t t)
    bint is_type_struni(type_t t)
    bint is_type_enum(type_t t)
    bint is_type_bitfld(type_t t)
    bint is_type_int(type_t bt)  # Does the type_t specify one of the basic types in
    bint is_type_int128(type_t t)  # Does the type specify a 128-bit value? (signed or unsigned, see
    bint is_type_int64(type_t t)  # Does the type specify a 64-bit value? (signed or unsigned, see
    bint is_type_int32(type_t t)  # Does the type specify a 32-bit value? (signed or unsigned, see
    bint is_type_int16(type_t t)  # Does the type specify a 16-bit value? (signed or unsigned, see
    bint is_type_char(type_t t)  # Does the type specify a char value? (signed or unsigned, see
    bint is_type_paf(type_t t)  # Is the type a pointer, array, or function type?
    bint is_type_ptr_or_array(type_t t)  # Is the type a pointer or array type?
    bint is_type_floating(type_t t)  # Is the type a floating point type?
    bint is_type_integral(type_t t)  # Is the type an integral type (char/short/int/long/bool)?
    bint is_type_ext_integral(type_t t)  # Is the type an extended integral type? (integral or enum)
    bint is_type_arithmetic(type_t t)  # Is the type an arithmetic type? (floating or integral)
    bint is_type_ext_arithmetic(type_t t)  # Is the type an extended arithmetic type? (arithmetic or enum)
    bint is_type_uint(type_t t)
    bint is_type_uchar(type_t t)
    bint is_type_uint16(type_t t)
    bint is_type_uint32(type_t t)
    bint is_type_uint64(type_t t)
    bint is_type_uint128(type_t t)
    bint is_type_ldouble(type_t t)
    bint is_type_double(type_t t)
    bint is_type_float(type_t t)
    bint is_type_tbyte(type_t t)
    bint is_type_bool(type_t t)
    bint is_tah_byte(type_t t)  # The TAH byte (type attribute header byte) denotes the...
    bint is_sdacl_byte(type_t t)  # Identify an sdacl byte. The first sdacl byte has the...
    bint append_argloc(qtype* out, argloc_t& vloc)  # ---------------------------------------------------------...
    bint extract_argloc(argloc_t* vloc, type_t** ptype, bint forbid_stkoff)  # Deserialize an argument location. Argument FORBID_STKOFF...
    type_t* resolve_typedef(til_t* til, type_t* type)
    bint is_restype_void(til_t* til, type_t* type)  # low level functions to be used in...
    bint is_restype_enum(til_t* til, type_t* type)
    bint is_restype_struni(til_t* til, type_t* type)
    bint is_restype_struct(til_t* til, type_t* type)
    type_t get_scalar_bt(int size)  # Get a base type for the specified size. This function...
    til_t* new_til(char* name, char* desc)  # Initialize a til
    int add_base_tils(qstring* errbuf, til_t* ti, char* tildir, char* bases, bint gen_events)  # Add multiple base tils. 
    til_t* load_til(char* name, qstring* errbuf, char* tildir)  # Load til from a file without adding it to the database...
    bint sort_til(til_t* ti)  # Sort til (use after modifying it). 
    bint compact_til(til_t* ti)  # Collect garbage in til. Must be called before storing the til. 
    bint store_til(til_t* ti, char* tildir, char* name)  # Store til to a file. If the til contains garbage, it...
    void free_til(til_t* ti)  # Free memory allocated by til
    til_t* load_til_header(char* tildir, char* name, qstring* errbuf)  # Get human-readable til description
    bint is_code_far(cm_t cm)  # Does the given model specify far code?.
    bint is_data_far(cm_t cm)  # Does the given model specify far data?.
    int install_custom_argloc(custloc_desc_t* custloc)  # Save a custom argloc
    bint remove_custom_argloc(int idx)  # Delete the custom argloc at the given index
    custloc_desc_t* retrieve_custom_argloc(int idx)  # Retrieve the custom argloc at the given index
    int verify_argloc(argloc_t& vloc, int size, rangeset_t* gaps)  # Verify argloc_t. 
    bint optimize_argloc(argloc_t* vloc, int size, rangeset_t* gaps)  # Verify and optimize scattered argloc into simple form....
    size_t print_argloc(char* buf, size_t bufsize, argloc_t& vloc, int size, int vflags)  # Convert an argloc to human readable form
    int for_all_arglocs(aloc_visitor_t& vv, argloc_t& vloc, int size, int off)  # Compress larger argloc types and initiate the aloc visitor
    int for_all_const_arglocs(const_aloc_visitor_t& vv, argloc_t& vloc, int size, int off)  # See for_all_arglocs()
    callcnv_t helper_get_cc(cm_t cm, callcnv_t new_callcnv)  # Helper functions that maintain binary compatibility with...
    void helper_set_cc(cm_t* cm, callcnv_t* new_callcnv, callcnv_t cc)
    callcnv_t get_effective_cc(callcnv_t cc)  # Get effective calling convention (with respect to default CC)
    bint is_user_cc(callcnv_t cc)  # Does the calling convention specify argument locations...
    bint is_vararg_cc(callcnv_t cc)  # Does the calling convention use ellipsis?
    bint is_purging_cc(callcnv_t cc)  # Does the calling convention clean the stack arguments...
    bint is_golang_cc(callcnv_t cc)  # GO language calling convention (return value in stack)?
    bint is_custom_callcnv(callcnv_t cc)  # Is custom calling convention?
    bint is_swift_cc(callcnv_t cc)  # Swift calling convention (arguments and return values in...
    bint get_stkarg_area_info(stkarg_area_info_t* out, callcnv_t cc)  # ---------------------------------------------------------...
    callcnv_t register_custom_callcnv(custom_callcnv_t& ccinf)  # Register a calling convention 
    bint unregister_custom_callcnv(callcnv_t callcnv)  # Unregister a calling convention 
    custom_callcnv_t* get_custom_callcnv(callcnv_t callcnv)  # Retrieve custom calling convention details
    callcnv_t find_custom_callcnv(char* name)  # Find a calling convention by its name 
    size_t get_custom_callcnvs(qstrvec_t* names, callcnvs_t* codes)  # Get all custom calling conventions 
    comp_t get_comp(comp_t comp)  # Get compiler bits
    char* get_compiler_name(comp_t id)  # Get full compiler name
    char* get_compiler_abbr(comp_t id)  # Get abbreviated compiler name
    void get_compilers(compvec_t* ids, qstrvec_t* names, qstrvec_t* abbrs)  # Get names of all built-in compilers
    comp_t is_comp_unsure(comp_t comp)  # See ::COMP_UNSURE
    comp_t default_compiler()  # Get compiler specified by {inf,idainfo,cc}
    bint is_gcc()  # Is the target compiler ::COMP_GNU?
    bint is_gcc32()  # Is the target compiler 32 bit gcc?
    bint is_gcc64()  # Is the target compiler 64 bit gcc?
    bint gcc_layout()  # Should use the struct/union layout as done by gcc?
    bint set_compiler(compiler_info_t& cc, int flags, char* abiname)  # Change current compiler. 
    bint set_compiler_id(comp_t id, char* abiname)  # Set the compiler id (see
    bint set_abi_name(char* abiname, bint user_level)  # Set abi name (see
    ssize_t get_abi_name(qstring* out)  # Get ABI name. 
    bint append_abi_opts(char* abi_opts, bint user_level)  # Add/remove/check ABI option General form of full abi...
    bint remove_abi_opts(char* abi_opts, bint user_level)
    bint set_compiler_string(char* compstr, bint user_level)
    bint use_golang_cc()  # is GOLANG calling convention used by default?
    void switch_to_golang()  # switch to GOLANG calling convention (to be used as default CC)
    int convert_pt_flags_to_hti(int pt_flags)  # Convert to Type parsing flags lesser than 0x10 don't...
    bint parse_decl(tinfo_t* out_tif, qstring* out_name, til_t* til, char* decl, int pt_flags)  # Parse ONE declaration. If the input string contains more...
    bint print_type(qstring* out, ea_t ea, int prtype_flags)  # Get type declaration for the specified address. 
    int get_named_type(til_t* ti, char* name, int ntf_flags, type_t** type, p_list** fields, char** cmt, p_list** fieldcmts, sclass_t* sclass, uint32* value)  # Get named typeinfo. The returned pointers are pointers...
    int get_named_type64(til_t* ti, char* name, int ntf_flags, type_t** type, p_list** fields, char** cmt, p_list** fieldcmts, sclass_t* sclass, uint64* value)  # See get_named_type() above. 
    char* tinfo_errstr(tinfo_code_t code)  # Helper function to convert an error code into a...
    bint del_named_type(til_t* ti, char* name, int ntf_flags)  # Delete information about a symbol. 
    char* first_named_type(til_t* ti, int ntf_flags)  # Enumerate types. 
    char* next_named_type(til_t* ti, char* name, int ntf_flags)  #  
    uint32 copy_named_type(til_t* dsttil, til_t* srctil, char* name)  # Copy a named type from one til to another. This function...
    bint decorate_name(qstring* out, char* name, bint should_decorate, callcnv_t cc, tinfo_t* type)  # Decorate/undecorate a C symbol name. 
    bint gen_decorate_name(qstring* out, char* name, bint should_decorate, callcnv_t cc, tinfo_t* type)  # Generic function for decorate_name() (may be used in IDP modules)
    ssize_t calc_c_cpp_name(qstring* out, char* name, tinfo_t* type, int ccn_flags)  # Get C or C++ form of the name. 
    bint enable_numbered_types(til_t* ti, bint enable)  # Enable the use of numbered types in til. Currently it is...
    bint get_numbered_type(til_t* ti, uint32 ordinal, type_t** type, p_list** fields, char** cmt, p_list** fieldcmts, sclass_t* sclass)  # Retrieve a type by its ordinal number
    uint32 alloc_type_ordinals(til_t* ti, int qty)  # Allocate a range of ordinal numbers for new types. 
    uint32 alloc_type_ordinal(til_t* ti)  #  {alloc_type_ordinals,ti,1}
    uint32 get_ordinal_limit(til_t* ti)  # Get number of allocated ordinals + 1. If there are no...
    uint32 get_ordinal_count(til_t* ti)  # Get number of allocated ordinals. 
    bint del_numbered_type(til_t* ti, uint32 ordinal)  # Delete a numbered type
    bint set_type_alias(til_t* ti, uint32 src_ordinal, uint32 dst_ordinal)  # Create a type alias. Redirects all references to source...
    uint32 get_alias_target(til_t* ti, uint32 ordinal)  # Find the final alias destination. If the ordinal has not...
    int32 get_type_ordinal(til_t* ti, char* name)  # Get type ordinal by its name
    char* get_numbered_type_name(til_t* ti, uint32 ordinal)  # Get type name (if exists) by its ordinal. If the type is...
    ssize_t create_numbered_type_name(qstring* buf, int32 ord)  # Create anonymous name for numbered type. This name can...
    bint is_ordinal_name(char* name, uint32* ord)  # Check if the name is an ordinal name. Ordinal names have...
    void build_anon_type_name(qstring* buf, type_t* type, p_list* fields)  # Generate a name like $hex_numbers based on the field...
    int compact_numbered_types(til_t* ti, uint32 min_ord, intvec_t* p_ordmap, int flags)  # Compact numbered types to get rid of empty slots. 
    bint is_type_choosable(til_t* ti, uint32 ordinal)  # Check if a struct/union type is choosable 
    void set_type_choosable(til_t* ti, uint32 ordinal, bint value)  # Enable/disable 'choosability' flag for a struct/union type 
    ea_t get_vftable_ea(uint32 ordinal)  # Get address of a virtual function table. 
    uint32 get_vftable_ordinal(ea_t vftable_ea)  # Get ordinal number of the virtual function table. 
    bint set_vftable_ea(uint32 ordinal, ea_t vftable_ea)  # Set the address of a vftable instance for a vftable type. 
    bint del_vftable_ea(uint32 ordinal)  # Delete the address of a vftable instance for a vftable type. 
    size_t get_default_align()  # Get default alignment for structure fields. 
    void align_size(size_t& cur_tot_size, size_t elem_size, size_t algn)  # Get alignment delta for the a structure field. 
    bint deref_ptr(ea_t* ptr_ea, tinfo_t& tif, ea_t* closure_obj)  # Dereference a pointer. 
    bint remove_tinfo_pointer(tinfo_t* tif, char** pname, til_t* til)  # Remove pointer of a type. (i.e. convert "char *" into...
    int add_til(char* name, int flags)  # Load a til file and add it the database type libraries...
    bint del_til(char* name)  # Unload a til file
    bint apply_named_type(ea_t ea, char* name)  # Apply the specified named type to the address. 
    bint apply_tinfo(ea_t ea, tinfo_t& tif, uint32 flags)  # Apply the specified type to the specified address. This...
    bint apply_cdecl(til_t* til, ea_t ea, char* decl, int flags)  # Apply the specified type to the address. This function...
    bint apply_callee_tinfo(ea_t caller, tinfo_t& tif)  # Apply the type of the called function to the calling...
    bint get_arg_addrs(eavec_t* out, ea_t caller)  # Retrieve argument initialization addresses. This...
    bint apply_once_tinfo_and_name(ea_t dea, tinfo_t& tif, char* name)  # Apply the specified type and name to the address. This...
    int guess_tinfo(tinfo_t* out, tid_t id)  # Generate a type information about the id from the...
    void set_c_header_path(char* incdir)  # Set include directory path the target compiler
    ssize_t get_c_header_path(qstring* buf)  # Get the include directory path of the target compiler
    void set_c_macros(char* macros)  # Set predefined macros for the target compiler
    ssize_t get_c_macros(qstring* buf)  # Get predefined macros for the target compiler
    til_t* get_idati()  # Pointer to the local type library - this til is private...
    bint get_idainfo_by_type(size_t* out_size, flags64_t* out_flags, opinfo_t* out_mt, tinfo_t& tif, size_t* out_alsize)  # Extract information from a tinfo_t. 
    bint get_tinfo_by_flags(tinfo_t* out, flags64_t flags)  # Get tinfo object that corresponds to data flags 
    void copy_tinfo_t(tinfo_t* _this, tinfo_t& r)
    bint detach_tinfo_t(tinfo_t* _this)
    void clear_tinfo_t(tinfo_t* _this)
    bint create_tinfo(tinfo_t* _this, type_t bt, type_t bt2, void* ptr)
    int verify_tinfo(typid_t typid)
    bint get_tinfo_details(typid_t typid, type_t bt2, void* buf)
    size_t get_tinfo_size(uint32* p_effalign, typid_t typid, int gts_code)
    size_t get_tinfo_pdata(void* outptr, typid_t typid, int what)
    size_t get_tinfo_property(typid_t typid, int gta_prop)
    size_t get_tinfo_property4(typid_t typid, int gta_prop, size_t p1, size_t p2, size_t p3, size_t p4)
    size_t set_tinfo_property(tinfo_t* tif, int sta_prop, size_t x)
    size_t set_tinfo_property4(tinfo_t* tif, int sta_prop, size_t p1, size_t p2, size_t p3, size_t p4)
    bint serialize_tinfo(qtype* type, qtype* fields, qtype* fldcmts, tinfo_t* tif, int sudt_flags)
    bint deserialize_tinfo(tinfo_t* tif, til_t* til, type_t** ptype, p_list** pfields, p_list** pfldcmts, char* cmt)
    int find_tinfo_udt_member(udm_t* udm, typid_t typid, int strmem_flags)
    bint print_tinfo(qstring* result, char* prefix, int indent, int cmtindent, int flags, tinfo_t* tif, char* name, char* cmt)
    char* dstr_tinfo(tinfo_t* tif)
    int visit_subtypes(tinfo_visitor_t* visitor, type_mods_t* out, tinfo_t& tif, char* name, char* cmt)
    bint compare_tinfo(typid_t t1, typid_t t2, int tcflags)
    int lexcompare_tinfo(typid_t t1, typid_t t2, int)
    bint get_stock_tinfo(tinfo_t* tif, stock_type_id_t id)
    uint64 read_tinfo_bitfield_value(typid_t typid, uint64 v, int bitoff)
    uint64 write_tinfo_bitfield_value(typid_t typid, uint64 dst, uint64 v, int bitoff)
    bint get_tinfo_attr(typid_t typid, qstring& key, bytevec_t* bv, bint all_attrs)
    bint set_tinfo_attr(tinfo_t* tif, type_attr_t& ta, bint may_overwrite)
    bint del_tinfo_attr(tinfo_t* tif, qstring& key, bint make_copy)
    bint get_tinfo_attrs(typid_t typid, type_attrs_t* tav, bint include_ref_attrs)
    bint set_tinfo_attrs(tinfo_t* tif, type_attrs_t* ta)
    uint32 score_tinfo(tinfo_t* tif)
    tinfo_code_t save_tinfo(tinfo_t* tif, til_t* til, size_t ord, char* name, int ntf_flags)
    bint append_tinfo_covered(rangeset_t* out, typid_t typid, uint64 offset)
    bint calc_tinfo_gaps(rangeset_t* out, typid_t typid)
    bint name_requires_qualifier(qstring* out, typid_t typid, char* name, uint64 offset)
    bint value_repr_t__from_opinfo(value_repr_t* _this, flags64_t flags, aflags_t afl, opinfo_t* opinfo, array_parameters_t* ap)
    size_t value_repr_t__print_(value_repr_t* _this, qstring* result, bint colored)
    bint value_repr_t__parse_value_repr(value_repr_t* _this, qstring& attr, type_t target_type)
    ssize_t udt_type_data_t__find_member(udt_type_data_t* _this, udm_t* udm, int strmem_flags)
    ssize_t udt_type_data_t__get_best_fit_member(udt_type_data_t* _this, asize_t disp)
    uchar enum_type_data_t__get_max_serial(enum_type_data_t* ei, uint64 value)
    tinfo_code_t enum_type_data_t__set_value_repr(enum_type_data_t* ei, value_repr_t& repr)
    tinfo_code_t enum_type_data_t__get_value_repr(enum_type_data_t* ei, value_repr_t* repr)
    void tinfo_get_innermost_udm(tinfo_t* itif, tinfo_t* tif, uint64 offset, size_t* udm_idx, uint64* bit_offset, bint return_member_type)
    ssize_t get_udm_by_tid(tinfo_t* tif, udm_t* udm, tid_t tid)
    ssize_t get_edm_by_tid(tinfo_t* tif, edm_t* edm, tid_t tid)
    bint get_type_by_tid(tinfo_t* tif, tid_t tid)
    tid_t get_tinfo_tid(tinfo_t* tif, bint force_tid)
    ssize_t get_tinfo_by_edm_name(tinfo_t* tif, til_t* til, char* mname)
    ssize_t get_frame_var(tinfo_t* tif, sval_t* actval, insn_t& insn, op_t* x, sval_t v)
    bint tinfo_get_func_frame(tinfo_t* tif, func_t* pfn)
    callcnv_t guess_func_cc(func_type_data_t& fti, int npurged, int cc_flags)  # ---------------------------------------------------------...
    bint dump_func_type_data(qstring* out, func_type_data_t& fti, int praloc_bits)  # Use func_type_data_t::dump()
    bint calc_retloc(func_type_data_t* fti)
    bint calc_arglocs(func_type_data_t* fti)
    bint calc_varglocs(func_type_data_t* fti, regobjs_t* regs, relobj_t* stkargs, int nfixed)
    bint stroff_as_size(int plen, tinfo_t& tif, asize_t value)  # ---------------------------------------------------------...
    int visit_stroff_udms(udm_visitor_t& sfv, tid_t* path, int plen, adiff_t* disp, bint appzero)  # ---------------------------------------------------------...
    bint is_one_bit_mask(uval_t mask)  # ---------------------------------------------------------...
    int get_arg_align(int type_align, int slotsize, callcnv_t cc)  # ---------------------------------------------------------...
    sval_t align_stkarg_up(sval_t spoff, int type_align, int slotsize, callcnv_t cc)  # ---------------------------------------------------------...
    tinfo_t remove_pointer(tinfo_t& tif)  # ::BT_PTR: If the current type is a pointer, return the...
    error_t unpack_idcobj_from_idb(idc_value_t* obj, tinfo_t& tif, ea_t ea, bytevec_t* off0, int pio_flags)  # Read a typed idc object from the database
    error_t unpack_idcobj_from_bv(idc_value_t* obj, tinfo_t& tif, bytevec_t& bytes, int pio_flags)  # Read a typed idc object from the byte vector
    error_t pack_idcobj_to_idb(idc_value_t* obj, tinfo_t& tif, ea_t ea, int pio_flags)  # Write a typed idc object to the database
    error_t pack_idcobj_to_bv(idc_value_t* obj, tinfo_t& tif, relobj_t* bytes, void* objoff, int pio_flags)  # Write a typed idc object to the byte vector. Byte vector...
    bint apply_tinfo_to_stkarg(insn_t& insn, op_t& x, uval_t v, tinfo_t& tif, char* name)  # Helper function for the processor modules. to be called from
    void gen_use_arg_tinfos(argtinfo_helper_t* _this, ea_t caller, func_type_data_t* fti, funcargvec_t* rargs)  # Do not call this function directly, use argtinfo_helper_t
    bint func_has_stkframe_hole(ea_t ea, func_type_data_t& fti)  # Looks for a hole at the beginning of the stack...
    int lower_type(til_t* til, tinfo_t* tif, char* name, lowertype_helper_t* _helper)  # ---------------------------------------------------------...
    int replace_ordinal_typerefs(til_t* til, tinfo_t* tif)  # Replace references to ordinal types by name references....
    void begin_type_updating(update_type_t utp)  # Mark the beginning of a large update operation on the...
    void end_type_updating(update_type_t utp)  # Mark the end of a large update operation on the types...
    tid_t get_named_type_tid(char* name)  # Get named local type TID 
    bint get_tid_name(qstring* out, tid_t tid)  # Get a type name for the specified TID 
    uint32 get_tid_ordinal(tid_t tid)  # Get type ordinal number for TID 
    ssize_t get_udm_by_fullname(udm_t* udm, char* fullname)  # Get udt member by full name 
    bint get_idainfo_by_udm(flags64_t* flags, opinfo_t* ti, udm_t& udm, ea_t refinfo_ea)  # Calculate IDA info from udt member 
    tid_t create_enum_type(char* enum_name, enum_type_data_t& ei, int enum_width, type_sign_t sign, bint convert_to_bitmask, char* enum_cmt)  # Create type enum 
    bint format_cdata(qstrvec_t* outvec, idc_value_t& idc_value, tinfo_t* tif, valstr_t* vtree, format_data_info_t* fdi)  # Format a data value as a C initializer. 
    int print_cdata(text_sink_t& printer, idc_value_t& idc_value, tinfo_t* tif, format_data_info_t* fdi)  # The same as format_cdata(), but instead of returning the...
    int print_decls(text_sink_t& printer, til_t* til, ordvec_t* ordinals, uint32 pdf_flags)  # Print types (and possibly their dependencies) in a...
    int calc_number_of_children(argloc_t& loc, tinfo_t& tif, bint dont_deref_ptr)  # Calculate max number of lines of a formatted c data,...
    bint get_enum_member_expr(qstring* buf, tinfo_t& tif, int serial, uint64 value)  # Return a C expression that can be used to represent an...
    bint choose_named_type(til_symbol_t* out_sym, til_t* root_til, char* title, int ntf_flags, predicate_t* predicate)  # Choose a type from a type library. 
